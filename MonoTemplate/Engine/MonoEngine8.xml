<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MonoEngine8</name>
    </assembly>
    <members>
        <member name="T:Engine.AnimatedTexture">
            <summary>
            holds data about a sprites textures and allows for definitions of the frames
            </summary>
        </member>
        <member name="F:Engine.AnimatedTexture.textures">
            <summary>
            holds refs to the textures used by this sprite
            </summary>
        </member>
        <member name="F:Engine.AnimatedTexture.texturePortion">
            <summary>
            holds the retangles containing the graphics for the frames
            </summary>
        </member>
        <member name="F:Engine.AnimatedTexture.collisionPortion">
            <summary>
            Holds the collision area for the frames
            </summary>
        </member>
        <member name="F:Engine.AnimatedTexture.collisionScaling">
            <summary>
            specifies any additional scaling to be used to alter collisionPortion
            </summary>
        </member>
        <member name="F:Engine.AnimatedTexture.collisionOffset">
            <summary>
            Specifies an offset to apply to the collision portion. useful for characters where the hit box should 
            allow parts of the sprite to overlap others (such as in forced perspective games like bomberman etc...
            </summary>
        </member>
        <member name="F:Engine.AnimatedTexture.totalFrames">
            <summary>
            holds the number of frames currently existing for this sprite
            </summary>
        </member>
        <member name="F:Engine.AnimatedTexture.Animator">
            <summary>
            The textures animator
            </summary>
        </member>
        <member name="F:Engine.AnimatedTexture.boss">
            <summary>
            a reference to the sprite
            </summary>
        </member>
        <member name="M:Engine.AnimatedTexture.#ctor(Engine.SpriteBase)">
            <summary>
            Constructor
            </summary>
            <param name="boss">reference to owner of this</param>
        </member>
        <member name="P:Engine.AnimatedTexture.Count">
            <summary>
            Gets the number of animation frames for this animated texture
            </summary>
        </member>
        <member name="P:Engine.AnimatedTexture.TextureCurrent">
            <summary>
            gets the texture currently being used by this sprites animation frame
            </summary>
        </member>
        <member name="M:Engine.AnimatedTexture.TextureFor(System.Int32)">
            <summary>
            Returns the texture used for the particular
            frame given
            </summary>
            <param name="thisFrame">The frame number to get the texture of</param>
            <returns>the texture reference or null if the frame was out of range</returns>
        </member>
        <member name="M:Engine.AnimatedTexture.CentreCurrent(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            passes back the centre of the current frame
            </summary>
            <param name="centre">a vector 2 to hold the centre value</param>
        </member>
        <member name="P:Engine.AnimatedTexture.DimensionCurrent">
            <summary>
            returns the width and height of the current texture portion
            </summary>
            <returns>The width and height of the portion</returns>
        </member>
        <member name="M:Engine.AnimatedTexture.DimensionsFor(System.Int32)">
            <summary>
            retreives the dimensions of the given frame
            </summary>
            <param name="thisFrame">the frame you want the dimensions for</param>
            <returns>the width and height of the given frame</returns>
        </member>
        <member name="M:Engine.AnimatedTexture.RectangleCurrent(Microsoft.Xna.Framework.Rectangle@)">
            <summary>
            Returns the rectangle for the current animation frame
            </summary>
            <param name="rect">A rectangle to store the requested rectangle in</param>
        </member>
        <member name="P:Engine.AnimatedTexture.RectangleCurrentGet">
            <summary>
            gets the rectangular portion for the current frame of animation
            </summary>
        </member>
        <member name="M:Engine.AnimatedTexture.RectangleFor(System.Int32,Microsoft.Xna.Framework.Rectangle@)">
            <summary>
            Returns the rectangle used for the particular frame given
            </summary>
            <param name="thisFrame">The frame number to get the rectangle of</param>
            <param name="rect">The rectangle for the frame or a zero rectangle if frame out of range</param>
        </member>
        <member name="M:Engine.AnimatedTexture.CollisionCurrent(Microsoft.Xna.Framework.Rectangle@)">
            <summary>
            Returns the collision rectangle for the current animation frame
            </summary>
            <param name="rect">A rectangle to store the requested rectangle in</param>
        </member>
        <member name="M:Engine.AnimatedTexture.CollisionFor(System.Int32,Microsoft.Xna.Framework.Rectangle@)">
            <summary>
            Returns the collision rectangle used for the particular frame given
            </summary>
            <param name="thisFrame">The frame number to get the rectangle of</param>
            <param name="rect">The rectangle for the frame or a zero rectangle if frame out of range</param>
        </member>
        <member name="F:Engine.AnimatedTexture._X">
            <summary>
            x and y values for calculations
            </summary>
        </member>
        <member name="F:Engine.AnimatedTexture._Y">
            <summary>
            x and y values for calculations
            </summary>
        </member>
        <member name="M:Engine.AnimatedTexture.CollisionCurrentAdjustedRenderSpace(Microsoft.Xna.Framework.Rectangle@,System.Single,System.Single)">
            <summary>
            sets the adjusted collision rectangle for the current animation frame
            in render space
            </summary>
            <param name="rect">A rectangle to store the requested rectangle in</param>
            <param name="pvx">the viewport X position</param>
            <param name="pvy">the viewport y position</param>
        </member>
        <member name="M:Engine.AnimatedTexture.SetCollisionSize">
            <summary>
            pre-calculates the collision size of the sprite
            </summary>
        </member>
        <member name="F:Engine.AnimatedTexture.collisionWidthDiv2">
            <summary>
            pre-calculated collision width divided by 2
            </summary>
        </member>
        <member name="F:Engine.AnimatedTexture.CollisionHeightDiv2">
            <summary>
            pre-calculated collision height divided by 2
            </summary>
        </member>
        <member name="F:Engine.AnimatedTexture.CollisionWidth">
            <summary>
            pre-calculated collision Width
            </summary>
        </member>
        <member name="F:Engine.AnimatedTexture.CollisionHeight">
            <summary>
            pre-calculated collisionHeight
            </summary>
        </member>
        <member name="M:Engine.AnimatedTexture.SetOffsetPosition">
            <summary>
            pre-calculates the offset for the sprites collision area
            changes when scale changes or frame changes
            </summary>
        </member>
        <member name="F:Engine.AnimatedTexture.ScaledCollisionOffsetX">
            <summary>
            holds pre-calculated collision offset in the X direction
            </summary>
        </member>
        <member name="F:Engine.AnimatedTexture.ScaledCollisionOffsetY">
            <summary>
            holds pre-calculated collision offset in the Y direction
            </summary>
        </member>
        <member name="M:Engine.AnimatedTexture.DefineSlidingFrames(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle,Engine.SlideMethod,System.Int32)">
            <summary>
            Creates animation frames automatically for an sliding sprite ( a graphic split into 
            several sections along its width or height)
            </summary>
            <param name="texture">The texture where this sprites graphic can be found</param>
            <param name="fullImagePortion">The rectangle that defines the sprite when full (the whole image)</param>
            <param name="slideLikeThis">specify the how you want the sprite to appear or dissapear</param>
            <param name="framesStepsRequired">How many steps are required for the image to appear or dissapear  (number of frames of animation)</param>
            <remarks>The number of steps needs to go into the width or height of your sprite an even number of times for the best effect 
            for example if you full sprite is 100 pixels wide then it could be split into 20 steps (5 pixels each)</remarks>
        </member>
        <member name="M:Engine.AnimatedTexture.SetNewVideoFrame(Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            Sets the latest frame of video for a sprite, a true value is returned if this was the first frame set for the sprite, this can allow you to 
            then test for this and do other work with the sprite (such as scaling) which requires frame data
            </summary>
            <param name="videoTexture">The current video texture to display</param>
            <returns>true if this was the first frame set for this sprite, false if it is not</returns>
        </member>
        <member name="M:Engine.AnimatedTexture.DefineVideo(Engine.VideoManager)">
            <summary>
            Gets a sprite ready to show a video with the help of a VideoManager
            </summary>
            <param name="videoManager">The video manager with a loaded video ready</param>
        </member>
        <member name="M:Engine.AnimatedTexture.Define(System.Collections.Generic.List{Microsoft.Xna.Framework.Graphics.Texture2D})">
            <summary>
            defines a animation frame for each texture in a given list using the entire texture
            </summary>
            <param name="textures">The texture list to define frames from</param>
        </member>
        <member name="M:Engine.AnimatedTexture.Define(Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            defines a animation frame that just uses an entire texture for the frame
            </summary>
            <param name="texture">The texture to use for this frame</param>
        </member>
        <member name="M:Engine.AnimatedTexture.Define(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            defines a animation frames texture that just uses an entire texture for the frame, with a scale factor and an offset to apply to collision area
            </summary>
            <param name="texture">The texture to use for this frame</param>
            <param name="collisionScale">The amount to increase or reduce the collision area (frame) of the sprite new Vector2(1,1) is no scaling</param>
            <param name="collisionOffset">the amount to offset the collision area of the sprite new Point(0,0) is no offset</param>
        </member>
        <member name="M:Engine.AnimatedTexture.Define(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            Defines a frame of animation for the sprite
            </summary>
            <param name="texture">The texture for this frame</param>
            <param name="frameRectangle">the rectangle portion with the image for this frame</param>
            <param name="collisionRectangle">A collision rectangle defines the size of the collision rectangle for this frame. if different from frameRectangle</param>
        </member>
        <member name="M:Engine.AnimatedTexture.Define(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            defines a animation frames texture and rectangluar portion
            </summary>
            <param name="texture">The texture to use for this frame</param>
            <param name="frameRectangle">The rectangular area of the texture containing the image for the frame</param>
        </member>
        <member name="M:Engine.AnimatedTexture.Define(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            defines a animation frames texture and rectangluar portion, with a scale factor and an offset to apply to collision area
            </summary>
            <param name="texture">The texture to use for this frame</param>
            <param name="frameRectangle">The rectangular area of the texture containing the image for the frame</param>
            <param name="collisionScale">The amount to increase or reduce the collision area (frame) of the sprite new Vector2(1,1) is no scaling</param>
            <param name="collisionOffset">the amount to offset the collision area of the sprite new Point(0,0) is no offset</param>
        </member>
        <member name="M:Engine.AnimatedTexture.Define(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            creates a frame of animation
            </summary>
            <param name="texture">texture containing the graphic</param>
            <param name="frameRectangle">the rectangle on the given texture specifying the graphic to display</param>
            <param name="collisionRectangle">the collision rectangle to use for this frame</param>
            <param name="collisionScale">the scaling to provide for collisions in x and y direction as a point</param>
            <param name="collisionOffset">the offset to apply to the collision rectangle in x and y direction</param>
        </member>
        <member name="M:Engine.AnimatedTexture.DefineFrom(Engine.Sprite)">
            <summary>
            defines the frames for a sprite based on the ones already defined in the given sprite
            </summary>
            <param name="frameSource">A sprite whose frame definitions we want to copy</param>
        </member>
        <member name="T:Engine.AnimationState">
            <summary>
            holds a specific state of animation for a sprite
            </summary>
        </member>
        <member name="F:Engine.AnimationState._animationControl">
            <summary>
            holds the method by which to animate this texture
            defaults to none
            </summary>
        </member>
        <member name="F:Engine.AnimationState.AnimationEndAction">
            <summary>
            holds what to do when we reach the last frame default is stop
            </summary>
        </member>
        <member name="F:Engine.AnimationState.activeFrame">
            <summary>
            currently active frame texture
            </summary>
        </member>
        <member name="F:Engine.AnimationState._firstFrame">
            <summary>
            the first frame of the current animation sequence
            </summary>
        </member>
        <member name="F:Engine.AnimationState._lastFrame">
            <summary>
            the last frame of current animation sequence
            </summary>
        </member>
        <member name="F:Engine.AnimationState._animationDirection">
            <summary>
            either 1 or -1 animate forwards or in reverse
            </summary>
        </member>
        <member name="F:Engine.AnimationState._distance">
            <summary>
            holds the distance to check the sprites movement against
            for movement animation
            </summary>
        </member>
        <member name="F:Engine.AnimationState._lastPositionCheck">
            <summary>
            The last recorded position of the sprite for distance animation checks
            </summary>
        </member>
        <member name="F:Engine.AnimationState._elapsedTime">
            <summary>
            holds the elapsed time so far for this timer based animation
            </summary>
        </member>
        <member name="F:Engine.AnimationState._animationPeriod">
            <summary>
            the period of time before animation should occur
            </summary>
        </member>
        <member name="F:Engine.AnimationState.LoopCount">
            <summary>
            indicates how many times animation has looped (only makes sense for repeat style animations)
            </summary>
        </member>
        <member name="F:Engine.AnimationState.nextState">
            <summary>
            holds a link to the state to work with next
            </summary>
        </member>
        <member name="M:Engine.AnimationState.ToString">
            <summary>
            produces a string containing the animation state
            </summary>
            <returns></returns>
        </member>
        <member name="T:Engine.Animator">
            <summary>
            controls animation frames for a sprite
            </summary>
        </member>
        <member name="P:Engine.Animator.AnimateCallBack">
            <summary>
            a delegate which is called whenever the animation frame changes
            it is called after the frame is changed so you can override the frame settings
            </summary>
        </member>
        <member name="P:Engine.Animator.SequenceEndCallBack">
            <summary>
            a delegate which is called whenever the animation sequence ends,
            use this to do things whenever a phase of animation changes
            </summary>
        </member>
        <member name="F:Engine.Animator.resumeState">
            <summary>
            holds the animation method stored when animation paused
            </summary>
        </member>
        <member name="F:Engine.Animator.AllowDuplicates">
            <summary>
            set to allow us to create duplicate animation settings (which would not make sense most of the time)
            defaults to false - no duplicates
            </summary>
        </member>
        <member name="F:Engine.Animator.RestartDuplicate">
            <summary>
            if true (defaults to true) then duplicate animations are overwritten and reset, this may or not be the behaviour you want
            </summary>
        </member>
        <member name="F:Engine.Animator.CyclicOverwrite">
            <summary>
            if true will remove the current animation if we are applying a different animation that stays active
            these include, repeat, reverse, halt and stop LastFrameActions.
            The default for this is (true). If you wish to override this behaviour and allow extra states to be generated then set this to false.
            You can manually decide this yourself using RemoveAnimationIfDifferent(int,int)
            </summary>
        </member>
        <member name="M:Engine.Animator.AutoRevertState(Engine.LastFrameAction,System.Int32,System.Int32)">
            <summary>
            determines if we are going to replace the existing animation
            </summary>
        </member>
        <member name="F:Engine.Animator.MaxState">
            <summary>
            maximum number of states that are allowed to be stacked/configured at any one time
            </summary>
        </member>
        <member name="F:Engine.Animator.State">
            <summary>
            holds a stack on animation states, which can be stacked or configured to work in a linked list way
            </summary>
        </member>
        <member name="P:Engine.Animator.StateList">
            <summary>
            gets the animation state stack
            </summary>
        </member>
        <member name="P:Engine.Animator.CurrentState">
            <summary>
            gets the current active state for quick manipulation of values (when this is needed)
            </summary>
        </member>
        <member name="F:Engine.Animator._activeState">
            <summary>
            holds the current state being used for animation control
            </summary>
        </member>
        <member name="P:Engine.Animator.ActiveState">
            <summary>
            gets the currently active animation state
            </summary>
        </member>
        <member name="F:Engine.Animator._totalStates">
            <summary>
            holds the number of states in the buffer - might not need
            </summary>
        </member>
        <member name="P:Engine.Animator.StateCount">
            <summary>
            gets the total number of animation states set for this sprite
            </summary>
        </member>
        <member name="P:Engine.Animator.Animating">
            <summary>
            Determines if the system is animating
            </summary>
        </member>
        <member name="P:Engine.Animator.activeFrame">
            <summary>
            gets the currently active frame of the sprite based on the current
            state being used
            </summary>
        </member>
        <member name="M:Engine.Animator.ClearAndContinue">
            <summary>
            forces any animation states to be removed leaving just the default manual animation state
            as the active one in whatever state it was in before any animations started
            </summary>
        </member>
        <member name="M:Engine.Animator.RemoveAnimationIfDifferent(System.Int32,System.Int32)">
            <summary>
            removes active animation state if we want to attempt to start a different animation set. 
            Use this when changing animation part way through a sequence such as when changing direction when walking
            </summary>
            <param name="start">first frame of animation</param>
            <param name="end">last frame of animation</param>
        </member>
        <member name="M:Engine.Animator.ClearAndReset">
            <summary>
            clears all animation states and sets the default manual animation to its starting values
            </summary>
        </member>
        <member name="M:Engine.Animator.RevertAndContinue">
            <summary>
            stops the current animation and drops back to a previous state if one exists
            </summary>
        </member>
        <member name="M:Engine.Animator.RevertAndContinue(System.Int32)">
            <summary>
            reverts to a previous state setting the current frame
            </summary>
            <param name="withThisFrame"></param>
        </member>
        <member name="M:Engine.Animator.RevertAndRestart">
            <summary>
            stops current animation and drops back to previous state, resetting it to its starting values
            </summary>
        </member>
        <member name="F:Engine.Animator.boss">
            <summary>
            reference to the animators sprite
            </summary>
        </member>
        <member name="M:Engine.Animator.#ctor(Engine.SpriteBase)">
            <summary>
            Constructor - creates a new animator
            </summary>
            <param name="boss">The sprite who owns the animator</param>
        </member>
        <member name="P:Engine.Animator.Distance">
            <summary>
            gets or sets the animation distance for distance based animation.
            Consider whether you should be doing this
            or setting a new animation state
            </summary>
        </member>
        <member name="P:Engine.Animator.Rate">
            <summary>
            gets or sets the rate of a time based animation.
            Consider whether you should be doing this
            or setting a new animation state
            </summary>
        </member>
        <member name="M:Engine.Animator.RangeAdjust(System.Int32,System.Int32)">
            <summary>
            adjusts the animation range for the active animation settings
            </summary>
            <param name="startFrame">first frame of the animation sequence</param>
            <param name="endFrame">last frame of animation sequence</param>
        </member>
        <member name="M:Engine.Animator.RangeAdjustAndSet(System.Int32,System.Int32)">
            <summary>
            adjusts the animation range for the active animation settings
            and sets animation frame to the first one specified unless frame settings haven't changed
            </summary>
            <param name="startFrame">first frame of the animation sequence</param>
            <param name="endFrame">last frame of animation sequence</param>
        </member>
        <member name="M:Engine.Animator.RangeClear">
            <summary>
            adjusts the animation range for the active animation settings to include all frames
            </summary>
        </member>
        <member name="M:Engine.Animator.Reset">
            <summary>
            resets the current animation state
            </summary>
        </member>
        <member name="M:Engine.Animator.Pause">
            <summary>
            pauses the current animation settings, you cannot do any other animation until resume as been called
            </summary>
        </member>
        <member name="M:Engine.Animator.Resume">
            <summary>
            Resumes animation from a paused state
            </summary>
        </member>
        <member name="M:Engine.Animator.AnimateDistance(System.Double,Engine.LastFrameAction)">
            <summary>
            Sets up a move based animation, which will change the animation frame each time the sprite covers
            the specified distance, this uses all available animation frames
            </summary>
            <param name="distance">The distance to move before animation occurs</param>
            <param name="lastAction">The action to take when we get to the last frame of animation</param>
        </member>
        <member name="M:Engine.Animator.AnimateDistance(System.Double,Engine.LastFrameAction,System.Int32,System.Int32)">
            <summary>
            Sets up a move based animation, which will change the animation frame each time the sprite covers
            the specified distance
            </summary>
            <param name="distance">The distance to move before animation occurs</param>
            <param name="lastAction">The action to take when we get to the last frame of animation</param>
            <param name="startFrame">first frame of the animation sequence</param>
            <param name="endFrame">last frame of animation sequence</param>
            <returns>true if animation stack had space, false if not</returns>
        </member>
        <member name="M:Engine.Animator.AnimateRate(System.Single,Engine.LastFrameAction)">
            <summary>
            Sets up a rate based animation, which changes after a period of time using all the frames of the sprite
            </summary>
            <param name="animationPeriod">the number of seconds to pass before changing frame</param>
            <param name="lastAction">The action to take when we get to the last frame of animation</param>
        </member>
        <member name="M:Engine.Animator.AnimateRate(System.Single,Engine.LastFrameAction,System.Int32,System.Int32)">
            <summary>
            Sets up a rate based animation, which changes after a period of time
            </summary>
            <param name="animationPeriod">the number of seconds to pass before changing frame</param>
            <param name="lastAction">The action to take when we get to the last frame of animation</param>
            <param name="startFrame">first frame of the animation sequence</param>
            <param name="endFrame">last frame of animation sequence</param>
            <returns>true if animation stack had space, false if not</returns>
        </member>
        <member name="M:Engine.Animator.AnimateUpdate(Engine.LastFrameAction)">
            <summary>
            Sets up an update based animation, which will change the animation frame every time the sprite is updated
            this can be used in conjunction with the sprites updates rate to create space invaders style animation.
            this uses all available animation frames
            </summary>
            <param name="lastAction">The action to take when we get to the last frame of animation</param>
        </member>
        <member name="M:Engine.Animator.AnimateUpdate(Engine.LastFrameAction,System.Int32,System.Int32)">
            <summary>
            Sets up an update based animation, which will change the animation frame every time the sprite is updated
            this can be used in conjunction with the sprites updates rate to create space invaders style animation
            </summary>
            <param name="lastAction">The action to take when we get to the last frame of animation</param>
            <param name="startFrame">first frame of the animation sequence</param>
            <param name="endFrame">last frame of animation sequence</param>
            <returns>true if animation stack had space, false if not</returns>
        </member>
        <member name="M:Engine.Animator.SetAnimationOrderForCurrentState(System.Boolean)">
            <summary>
            ensures correct ranges are set for animation settings
            </summary>
        </member>
        <member name="M:Engine.Animator.Update">
            <summary>
            Updates the animation for the sprite
            </summary>
        </member>
        <member name="M:Engine.Animator.ShowFirst">
            <summary>
            Move to the first animation frame in the previously specified sequence
            </summary>
        </member>
        <member name="M:Engine.Animator.ShowLast">
            <summary>
            Move to the last animation frame in the previously specified sequence
            </summary>
        </member>
        <member name="M:Engine.Animator.ShowNext">
            <summary>
            Advance to next frame in the previously specified sequence
            Checking for correction conditions automatically
            </summary>
        </member>
        <member name="M:Engine.Animator.ShowPrevious">
            <summary>
            Advance to previous frame in the previously specified sequence
            Checking for correction conditions automatically
            </summary>
        </member>
        <member name="M:Engine.Animator.Show(System.Int32)">
            <summary>
            Sets active frame of the Sprite to the one specified 
            </summary>
            <param name="thisFrame">The frame of animation we wish to display</param>
            <remarks>If the frame given is outside the range available then this will be corrected</remarks>
        </member>
        <member name="F:Engine.Animator._check_Animation">
            <summary>
            holds a reference to the active animation state
            </summary>
        </member>
        <member name="M:Engine.Animator.CheckAnimationEnd">
            <summary>
            Works out what to do when the end of frame list has been exceded
            </summary>
        </member>
        <member name="M:Engine.Animator.EndActionToString(Engine.LastFrameAction)">
            <summary>
            returns a textual version of the end action
            </summary>
            <param name="lastFrameAction"></param>
            <returns></returns>
        </member>
        <member name="T:Engine.AStarSearcheable">
            <summary>
            interface that must be implemented to allow the AStar algorithm to work with your tilemap
            </summary>
        </member>
        <member name="P:Engine.AStarSearcheable.unitDistance">
            <summary>
            the distance estimate to move laterally between neighbour tiles
            </summary>
        </member>
        <member name="P:Engine.AStarSearcheable.unitDiagonalDistance">
            <summary>
            the distance estimate to move diagonally between neighbour tiles
            </summary>
        </member>
        <member name="M:Engine.AStarSearcheable.Navigatable(Microsoft.Xna.Framework.Point)">
            <summary>
            a method that checks at specified location and returns true if it is navigatable or false if it is not
            </summary>
            <param name="location">A tile location for your method to check</param>
            <returns>true if navigatable or false if not</returns>
        </member>
        <member name="M:Engine.AStarSearcheable.SetColour(System.Int32,System.Int32,Microsoft.Xna.Framework.Color)">
            <summary>
            sets a colour wash for a tile location, 
            this is only needed if you use the colour indremental versions
            </summary>
            <param name="x">x coord</param>
            <param name="y">y coord</param>
            <param name="c">colour</param>
        </member>
        <member name="M:Engine.AStarSearcheable.BriefHighlight(System.Int32,System.Int32)">
            <summary>
            A routine called when an existing open tile and has it's gcost improved,
            this is only needed if you use the colour indremental versions
            </summary>
            <param name="x">x location of tile</param>
            <param name="y">y location of tile</param>
        </member>
        <member name="M:Engine.AStarSearcheable.BriefHighlightCurrent(System.Int32,System.Int32)">
            <summary>
            A routine called when an existing open tile is selected as the current one to explore neighbours of
            this is only needed if you use the colour indremental versions
            </summary>
            <param name="x">x location of tile</param>
            <param name="y">y location of tile</param>
        </member>
        <member name="M:Engine.AStarSearcheable.Distance(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>
            your heuristic method needs to return the distance between two tiles
            this needs to take into account whatever your unit distance settings were
            The better the heuristic the less likely you are to get inefficient paths generated
            </summary>
            <param name="start">start tile location</param>
            <param name="target">destination tile location</param>
            <returns>an integer distance between the two tiles</returns>
        </member>
        <member name="T:Engine.AStar">
            <summary>
            provides an AStar search function for a tilemap
            
            </summary>
        </member>
        <member name="T:Engine.AStar.Node">
            <summary>
            a node in the search space
            </summary>
        </member>
        <member name="F:Engine.AStar.Node.location">
            <summary>
            tile location
            </summary>
        </member>
        <member name="F:Engine.AStar.Node.parent">
            <summary>
            a reference to the tile that spawn this one
            </summary>
        </member>
        <member name="F:Engine.AStar.Node.gCost">
            <summary>
            distance cost from start tile
            </summary>
        </member>
        <member name="F:Engine.AStar.Node.hCost">
            <summary>
            distance cost from target tile
            </summary>
        </member>
        <member name="F:Engine.AStar.Node.fCost">
            <summary>
            total cost of using this tile (g + h)
            </summary>
        </member>
        <member name="P:Engine.AStar.Node.GCost">
            <summary>
            when GCost is set the fcost is automatically re-calculated
            </summary>
        </member>
        <member name="M:Engine.AStar.Node.#ctor(Microsoft.Xna.Framework.Point,Engine.AStar.Node,System.Int32,System.Int32)">
            <summary>
            constructs a node with settings
            </summary>
            <param name="loc">location of node</param>
            <param name="parent">spawner of this node</param>
            <param name="g">cost from start node to this node</param>
            <param name="h">cost of moving from this node to target node</param>
        </member>
        <member name="P:Engine.AStar.closedSet">
            <summary>
            contains nodes examined 
            </summary>
        </member>
        <member name="P:Engine.AStar.openSet">
            <summary>
            contains nodes available to explore the costs of
            </summary>
        </member>
        <member name="F:Engine.AStar.traverseMap">
            <summary>
            reference to the tile implementation of the interface
            </summary>
        </member>
        <member name="F:Engine.AStar.ordinalonly">
            <summary>
            determines whether ordinal or subordinal directions must be followed
            </summary>
        </member>
        <member name="F:Engine.AStar.ncEqual">
            <summary>
            Generic List comparerer for nodes
            </summary>
        </member>
        <member name="F:Engine.AStar.target">
            <summary>
            end tile location
            </summary>
        </member>
        <member name="F:Engine.AStar.start">
            <summary>
            start tile location
            </summary>
        </member>
        <member name="P:Engine.AStar.nodemap">
            <summary>
            a nodemap for quickly looking up open nodes that need gcosts and parents updating
            </summary>
        </member>
        <member name="F:Engine.AStar.current">
            <summary>
            holds the current Node being examined
            </summary>
        </member>
        <member name="P:Engine.AStar.closedSetN">
            <summary>
            a Read only accessor for the closed set
            </summary>
        </member>
        <member name="P:Engine.AStar.openSetN">
            <summary>
            Read only accessor for the open set
            </summary>
        </member>
        <member name="M:Engine.AStar.StartIterateGraphColour(Engine.NetworkNode,Engine.NetworkNode,Engine.BriefHighlightNode,Engine.BriefHighlightNode,Engine.BriefHighlightNode)">
            <summary>
            Sets up the search of a graph with colour highlighting call backs, Use iterateGraph to perform search steps
            </summary>
            <param name="start">start node</param>
            <param name="end">end node</param>
            <param name="cheapestCallBack">Method to call when cheapest node selected</param>
            <param name="neighbourCallBack">Method to call when a neighbour node is selected</param>
            <param name="updateNeighbourCallBack">Method to call when a neighbours cost is updated</param>
        </member>
        <member name="M:Engine.AStar.IterateGraphColour">
            <summary>
            performs one iteration of the openset, with highlight call backs activated
            </summary>
            <returns>a route of network nodes if a path is found, null if search needs more iteration, or a single network node with the name No Route if no path is possible (open set is exhausted)</returns>
        </member>
        <member name="M:Engine.AStar.StartIterateGraph(Engine.NetworkNode,Engine.NetworkNode)">
            <summary>
            Sets up the search of a graph with colour highlighting call backs, Use iterateGraph to perform search steps
            </summary>
            <param name="start">start node</param>
            <param name="end">end node</param>
        </member>
        <member name="M:Engine.AStar.IterateGraph">
            <summary>
            performs one iteration of the openset
            </summary>
            <returns>a route of network nodes if a path is found, null if search needs more iteration, or a single network node with the name No Route if no path is possible (open set is exhausted)</returns>
        </member>
        <member name="M:Engine.AStar.GetPath(Engine.NetworkNode,Engine.NetworkNode)">
            <summary>
            Calculates the entire route from start to finish in one session
            </summary>
            <param name="start">The start node</param>
            <param name="end">The destination node</param>
            <returns>a List of network nodes comprising the path if a route is possible or null if not</returns>
        </member>
        <member name="M:Engine.AStar.StartPathColour(Engine.TileMap,Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point,System.Boolean,Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Color)">
            <summary>
            Activate the AStar routine for single pass iterations
            </summary>
            <param name="map">tilemap which must implement AStarSearchable interface</param>
            <param name="start">start location in map</param>
            <param name="target">target location in map</param>
            <param name="ordinals">Set to true to only allow ordinal movement, if false diagonals are permitted</param>
            <param name="closeSetColour">The colour render items in the closed set</param>
            <param name="openSetColour">The colour to render items in the openset</param>
            <param name="routeColour">the colour to render the items in the route</param>
        </member>
        <member name="M:Engine.AStar.IterateColour">
            <summary>
            do one more iteration/expansion of the open list, using colour markers
            </summary>
            <returns>A list of Points or null if more iterations needed</returns>
        </member>
        <member name="M:Engine.AStar.StartPath(Engine.TileMap,Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point,System.Boolean)">
            <summary>
            Activate the AStar routine for single pass iterations
            </summary>
            <param name="map">tilemap which must implement AStarSearchable interface</param>
            <param name="start">start location in map</param>
            <param name="target">target location in map</param>
            <param name="ordinals">Set to true to only allow ordinal movement, if false diagonals are permitted</param>
        </member>
        <member name="M:Engine.AStar.Iterate">
            <summary>
            do one more iteration/expansion of the open list, using colour markers
            </summary>
            <returns>A list of Points or null if more iterations needed</returns>
        </member>
        <member name="M:Engine.AStar.GetPath(Engine.TileMap,Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point,System.Boolean)">
            <summary>
            Calculates the entire route from start to finish in one session
            </summary>
            <param name="map">TileMap to navigate</param>
            <param name="start"></param>
            <param name="target"></param>
            <param name="ordinalsOnly"></param>
            <returns></returns>
        </member>
        <member name="M:Engine.AStar.GetPathAsync(Engine.TileMap,Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point,System.Boolean,System.Int32,Engine.PathCallBack)">
            <summary>
            Performs an A* search of the given map calling your provided callback when the search is finished
            </summary>
            <param name="map">The AStarSearchable tilemap to work with</param>
            <param name="start">The start tile to search from</param>
            <param name="target">the tile to attempt to reach</param>
            <param name="ordinalsOnly">if true search NESW only if false use N NE E SE S SW W NW directions</param>
            <param name="sleepTime">set to -1 to run full speed, or specify number of milliseconds to pause between iterations</param>
            <param name="onfinish">the method to call</param>
        </member>
        <member name="M:Engine.AStar.AbandonAsyncSearch">
            <summary>
            stop an asynchronus search from delivering a result
            you will need to do this from your clean up code
            </summary>
        </member>
        <member name="M:Engine.AStar.SearchAsync">
            <summary>
            performs the A*Search asynchronusly
            </summary>
        </member>
        <member name="M:Engine.AStar.Reconstruct(Engine.AStar.Node)">
            <summary>
            works backwards from node at target location following parents until at start node
            </summary>
            <param name="current">the node to start walking backwards from</param>
            <returns></returns>
        </member>
        <member name="M:Engine.AStar.GetLowestFScore(System.Collections.Generic.List{Engine.AStar.Node})">
            <summary>
            very ineffecient linear search, needs a heap method really to hold nodes
            </summary>
            <param name="set">the node list to search</param>
            <returns>reference to lowest node found</returns>
        </member>
        <member name="T:Engine.AStarTileMap">
            <summary>
            a get you going TileMap with built in default A Star components
            </summary>
        </member>
        <member name="P:Engine.AStarTileMap.unitDiagonalDistance">
            <summary>
            the heuristic distance for a diagonal move
            defaults to 28
            </summary>
        </member>
        <member name="P:Engine.AStarTileMap.unitDistance">
            <summary>
            the heuristic distance for a horizontal or vertical move
            defaults to 20
            </summary>
        </member>
        <member name="M:Engine.AStarTileMap.BriefHighlight(System.Int32,System.Int32)">
            <summary>
            highlight for temporary tile changes
            </summary>
            <param name="x">tile column</param>
            <param name="y">tile row</param>
        </member>
        <member name="M:Engine.AStarTileMap.BriefHighlightCurrent(System.Int32,System.Int32)">
            <summary>
            highlight for current parent tile
            </summary>
            <param name="x">tile column</param>
            <param name="y">tile row</param>
        </member>
        <member name="M:Engine.AStarTileMap.Distance(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>
            heuristic for the distance between two tiles
            override to set your own heuristic
            default is (int)(PointHelper.Distance(start, target) * unitDistance)
            </summary>
            <param name="start">start tile location</param>
            <param name="target">end tile location</param>
            <returns>heuristic distance between the two tile locations</returns>
        </member>
        <member name="M:Engine.AStarTileMap.Navigatable(Microsoft.Xna.Framework.Point)">
            <summary>
            used by A star to decide if a tile is walkable defaults to 
            return ValidTile(location) and GetGraphic(location) == 0;
            override this if you need more complex behaviour
            </summary>
            <param name="location">a tile location to check</param>
            <returns>return true if location allowed, false if not</returns>
        </member>
        <member name="M:Engine.AStarTileMap.SetColour(System.Int32,System.Int32,Microsoft.Xna.Framework.Color)">
            <summary>
            sets the colour of a visited tile to orange for closed list and green for open list
            </summary>
            <param name="x">tile column</param>
            <param name="y">tile row</param>
            <param name="c">color being set</param>
        </member>
        <member name="T:Engine.IAudioManager">
            <summary>
            interface for audiomanager so we can pick it up
            </summary>
        </member>
        <member name="T:Engine.AudioManager">
            <summary>
            manages a collection of songs and sound effects
            </summary>
        </member>
        <member name="F:Engine.AudioManager.mp3List">
            <summary>
            holds all loaded mp3 tracks
            </summary>
        </member>
        <member name="F:Engine.AudioManager.effectList">
            <summary>
            holds all sound effects (wav files)
            </summary>
        </member>
        <member name="F:Engine.AudioManager.activeEffects">
            <summary>
            holds the sound effect instances that are being executed
            for managing and pan with sprites
            </summary>
        </member>
        <member name="F:Engine.AudioManager._masterVolume">
            <summary>
            holds the current master volume for managed effects
            </summary>
        </member>
        <member name="P:Engine.AudioManager.MasterVolume">
            <summary>
            The master volume for all basic managed effects (those that don't alter volume, pitch or panning automatically)
            if you change it, all currently playing standard sound effects will take on
            this volume level. If you want to work independently you will need to 
            grab hold of the effects independently using GetManagedEffect(), but you can only do
            this for sounds played with PlayManagedEffect as you need an instance name
            </summary>
        </member>
        <member name="F:Engine.AudioManager.getVisData">
            <summary>
            Specifies if we should attempt to request the visualisation data for current music
            </summary>
        </member>
        <member name="F:Engine.AudioManager.duplicateId">
            <summary>
            holds a number to allow duplicate effects to play if it happens by accident
            </summary>
        </member>
        <member name="F:Engine.AudioManager.engine">
            <summary>
            reference to the engine manager for viewport access
            </summary>
        </member>
        <member name="F:Engine.AudioManager.SongCount">
            <summary>
            number of currently loaded songs
            </summary>
        </member>
        <member name="F:Engine.AudioManager.LoadedEffects">
            <summary>
            number of currently loaded sound effects
            </summary>
        </member>
        <member name="F:Engine.AudioManager.ManagedEffects">
            <summary>
            number of currently managed sound effects
            </summary>
        </member>
        <member name="M:Engine.AudioManager.#ctor(Microsoft.Xna.Framework.Game)">
            <summary>
            creates the audio manager
            </summary>
            <param name="game"></param>
        </member>
        <member name="M:Engine.AudioManager.Game_Exiting(System.Object,System.EventArgs)">
            <summary>
            attempt to close down all audio resources on exit
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Engine.AudioManager.Initialize">
            <summary>
            initialises the audio manager
            </summary>
        </member>
        <member name="M:Engine.AudioManager.Dispose(System.Boolean)">
            <summary>
            gets rid of audio manager resources
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="F:Engine.AudioManager._upd_Vel2D">
            <summary>
            update area for scratch 2d work
            </summary>
        </member>
        <member name="F:Engine.AudioManager._upd_OTHER_POS_2D">
            <summary>
            a second 2d scratch area
            </summary>
        </member>
        <member name="F:Engine.AudioManager._upd_Vel">
            <summary>
            update area for scratch 3d work
            </summary>
        </member>
        <member name="F:Engine.AudioManager._upd_period">
            <summary>
            update holder for period
            </summary>
        </member>
        <member name="F:Engine.AudioManager._upd_VC">
            <summary>
            holds x and y positions for various actions during update for the audio engine
            </summary>
        </member>
        <member name="M:Engine.AudioManager.Update(Microsoft.Xna.Framework.GameTime)">
            <summary>
            updates for panning etc... will need to happen here
            </summary>
            <param name="gameTime">The time period to update for (not used here)</param>
        </member>
        <member name="M:Engine.AudioManager.GetSongNames(System.String)">
            <summary>
            returns a list of all the loaded song names
            </summary>
            <param name="separator">The text you want to place inbetween each song name.
            Use ~ to force a line break after each name</param>
            <returns>The formatted list of song names</returns>
        </member>
        <member name="M:Engine.AudioManager.GetEffectNames(System.String)">
            <summary>
            returns a list of all the loaded sound effects
            </summary>
            <param name="separator">The text you want to place inbetween each song name.
            Use ~ to force a line break after each name</param>
            <returns>A formatted list of loaded sound effects</returns>
        </member>
        <member name="M:Engine.AudioManager.GetActiveEffectNames(System.String)">
            <summary>
            Returns a formatted list of active managed sound effects
            </summary>
            <param name="separator">The text you want to place inbetween each song name.
            Use ~ to force a line break after each name</param>
            <returns>A formatted list of active managed sound effects</returns>
        </member>
        <member name="M:Engine.AudioManager.AddSong(System.String,Microsoft.Xna.Framework.Media.Song)">
            <summary>
            Adds a pre-loaded mp3/WMA track into the audio manager
            </summary>
            <param name="songName">The name to give to this soundtrack</param>
            <param name="song">The pre-loaded song to add to the AudioManager</param>
        </member>
        <member name="M:Engine.AudioManager.AddSong(System.String,System.String)">
            <summary>
            Loads an mp3/WMA and adds it to the song list
            </summary>
            <param name="songName">The name to give to this soundtrack</param>
            <param name="filename">The file name and path e.g. audio\\music</param>
            <returns>True if successfully loaded or False if some error loading</returns>
        </member>
        <member name="M:Engine.AudioManager.AddSoundEffect(System.String,System.String)">
            <summary>
            Loads a sound effect file and adds it to the Audio managers list
            </summary>
            <param name="effectName">The name to refer to the sound effect in future</param>
            <param name="filename">The file name and path e.g. audio\\Shooter</param>
            <returns>True if successfully loaded or False if some error loading</returns>
        </member>
        <member name="M:Engine.AudioManager.AddSoundEffect(System.String,Microsoft.Xna.Framework.Audio.SoundEffect)">
            <summary>
            Loads a sound effect file and adds it to the Audio managers list
            </summary>
            <param name="effectName">The name to refer to the sound effect in future</param>
            <param name="soundEffect">The sound effect already loaded</param>
            <returns>True if successfully loaded or False if some error loading</returns>
        </member>
        <member name="M:Engine.AudioManager.PlayManagedEffect(System.String,System.String,System.Int32,Engine.AudioCallBack)">
            <summary>
            Plays a sound effect but also returns the SoundEffectInstance
            so you can manage the pitch, volume and panning yourself
            You can play and manage the same sound multiple times by using the instance name
            </summary>
            <param name="instanceName">The unique name to give to this version of the sound effect</param>
            <param name="effectName">The name of the effect you wish to play and configure</param>
            <param name="loopCount">sets loop count, a value of -1 means loop forever, 0 means play once</param>
            <param name="callMe">A subroutine to run when the sound effect ends</param>
            <returns>The SoundEffectInstance or null if the effect did not exist</returns>
        </member>
        <member name="M:Engine.AudioManager.PlayManagedEffect(System.String,System.String,System.Int32)">
            <summary>
            Plays a sound effect but also returns the SoundEffectInstance
            so you can manage the pitch, volume and panning yourself
            You can play and manage the same sound multiple times by using the instance name
            </summary>
            <param name="instanceName">The unique name to give to this version of the sound effect</param>
            <param name="effectName">The name of the effect you wish to play and configure</param>
            <param name="loopCount">sets loop count, a value of -1 means loop forever, 0 means play once</param>
            <returns>The SoundEffectInstance or null if the effect did not exist</returns>
        </member>
        <member name="F:Engine.AudioManager.callsMade">
            <summary>
            holds number of calls made during updates??
            </summary>
        </member>
        <member name="M:Engine.AudioManager.PlayManagedEffect(System.String,System.String,System.Int32,Engine.duplicateEffect,Engine.AudioCallBack)">
            <summary>
            Plays a sound effect but also returns the SoundEffectInstance
            so you can manage the pitch, volume and panning yourself
            You can play and manage the same sound multiple times by using the instance name
            </summary>
            <param name="instanceName">The unique name to give to this version of the sound effect</param>
            <param name="effectName">The name of the effect you wish to play and configure</param>
            <param name="loopCount">sets loop count, a value of -1 means loop forever, 0 means play once</param>
            <param name="dupControl">Determine what should happen if instance name already exists</param>
            <param name="callMe">A subroutine to call when the sound effect ends</param>
            <returns>The SoundEffectInstance or null if the effect did not exist</returns>
        </member>
        <member name="M:Engine.AudioManager.PlayManagedEffect(System.String,System.String,System.Int32,Engine.duplicateEffect)">
            <summary>
            Plays a sound effect but also returns the SoundEffectInstance
            so you can manage the pitch, volume and panning yourself
            You can play and manage the same sound multiple times by using the instance name
            </summary>
            <param name="instanceName">The unique name to give to this version of the sound effect</param>
            <param name="effectName">The name of the effect you wish to play and configure</param>
            <param name="loopCount">sets loop count, a value of -1 means loop forever, 0 means play once</param>
            <param name="dupControl">Determine what should happen if instance name already exists</param>
            <returns>The SoundEffectInstance or null if the effect did not exist</returns>
        </member>
        <member name="M:Engine.AudioManager.RemoveManagedEffect(System.String)">
            <summary>
            Attempts to remove a managed effect instance
            </summary>
            <param name="instanceName">The name of the sound effect instance
            (not the name of the sound effect)</param>
        </member>
        <member name="M:Engine.AudioManager.RemoveThisActiveSoundEffect(System.String)">
            <summary>
            Attempts to remove all sound effect instances of the given effect name
            For instance if you currently have the same sound playing 6 times it will stop all of those
            RemoveManagedEffect can only remove a single instance
            </summary>
            <param name="effectName">The name of the sound effect to look for instances of</param>
        </member>
        <member name="M:Engine.AudioManager.RemoveAllManagedEffects">
            <summary>
            Removes and stops all managed effects
            </summary>
        </member>
        <member name="M:Engine.AudioManager.PauseManagedEffect(System.String)">
            <summary>
            Pauses a currently alive managed sound effect
            </summary>
            <param name="instanceName">The instance name to pause (not the sound effect name)</param>
        </member>
        <member name="M:Engine.AudioManager.StopManagedEffect(System.String)">
            <summary>
            Stops a currently alive managed sound effect
            </summary>
            <param name="instanceName">The instance name to stop (not the sound effect name)</param>
        </member>
        <member name="M:Engine.AudioManager.ResumeManagedEffect(System.String)">
            <summary>
            Resumes a previously paused alive managed sound effect
            </summary>
            <param name="instanceName">The instance name to resume (not the sound effect name)</param>
        </member>
        <member name="M:Engine.AudioManager.GetManagedEffect(System.String)">
            <summary>
            Attempts to return the EffectCue associated with a particular managed
            effect cue.
            </summary>
            <param name="instanceName">The instance name to gather (not the sound effect name)</param>
            <returns>The located effect or null</returns>
            <remarks>Allows you to manipulate the effect being managed in anyway you please</remarks>
        </member>
        <member name="M:Engine.AudioManager.GetSong(System.String)">
            <summary>
            Gets the named song object. This will give you access to information such as Duration, 
            which may be useful
            </summary>
            <param name="songName">The name of the managed song to return info for</param>
            <returns>A Song object containing the named song or null if it didn't exist</returns>
        </member>
        <member name="M:Engine.AudioManager.PlayEffectViewerAtViewPort(System.String,System.String,System.Int32,Engine.Sprite,Engine.audioEffect)">
            <summary>
            Plays a sound effect and associates it with a sprite 
            </summary>
            <param name="instanceName">The unique name to give to this version of the sound effect</param>
            <param name="effectName">The name of the effect you wish to play and configure</param>
            <param name="loopCount">sets loop count, a value of -1 means loop forever, 0 means play once</param>
            <param name="associatedSprite">The sprite to auto associate with the sound effect</param>
            <param name="effects">The special effects to associate with the sound effect</param>
            <returns>The SoundEffectInstance or null if the effect did not exist</returns>
        </member>
        <member name="M:Engine.AudioManager.PlayEffectViewerAtViewPort(System.String,System.String,System.Int32,Engine.Sprite,Engine.audioEffect,Engine.duplicateEffect)">
            <summary>
            Plays a sound effect and associates it with a sprite 
            </summary>
            <param name="instanceName">The unique name to give to this version of the sound effect</param>
            <param name="effectName">The name of the effect you wish to play and configure</param>
            <param name="loopCount">sets loop count, a value of -1 means loop forever, 0 means play once</param>
            <param name="associatedSprite">The sprite to auto associate with the sound effect</param>
            <param name="effects">The special effects to associate with the sound effect</param>
            <param name="dupControl">Determine what should happen if instance name already exists</param>
            <returns>The SoundEffectInstance or null if the effect did not exist</returns>
        </member>
        <member name="M:Engine.AudioManager.PlayEffectViewerAtPosition(System.String,System.String,System.Int32,Engine.Sprite,Microsoft.Xna.Framework.Vector3,Engine.audioEffect)">
            <summary>
            Plays a sound effect and associates it with a sprite and a position
            if instance name is already in use the sound effect does not play
            </summary>
            <param name="instanceName">The unique name to give to this version of the sound effect</param>
            <param name="effectName">The name of the effect you wish to play and configure</param>
            <param name="loopCount">sets loop count, a value of -1 means loop forever, 0 means play once</param>
            <param name="associatedSprite">The sprite to auto associate with the sound effect</param>
            <param name="viewerPosition">The position of the viewer</param>
            <param name="effects">The special effects to associate with the sound effect</param>
            <returns>The SoundEffectInstance or null if the effect did not exist</returns>
        </member>
        <member name="M:Engine.AudioManager.PlayEffectViewerAtPosition(System.String,System.String,System.Int32,Engine.Sprite,Microsoft.Xna.Framework.Vector3,Engine.audioEffect,Engine.duplicateEffect)">
            <summary>
            Plays a sound effect and associates it with a sprite and a position
            </summary>
            <param name="instanceName">The unique name to give to this version of the sound effect</param>
            <param name="effectName">The name of the effect you wish to play and configure</param>
            <param name="loopCount">sets loop count, a value of -1 means loop forever, 0 means play once</param>
            <param name="associatedSprite">The sprite to auto associate with the sound effect</param>
            <param name="viewerPosition">The position of the viewer</param>
            <param name="effects">The special effects to associate with the sound effect</param>
            <param name="dupControl">Determine what should happen if instance name already exists</param>
            <returns>The SoundEffectInstance or null if the effect did not exist</returns>
        </member>
        <member name="M:Engine.AudioManager.PlayEffectViewerAtSprite(System.String,System.String,System.Int32,Engine.Sprite,Engine.Sprite,Engine.audioEffect)">
            <summary>
            Plays a sound effect and associates it with a sprite and alters in relation to the other sprite 
            If the sound instance name already exsits then the sound will not play
            </summary>
            <param name="instanceName">The unique name to give to this version of the sound effect</param>
            <param name="effectName">The name of the effect you wish to play and configure</param>
            <param name="loopCount">sets loop count, a value of -1 means loop forever, 0 means play once</param>
            <param name="associatedSprite">The sprite to auto associate with the sound effect</param>
            <param name="viewerSprite">The sprite that contains the position of the viewer</param>
            <param name="effects">The special effects to associate with the sound effect</param>
            <returns>The SoundEffectInstance or null if the effect did not exist</returns>
        </member>
        <member name="M:Engine.AudioManager.PlayEffectViewerAtSprite(System.String,System.String,System.Int32,Engine.Sprite,Engine.Sprite,Engine.audioEffect,Engine.duplicateEffect)">
            <summary>
            Plays a sound effect and associates it with a sprite and alters in relation to the other sprite 
            </summary>
            <param name="instanceName">The unique name to give to this version of the sound effect</param>
            <param name="effectName">The name of the effect you wish to play and configure</param>
            <param name="loopCount">sets loop count, a value of -1 means loop forever, 0 means play once</param>
            <param name="associatedSprite">The sprite to auto associate with the sound effect</param>
            <param name="viewerSprite">The sprite that contains the position of the viewer</param>
            <param name="effects">The special effects to associate with the sound effect</param>
            <param name="dupControl">Determine what should happen if instance name already exists</param>
            <returns>The SoundEffectInstance or null if the effect did not exist</returns>
        </member>
        <member name="M:Engine.AudioManager.PlayEffect(System.String,Engine.AudioCallBack)">
            <summary>
            Plays a sound and throws it away, they cannot be looped
            useful for simple sound effect work, it will create duplicate sounds if required
            </summary>
            <param name="effectName">The name of the sound effect to play</param>
            <param name="callMe">A subroutine to call when the sound effect finishes</param>
            <returns>A sound effect instance so you can alter the pitch and volume if required</returns>
        </member>
        <member name="M:Engine.AudioManager.PlayEffect(System.String)">
            <summary>
            Plays a sound and throws it away, they cannot be looped
            useful for simple sound effect work, it will create duplicate sounds if required
            </summary>
            <param name="effectName">The name of the sound effect to play</param>
            <returns>A sound effect instance so you can alter the pitch and volume if required</returns>
        </member>
        <member name="F:Engine.AudioManager.internalName">
            <summary>
            holds an internal effect name for unmanaged effects
            </summary>
        </member>
        <member name="M:Engine.AudioManager.PlaySong(System.String)">
            <summary>
            Attempts to play the given song, which must be already 
            loaded into the AudioManager
            </summary>
            <param name="songName">Plays a song in the audio manager</param>
        </member>
        <member name="M:Engine.AudioManager.PlaySongUnlessPlaying(System.String)">
            <summary>
            Attempts to play a song. If it is already playing it does not restart.
            If you want to always restart use PlaySong()
            </summary>
            <param name="songName">The song in the audio manager to play</param>
        </member>
        <member name="F:Engine.AudioManager.currentSong">
            <summary>
            holds the name of the currently active song
            </summary>
        </member>
        <member name="P:Engine.AudioManager.CurrentSong">
            <summary>
            gets the name of the currently playing song
            If this is empty then no song is playing
            </summary>
        </member>
        <member name="M:Engine.AudioManager.StopCurrentSong">
            <summary>
            stops the currently playing song
            </summary>
        </member>
        <member name="F:Engine.AudioManager._screenListner">
            <summary>
            An audio listner which calculates the perceived sound at a certain position
            </summary>
        </member>
        <member name="F:Engine.AudioManager.emitter">
            <summary>
            Works with the listner to help generate 3d sound effects
            </summary>
        </member>
        <member name="T:Engine.Bin">
            <summary>
            Defines a grid to split sprites into so collision detection can be more optimised
            reducing the number of comparisions to perform
            </summary>
        </member>
        <member name="F:Engine.Bin.binList">
            <summary>
            the current bin setup for the active sprites
            </summary>
        </member>
        <member name="F:Engine.Bin.rows">
            <summary>
            number of rows in the bin
            </summary>
        </member>
        <member name="F:Engine.Bin.cols">
            <summary>
            number of cols in the bin
            </summary>
        </member>
        <member name="F:Engine.Bin.binWidth">
            <summary>
            width of a bin cell
            </summary>
        </member>
        <member name="F:Engine.Bin.binHeight">
            <summary>
            height of a bin cell
            </summary>
        </member>
        <member name="F:Engine.Bin.total">
            <summary>
            total number of bin positions in list
            </summary>
        </member>
        <member name="M:Engine.Bin.#ctor">
            <summary>
            constructs a new bin layout for the current world dimensions
            </summary>
        </member>
        <member name="M:Engine.Bin.#ctor(System.Int32,System.Int32)">
            <summary>
            constructs a new bin with the specified widths and heights
            </summary>
            <param name="binwidth">number of pixels that each column occupies</param>
            <param name="binheight">number of pixels that each row occupies</param>
        </member>
        <member name="M:Engine.Bin.Construct">
            <summary>
            creates the current bin 
            </summary>
        </member>
        <member name="F:Engine.Bin.activeList">
            <summary>
            holds temporarily the active bin locations for a particular sprite
            </summary>
        </member>
        <member name="M:Engine.Bin.Add(Engine.Sprite)">
            <summary>
            adds a sprite to the global bins and sets the sprites bin tracker
            </summary>
            <param name="s">The sprite to process</param>
        </member>
        <member name="M:Engine.Bin.ViewBins(Engine.PlayerView)">
            <summary>
            generates the binlist for the given viewport
            </summary>
            <param name="pv">the player view to generate bins for</param>
        </member>
        <member name="F:Engine.Bin.sl">
            <summary>
            reference to current bin to reduce bound checking
            </summary>
        </member>
        <member name="M:Engine.Bin.GetCheckList(System.Collections.Generic.List{Engine.Sprite}@,System.Collections.Generic.List{System.Int32}@)">
            <summary>
            Produces a simple linear list (non-repeating) of the sprites sharing the same bins
            THIS IS SLOW NEED TO RE-WORK
            </summary>
            <param name="linearList">a reference to the place to store the list of sprites</param>
            <param name="bins">a reference to the bins to look for sprites in</param>
        </member>
        <member name="M:Engine.Bin.GetRenderList(Engine.Sprite[0:,0:]@,System.Collections.Generic.List{System.Int32},System.Int32[]@)">
            <summary>
            Produces a simple linear list (non-repeating) of the sprites sharing the same bins
            THIS IS SLOW NEED TO RE-WORK
            </summary>
            <param name="renderList">a reference to the array to store the sprites</param>
            <param name="bins">a reference to the bins to look for sprites in</param>
            <param name="renderCount">count list for separate sprite layers</param>
            <returns>number of sprites in the array</returns>
        </member>
        <member name="P:Engine.Bin.Count">
            <summary>
            gets the number of sprites held in reference in the binlist
            </summary>
        </member>
        <member name="M:Engine.Bin.Empty">
            <summary>
            clears the current bin entry list
            </summary>
        </member>
        <member name="T:Engine.BlurNGlow">
            <summary>
            Produces bluring and glowing effect
            </summary>
        </member>
        <member name="F:Engine.BlurNGlow.activeLayer">
            <summary>
            the working sprite layer for effect settings
            </summary>
        </member>
        <member name="P:Engine.BlurNGlow.ActiveLayer">
            <summary>
            gets or sets the active layer for making user effect changes
            </summary>
        </member>
        <member name="F:Engine.BlurNGlow.rtBlurH">
            <summary>
            rendertarget for first phase of bluring (can be re-used)
            </summary>
        </member>
        <member name="F:Engine.BlurNGlow.rtBlurV">
            <summary>
            may need up to 4 if we are crazy and doing a separate blur on each
            of the sprite layers
            </summary>
        </member>
        <member name="F:Engine.BlurNGlow._blurSize">
            <summary>
            spread of bluring
            </summary>
        </member>
        <member name="P:Engine.BlurNGlow.BlurAmount">
            <summary>
            gets or sets the size of the blur for the active layer, default is 0.5f
            </summary>
        </member>
        <member name="F:Engine.BlurNGlow._hblurMultiplier">
            <summary>
            a multiplier for the blur weights
            </summary>
        </member>
        <member name="P:Engine.BlurNGlow.HorizBlurMultiplier">
            <summary>
            gets or sets a multiplier (default is 2) that affects the horizontal spread weight (how heavy it is) of the general BlurSize in the horizontal
            direction. You should in general keep the Horizontal multiplier twice that of the vertical one
            </summary>
        </member>
        <member name="F:Engine.BlurNGlow._vblurMultiplier">
            <summary>
            a multiplier for the blur weights
            </summary>
        </member>
        <member name="P:Engine.BlurNGlow.VertBlurMultiplier">
            <summary>
            gets a multiplier (default is 1) that affects the vertical spread weight (how heavy it is) of the general BlurSize in the vertical
            direction. You should in general keep the Vertical multiplier half that of the horizontal one
            </summary>
        </member>
        <member name="F:Engine.BlurNGlow._glowActive">
            <summary>
            determines whether to initiate glow phase
            </summary>
        </member>
        <member name="P:Engine.BlurNGlow.ShowOverlay">
            <summary>
            determines if the original image should be displayed ontop of the blur/glow effect
            true means its shown, false means not shown. Default is false, so only show blur and not orignal graphics for layer
            </summary>
        </member>
        <member name="F:Engine.BlurNGlow._glowColor">
            <summary>
            colouring to apply to blur/glow effect
            </summary>
        </member>
        <member name="P:Engine.BlurNGlow.GlowColor">
            <summary>
            gets or sets the tint applied to the blurring effect for the active layer, default colour is White, so this makes the glow the same colour as the objects in the scene.
            </summary>
        </member>
        <member name="F:Engine.BlurNGlow._glowAlpha">
            <summary>
            transparency to apply to blur effect
            </summary>
        </member>
        <member name="P:Engine.BlurNGlow.GlowAlpha">
            <summary>
            gets or sets the transparency to apply to the blur effect on the active layer, the default is 1 (opaque, so full on)
            </summary>
        </member>
        <member name="F:Engine.BlurNGlow._originalGlowAlpha">
            <summary>
            transparency to apply to orginal input
            </summary>
        </member>
        <member name="P:Engine.BlurNGlow.OverlayAlpha">
            <summary>
            gets or sets the transparency to apply to the original image (that we blurred)
            only works if ShowOverlay is true, default is 0.9f, this lets some of blur bleed through image
            </summary>
        </member>
        <member name="M:Engine.BlurNGlow.#ctor(Microsoft.Xna.Framework.Graphics.GraphicsDevice,Microsoft.Xna.Framework.Graphics.Effect)">
            <summary>
            Creates the blur'glow post processor
            </summary>
            <param name="g">The graphic device being used</param>
            <param name="effect">The compiled effect file used</param>
        </member>
        <member name="M:Engine.BlurNGlow.Default">
            <summary>
            sets the defaults blur/glow properties for all sprite layers
            </summary>
        </member>
        <member name="M:Engine.BlurNGlow.Default(System.Int32)">
            <summary>
            Defaults a specific sprite layers blur and glow properties
            </summary>
            <param name="spriteLayer"></param>
        </member>
        <member name="M:Engine.BlurNGlow.Process(System.Int32)">
            <summary>
            Performs the Blur and Glow post process operation
            </summary>
        </member>
        <member name="M:Engine.BlurNGlow.Final(System.Int32)">
            <summary>
            Draws any after rendering (usually the frame buffer produced by the effect)
            </summary>
            <param name="spriteLayer">The sprite layer been worked</param>
        </member>
        <member name="P:Engine.BlurNGlow.GetTexture">
            <summary>
            get final rendered texture
            </summary>
        </member>
        <member name="T:Engine.Box">
            <summary>
            defines a 3d box
            </summary>
        </member>
        <member name="F:Engine.Box.corner">
            <summary>
            Specifies the top left front corner of the box
            </summary>
        </member>
        <member name="F:Engine.Box.dimension">
            <summary>
            the width (x), height (y) and depth (z)
            </summary>
        </member>
        <member name="M:Engine.Box.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates a box with whose top left front corner
            and dimensions are given
            </summary>
            <param name="left">the left hand side</param>
            <param name="top">the top</param>
            <param name="front">the front (z value)</param>
            <param name="width">width of box</param>
            <param name="height">height of box</param>
            <param name="depth">depth of box</param>
        </member>
        <member name="M:Engine.Box.#ctor">
            <summary>
            creates a box with zero values
            </summary>
        </member>
        <member name="P:Engine.Box.Empty">
            <summary>
            an empty box
            </summary>
        </member>
        <member name="M:Engine.Box.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>
            Creates a box with whose top left front corner
            and dimensions are given
            </summary>
            <param name="corner">The top left front corner of the box</param>
            <param name="dimension">The width, height and depth of the box</param>
        </member>
        <member name="P:Engine.Box.Left">
            <summary>
            gets the left hand side of the box
            </summary>
        </member>
        <member name="P:Engine.Box.Right">
            <summary>
            gets the right hand side of the box
            </summary>
        </member>
        <member name="P:Engine.Box.Top">
            <summary>
            gets the top of the box
            </summary>
        </member>
        <member name="P:Engine.Box.Bottom">
            <summary>
            gets the bottom of the box
            </summary>
        </member>
        <member name="P:Engine.Box.Front">
            <summary>
            gets the front of the box
            </summary>
        </member>
        <member name="P:Engine.Box.Back">
            <summary>
            gets the back of the box
            </summary>
        </member>
        <member name="P:Engine.Box.Width">
            <summary>
            width of box
            </summary>
        </member>
        <member name="P:Engine.Box.Height">
            <summary>
            height of box
            </summary>
        </member>
        <member name="P:Engine.Box.Depth">
            <summary>
            depth of box
            </summary>
        </member>
        <member name="M:Engine.Box.ToString">
            <summary>
            returns a nicely formatted representation of the limit box
            </summary>
            <returns>limit box</returns>
        </member>
        <member name="T:Engine.CollisionHandler">
            <summary>
            generic collision handling, with empty virtual methods
            to be implemented 
            </summary>
        </member>
        <member name="F:Engine.CollisionHandler.em">
            <summary>
            reference to the engine for access to other items if required
            </summary>
        </member>
        <member name="F:Engine.CollisionHandler.checks">
            <summary>
            holds the checks made during this cycle
            </summary>
        </member>
        <member name="F:Engine.CollisionHandler.maxChecks">
            <summary>
            holds maximum checks we did in a cycle
            </summary>
        </member>
        <member name="P:Engine.CollisionHandler.Checks">
            <summary>
            gets  the number of collisions that have occurred
            </summary>
        </member>
        <member name="F:Engine.CollisionHandler.collisions">
            <summary>
            holds number of collisions processed during this cycle
            </summary>
        </member>
        <member name="F:Engine.CollisionHandler.maxCollisions">
            <summary>
            holds maximum number of collisions detected in a cycle
            </summary>
        </member>
        <member name="P:Engine.CollisionHandler.Collisions">
            <summary>
            gets the number of collisions processed during the cycle
            </summary>
        </member>
        <member name="M:Engine.CollisionHandler.#ctor(Engine.EngineManager)">
            <summary>
            collects the reference to the engine
            </summary>
            <param name="engine"></param>
        </member>
        <member name="M:Engine.CollisionHandler.ResetMetrics">
            <summary>
            resets the collision data
            </summary>
        </member>
        <member name="M:Engine.CollisionHandler.CollisionCheck(Engine.Sprite)">
            <summary>
            checks to see if this sprite has any collisions to respond to
            </summary>
            <param name="s">The sprite to check</param>
        </member>
        <member name="M:Engine.CollisionHandler.CollisionResponse(Engine.Sprite,Engine.Sprite)">
            <summary>
            responds to the collision that happened between these 2 sprites
            </summary>
            <param name="s">The sprite being processed</param>
            <param name="t">The sprite it collided with</param>
        </member>
        <member name="T:Engine.ColorHelper">
            <summary>
            helper for colour manipulation
            </summary>
        </member>
        <member name="F:Engine.ColorHelper.ArcadeBlack">
            <summary>
            Black
            </summary>
        </member>
        <member name="F:Engine.ColorHelper.ArcadeRed">
            <summary>
            full red
            </summary>
        </member>
        <member name="F:Engine.ColorHelper.ArcadeGreen">
            <summary>
            full green
            </summary>
        </member>
        <member name="F:Engine.ColorHelper.ArcadeBlue">
            <summary>
            full blue
            </summary>
        </member>
        <member name="F:Engine.ColorHelper.ArcadeYellow">
            <summary>
            full yellow
            </summary>
        </member>
        <member name="F:Engine.ColorHelper.ArcadeCyan">
            <summary>
            full cyan
            </summary>
        </member>
        <member name="F:Engine.ColorHelper.ArcadeMagenta">
            <summary>
            full magenta
            </summary>
        </member>
        <member name="F:Engine.ColorHelper.ArcadeWhite">
            <summary>
            full white
            </summary>
        </member>
        <member name="F:Engine.ColorHelper.Arcade">
            <summary>
            array of standard 8 arcade colours primary and secondary
            in this order 0 - red, green, blue, yellow, cyan, magenta, white, black
            </summary>
        </member>
        <member name="F:Engine.ColorHelper.ArcadeNoBlack">
            <summary>
            array of standard 7 arcade colours primary and secondary
            in this order 0 - red, green, blue, yellow, cyan, magenta, white
            </summary>
        </member>
        <member name="F:Engine.ColorHelper.ArcadeNoBlackNoWhite">
            <summary>
            array of standard  arcade colours primary and secondary
            in this order 0 - red, green, blue, yellow, cyan, magenta
            </summary>
        </member>
        <member name="P:Engine.ColorHelper.ColourCountNoBlack">
            <summary>
            gets number of colours in Arcade colour array without counting the black colour at then end. You can use this to generate random primary and secondary colours
            </summary>
        </member>
        <member name="P:Engine.ColorHelper.ColourCount">
            <summary>
            gets number of colours in Arcade colour array including black. You can use this to generate random primary and secondary colours
            </summary>
        </member>
        <member name="T:Engine.Icycle">
            <summary>
            interface to enable the passing of colour information to an object from the ColourCycle class
            </summary>
        </member>
        <member name="P:Engine.Icycle.ChangeColour">
            <summary>
            write only property for setting accepting the new colour change value
            </summary>
        </member>
        <member name="T:Engine.ColorCycle">
            <summary>
            nice little helper class to perform colour interpolation
            </summary>
        </member>
        <member name="T:Engine.ColorCycle.InterpolateMethod">
            <summary>
            how to change between next set of colours when interpolating
            </summary>
        </member>
        <member name="F:Engine.ColorCycle.InterpolateMethod.sequence">
            <summary>
            move on to next pair in sequence
            </summary>
        </member>
        <member name="F:Engine.ColorCycle.InterpolateMethod.random">
            <summary>
            pick a second random colour from the sequence
            </summary>
        </member>
        <member name="F:Engine.ColorCycle.InterpolateMethod.once">
            <summary>
            makes the colour change stop once a single set of interpolation has completed
            </summary>
        </member>
        <member name="T:Engine.ColorCycle.DelayMethod">
            <summary>
            method to use when switching between colours
            </summary>
        </member>
        <member name="F:Engine.ColorCycle.DelayMethod.sequence">
            <summary>
            picks a new colour in sequence with a time delay
            </summary>
        </member>
        <member name="F:Engine.ColorCycle.DelayMethod.random">
            <summary>
            picks a new random colour with a time delay
            </summary>
        </member>
        <member name="F:Engine.ColorCycle.DelayMethod.onceThrough">
            <summary>
            changes colour once the end of the list as been reached
            </summary>
        </member>
        <member name="T:Engine.ColorCycle.CallBack">
            <summary>
            callback definition
            </summary>
            <param name="newColor">the colour generated to be used</param>
        </member>
        <member name="F:Engine.ColorCycle.colorcycleset">
            <summary>
            holds the colours to use to cycle
            </summary>
        </member>
        <member name="F:Engine.ColorCycle.currentInterpolation">
            <summary>
            current interpolation amount
            </summary>
        </member>
        <member name="F:Engine.ColorCycle.dInterpolation">
            <summary>
            amount to change interpolation value 
            </summary>
        </member>
        <member name="F:Engine.ColorCycle.lowerIndex">
            <summary>
            current bottom colour index
            </summary>
        </member>
        <member name="F:Engine.ColorCycle.upperIndex">
            <summary>
            current upper colour index
            </summary>
        </member>
        <member name="F:Engine.ColorCycle.evChangeParameters">
            <summary>
            event perform the colour changes
            </summary>
        </member>
        <member name="F:Engine.ColorCycle.interpolateType">
            <summary>
            method to use to pick new colour when interpolation ends
            </summary>
        </member>
        <member name="F:Engine.ColorCycle.delayType">
            <summary>
            method to use to pick new colour in delay type
            </summary>
        </member>
        <member name="F:Engine.ColorCycle.manip">
            <summary>
            reference to the Icycle interface requested
            </summary>
        </member>
        <member name="F:Engine.ColorCycle.myEventManagerRef">
            <summary>
            my ref to the event manager
            </summary>
        </member>
        <member name="F:Engine.ColorCycle.myran">
            <summary>
            internal random number generator
            </summary>
        </member>
        <member name="M:Engine.ColorCycle.#ctor(Engine.Icycle,Microsoft.Xna.Framework.Color[],Engine.ColorCycle.InterpolateMethod,System.Single,System.Int32,Engine.EventManager)">
            <summary>
            Sets up a colour cycling scheme using an object implementing the Icycle interface
            </summary>
            <param name="changeColourOfThis">An object that implements the Icycle interface</param>
            <param name="colourspace">the set of colours to use</param>
            <param name="changeTime">number of seconds to take to interpolate between a pair of colours</param>
            <param name="startIndex">The zero based colour number to start with</param>
            <param name="interpolateHow">method of selecting a new colour once a sequence has finished</param>
            <param name="eventManager">A reference to the event manager</param>
        </member>
        <member name="M:Engine.ColorCycle.#ctor(Engine.Icycle,Microsoft.Xna.Framework.Color[],Engine.ColorCycle.DelayMethod,System.Single,System.Int32,Engine.EventManager)">
            <summary>
            Sets up a colour delay changing scheme using an object implementing the Icycle interface
            </summary>
            <param name="changeColourOfThis">An object that implements the Icycle interface</param>
            <param name="colourspace">the set of colours to use</param>
            <param name="delayTime">number of seconds to wait before changing to next colour in sequence</param>
            <param name="startIndex">The zero based colour number to start with</param>
            <param name="delayHow">method of selecting a new colour once a sequence has finished</param>
            <param name="eventManager">A reference to the event manager</param>
        </member>
        <member name="M:Engine.ColorCycle.Change">
            <summary>
            change to next colour in specified manner and send value
            </summary>
        </member>
        <member name="M:Engine.ColorCycle.Remove">
            <summary>
            removes the colour cycler when finished with
            </summary>
        </member>
        <member name="M:Engine.ColorCycle.lerpit">
            <summary>
            performs the interpolation between colours and sets new colour when required
            </summary>
        </member>
        <member name="T:Engine.DefaultCollisionEngine">
            <summary>
            provides collision logic for dealing with circle to X collisions
            currently only does circle to circle
            </summary>
        </member>
        <member name="M:Engine.DefaultCollisionEngine.#ctor(Engine.EngineManager)">
            <summary>
            constructs the circle collisiong engine
            </summary>
            <param name="engine">the reference to the engine</param>
        </member>
        <member name="F:Engine.DefaultCollisionEngine.sl">
            <summary>
            holds sprites to collision check with
            </summary>
        </member>
        <member name="M:Engine.DefaultCollisionEngine.CollisionCheck(Engine.Sprite)">
            <summary>
            checks to see if this sprite has any collisions to respond to
            </summary>
            <param name="s">The sprite to check</param>
        </member>
        <member name="M:Engine.DefaultCollisionEngine.GetClosestSide(Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            attempts to determine roughly which side was closest 
            after collision
            </summary>
            <param name="s">primary</param>
            <param name="other">secondary</param>
            <returns>direction value</returns>
        </member>
        <member name="F:Engine.DefaultCollisionEngine.oSides">
            <summary>
            holds the side data for the other sprite
            </summary>
        </member>
        <member name="F:Engine.DefaultCollisionEngine.sRadius">
            <summary>
            holds the radius of current sprite being checked
            </summary>
        </member>
        <member name="F:Engine.DefaultCollisionEngine.sCentre">
            <summary>
            stores centre of current sprite being checked
            </summary>
        </member>
        <member name="F:Engine.DefaultCollisionEngine.oCentre">
            <summary>
            stores centre of sprite being checked against
            </summary>
        </member>
        <member name="F:Engine.DefaultCollisionEngine.impulseVector">
            <summary>
            impulse vector of a collision
            </summary>
        </member>
        <member name="F:Engine.DefaultCollisionEngine.distP2">
            <summary>
            distance between 2 sprites (squared)
            </summary>
        </member>
        <member name="F:Engine.DefaultCollisionEngine.normalOfCollisionPlane">
            <summary>
            normal to collision plane so we can work out bounce
            </summary>
        </member>
        <member name="F:Engine.DefaultCollisionEngine.normalOfCollision">
            <summary>
            squared length of collision normal
            </summary>
        </member>
        <member name="F:Engine.DefaultCollisionEngine.impactVelocity">
            <summary>
            velocity at collision impact
            </summary>
        </member>
        <member name="F:Engine.DefaultCollisionEngine.impulse">
            <summary>
            the force that the collision generates
            </summary>
        </member>
        <member name="F:Engine.DefaultCollisionEngine.radSquaredCalc">
            <summary>
            square of the two sprite radii combined
            </summary>
        </member>
        <member name="F:Engine.DefaultCollisionEngine.secondaryAmount">
            <summary>
            amount of shared momentum for secondary item
            </summary>
        </member>
        <member name="F:Engine.DefaultCollisionEngine.primaryAmount">
            <summary>
            amount of shared momentum for primary item
            </summary>
        </member>
        <member name="M:Engine.DefaultCollisionEngine.CollisionResponse(Engine.Sprite,Engine.Sprite)">
            <summary>
            responds to the collision that happened between these 2 sprites
            </summary>
            <param name="s">The sprite being processed</param>
            <param name="target">The sprite it collided with</param>
        </member>
        <member name="T:Engine.BriefHighlightNode">
            <summary>
            a call back to handle briefly highlighting node neighbours
            </summary>
            <param name="node"></param>
        </member>
        <member name="T:Engine.TileCallBack">
            <summary>
            tile call back which accepts a tile number and location then must return either a replacement tile or the same tile
            this happens before a tile is placed into the scene
            </summary>
            <param name="tilenumber">the tile number ready to be placed</param>
            <param name="location">the location the tile is to be placed</param>
            <returns>tile to set a given location</returns>
        </member>
        <member name="T:Engine.XMLAutoReader">
            <summary>
            a method that will cast the given object to its correct object type
            </summary>
            <param name="objectData">the data to cast</param>
        </member>
        <member name="T:Engine.CollisionCallBack">
            <summary>
            delegate definition for code to respond to two sprites meeting, it is up to you how to handle the collision after detection
            </summary>
            <param name="hit">the sprite collided with</param>
        </member>
        <member name="T:Engine.CollisionPixelCallBack">
            <summary>
            delegate definition for code to respond to sprites meeting, where pixel collision detection is needed
            </summary>
            <param name="hit">The sprite hit</param>
            <param name="Overlap">The portion of render space where sprites overlapped</param>
            <param name="myOffset">overlap rectangles offset from top left corner of the main sprite rectangle</param>
            <param name="hitOffset">overlap rectangles offset from top left corner of sprite hit's rectangle</param>
            <return>True if you want to continue processing collisions for this sprite
             (do this if you don't hit a sprite you want pixel collision detection for), return false if you processed pixel collisions</return>
        </member>
        <member name="T:Engine.PrologueCallBack">
            <summary>
            delegate definition for code to respond to two sprites meeting, this allows you to set things before collision response is conducted
            </summary>
            <param name="hit">the sprite collided with</param>
        </member>
        <member name="T:Engine.EpilogueCallBack">
            <summary>
            delegate function called after collision has been handeld and response calculated
            </summary>
            <param name="hit">the sprite collided with</param>
        </member>
        <member name="T:Engine.ResponseCallBack">
            <summary>
            a delegate for a custom collision response,  this may change if requests need this
            </summary>
            <param name="hit">the sprite collided with</param>
            <param name="collisionNormal">the normal of the collision</param>
            <param name="impactVelocity">the impact velocity at the time of collision</param>
        </member>
        <member name="T:Engine.CollisionUserHandler">
            <summary>
            delegate definition for code to respond to two sprites meeting, it is up to you how to handle the collision after detection
            </summary>
            <param name="collisionOwner">Sprite which attached this</param>
            <param name="collidedWith">the sprite collided with</param>
        </member>
        <member name="T:Engine.CollisionPrologue">
            <summary>
            delegate definition for code to respond to two sprites meeting, this allows you to set things before collision response is conducted
            </summary>
            <param name="collisionOwner">Sprite which attached this</param>
            <param name="collidedWith">the sprite collided with</param>
        </member>
        <member name="T:Engine.CollisionResponse">
            <summary>
            a delegate for a custom collision response,  this may change if requests need this
            </summary>
            <param name="collisionOwner">Sprite which attached this epilogue</param>
            <param name="collidedWith">the sprite collided with</param>
            <param name="collisionNormal">the normal of the collision</param>
            <param name="impactVelocity">the impact velocity at the time of collision</param>
        </member>
        <member name="T:Engine.CollisionEpilogue">
            <summary>
            delegate function called after collision has been handeld and response calculated
            </summary>
            <param name="collisionOwner">Sprite which attached this epilogue</param>
            <param name="collidedWith">the sprite collided with</param>
        </member>
        <member name="T:Engine.TextHandler">
            <summary>
            Delegate function to allow user controlled text effects, implemented but not activated yet
            </summary>
            <param name="ts">The text data for the text you are going to manipulate</param>
            <param name="dx">The x position of the next character will be placed</param>
            <param name="dy">The y position of the next character will be placed</param>
            <remarks>This has been deactivated at the moment there is no way to access it</remarks>
        </member>
        <member name="T:Engine.TextMenuHandler">
            <summary>
            delegate definition for text handlers
            </summary>
            <param name="ts"></param>
        </member>
        <member name="T:Engine.EventHandler">
            <summary>
            Delegate definition for an Event.
            </summary>
        </member>
        <member name="T:Engine.AudioCallBack">
            <summary>
            defines a delegate sig for audio effects
            </summary>
        </member>
        <member name="T:Engine.PointCallBack">
            <summary>
            Defines a delegate which will be called when the engine has been asked to locate
            a sprite with this point within it
            </summary>
            <param name="location">The location checked</param>
        </member>
        <member name="T:Engine.StateChanger">
            <summary>
            defines a delegate which will be called at the end of the update routines 
            to enable cleaner state changes
            </summary>
        </member>
        <member name="T:Engine.SpriteCallBack">
            <summary>
            call back for sprite functions used for inherited sprites that don't
            need to have the sprite reference passed to them
            </summary>
        </member>
        <member name="T:Engine.PathCallBack">
            <summary>
            call back for asynchronus path finding routines. setup your code to do something else while waiting for the call back
            </summary>
            <param name="route">the route found, if null then a route is not possible</param>
        </member>
        <member name="T:Engine.DijkstraSearchable">
            <summary>
            provides featured required of a TileMap to make use of Dijkstra search routines
            </summary>
        </member>
        <member name="M:Engine.DijkstraSearchable.Navigatable(Microsoft.Xna.Framework.Point)">
            <summary>
            a method that checks at specified location and returns true if it is navigatable or false if it is not
            </summary>
            <param name="location">A tile location for your method to check</param>
            <returns>true if navigatable or false if not</returns>
        </member>
        <member name="M:Engine.DijkstraSearchable.SetColour(System.Int32,System.Int32,Microsoft.Xna.Framework.Color)">
            <summary>
            sets a colour wash for a tile location, 
            this is only needed if you use the colour indremental versions
            </summary>
            <param name="x">x coord</param>
            <param name="y">y coord</param>
            <param name="c">colour</param>
        </member>
        <member name="M:Engine.DijkstraSearchable.BriefHighlight(System.Int32,System.Int32)">
            <summary>
            A routine called when an existing open tile and has it's cost improved,
            this is only needed if you use the colour indremental versions
            </summary>
            <param name="x">x location of tile</param>
            <param name="y">y location of tile</param>
        </member>
        <member name="M:Engine.DijkstraSearchable.BriefHighlightCurrent(System.Int32,System.Int32)">
            <summary>
            A routine called when an existing open tile is selected as the current one to explore neighbours of
            this is only needed if you use the colour indremental versions
            </summary>
            <param name="x">x location of tile</param>
            <param name="y">y location of tile</param>
        </member>
        <member name="T:Engine.Dijkstra">
            <summary>
            provides implementations of Dijkstra's search algorithm for node based systems and tile systems
            </summary>
        </member>
        <member name="T:Engine.Dijkstra.MapNode">
            <summary>
            a Node representing a tilemap location
            </summary>
        </member>
        <member name="P:Engine.Dijkstra.MapNode.location">
            <summary>
            The location in the tilemap of this node
            </summary>
        </member>
        <member name="M:Engine.Dijkstra.MapNode.#ctor(System.String,Microsoft.Xna.Framework.Point)">
            <summary>
            cosntructs a new map node
            </summary>
            <param name="name">name to give to the name</param>
            <param name="loc">location of the node</param>
        </member>
        <member name="M:Engine.Dijkstra.MapNode.#ctor">
            <summary>
            constructs an empty node
            </summary>
        </member>
        <member name="P:Engine.Dijkstra.openSet">
            <summary>
            a read only accessor for the openset
            </summary>
        </member>
        <member name="M:Engine.Dijkstra.GetMapPath(Engine.DijkstraSearchable,Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point,System.Boolean)">
            <summary>
            
            </summary>
            <param name="map"></param>
            <param name="start"></param>
            <param name="end"></param>
            <param name="ordinalsOnly"></param>
            <returns></returns>
        </member>
        <member name="M:Engine.Dijkstra.GetPath(Engine.Dijkstra.MapNode,Engine.Dijkstra.MapNode)">
            <summary>
            traverses map nodes to determine a route if possible
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:Engine.Dijkstra.StartIterate(Engine.DijkstraSearchable,Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point,System.Boolean)">
            <summary>
            
            </summary>
            <param name="map"></param>
            <param name="start"></param>
            <param name="end"></param>
            <param name="ordinalsOnly"></param>
        </member>
        <member name="M:Engine.Dijkstra.Iterate">
            <summary>
            performs one iteration of the algorithm
            </summary>
            <returns></returns>
        </member>
        <member name="M:Engine.Dijkstra.StartIterateColour(Engine.DijkstraSearchable,Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point,System.Boolean,Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Color)">
            <summary>
            Sets up an interation based search using colour 
            </summary>
            <param name="map">The map to be searched</param>
            <param name="start">start tile</param>
            <param name="end">destination tile</param>
            <param name="ordinalsOnly">if true major ordinals are used for neighbours, if false then minor ordinals are included (diagonals)</param>
            <param name="closeSetColour">Colour to render closed set members</param>
            <param name="openSetColour">Colour to render open set members</param>
            <param name="routeColour">Colour to render the route</param>
        </member>
        <member name="M:Engine.Dijkstra.IterateColour">
            <summary>
            performs one iteration of the algorithm
            </summary>
            <returns></returns>
        </member>
        <member name="M:Engine.Dijkstra.GetPath(System.Collections.Generic.List{Engine.NetworkNode},Engine.NetworkNode,Engine.NetworkNode)">
            <summary>
            processes a given list of nodes to determine shortest rouint
            </summary>
            <param name="locations">a list containing all the nodes</param>
            <param name="start">node to start at</param>
            <param name="end">Node to get to</param>
        </member>
        <member name="M:Engine.Dijkstra.StartIterateGraphColour(System.Collections.Generic.List{Engine.NetworkNode},Engine.NetworkNode,Engine.NetworkNode,Engine.BriefHighlightNode,Engine.BriefHighlightNode,Engine.BriefHighlightNode)">
            <summary>
            Sets up the graph data for an iterative search using colour call backs
            </summary>
            <param name="locations">graph</param>
            <param name="start">start node</param>
            <param name="end">end node</param>
            <param name="cheapestCallBack">Method to call when cheapest node selected</param>
            <param name="cheapestNeighbourCallBack">Method to call when the cheapest neighbour is selected</param>
            <param name="neighbourCallBack">Method to call when a neighbour is selected</param>
        </member>
        <member name="P:Engine.Dijkstra.VisitedSet">
            <summary>
            A read only accessor for the visited set of nodes
            </summary>
        </member>
        <member name="P:Engine.Dijkstra.nodemap">
            <summary>
            a read only accessor the the nodemap
            </summary>
        </member>
        <member name="M:Engine.Dijkstra.IterateGraphColour">
            <summary>
            perform next phase of iteration on the graph
            </summary>
            <returns>null if not finished, returns a route with one node name No route if can't reach goal and actual route if end reached</returns>
        </member>
        <member name="M:Engine.Dijkstra.StartIterateGraph(System.Collections.Generic.List{Engine.NetworkNode},Engine.NetworkNode,Engine.NetworkNode)">
            <summary>
            Sets up the graph data for an iterative search
            </summary>
            <param name="locations">graph</param>
            <param name="start">start node</param>
            <param name="end">end node</param>
        </member>
        <member name="M:Engine.Dijkstra.IterateGraph">
            <summary>
            perform next phase of iteration on the graph
            </summary>
            <returns>null if not finished, returns a route with one node name No route if can't reach goal and actual route if end reached</returns>
        </member>
        <member name="M:Engine.Dijkstra.GetCheapestNode">
            <summary>
            returns the node with the smallest cost to reach
            </summary>
            <returns>cheapest node so far in list</returns>
        </member>
        <member name="M:Engine.DijkstraTileMap.BriefHighlight(System.Int32,System.Int32)">
            <summary>
            highlight for temporary tile changes
            </summary>
            <param name="x">tile column</param>
            <param name="y">tile row</param>
        </member>
        <member name="M:Engine.DijkstraTileMap.BriefHighlightCurrent(System.Int32,System.Int32)">
            <summary>
            highlight for current parent tile
            </summary>
            <param name="x">tile column</param>
            <param name="y">tile row</param>
        </member>
        <member name="M:Engine.DijkstraTileMap.Navigatable(Microsoft.Xna.Framework.Point)">
            <summary>
            used by Dijsktra to decide if a tile is walkable defaults to 
            return ValidTile(location) and GetGraphic(location) == 0;
            override this if you need more complex behaviour
            </summary>
            <param name="location">a tile location to check</param>
            <returns>return true if location allowed, false if not</returns>
        </member>
        <member name="M:Engine.DijkstraTileMap.SetColour(System.Int32,System.Int32,Microsoft.Xna.Framework.Color)">
            <summary>
            sets the colour of a visited tile to orange for removed from open list and green for active in open list
            </summary>
            <param name="x">tile column</param>
            <param name="y">tile row</param>
            <param name="c">color being set</param>
        </member>
        <member name="T:Engine.DynamicSoundEffect">
            <summary>
            a class to make using the DynamicSoundEffectInstance easier to use
            </summary>
        </member>
        <member name="F:Engine.DynamicSoundEffect.NoteC">
            <summary>
            C
            </summary>
        </member>
        <member name="F:Engine.DynamicSoundEffect.NoteCsharp">
            <summary>
            C#
            </summary>
        </member>
        <member name="F:Engine.DynamicSoundEffect.NoteD">
            <summary>
            D
            </summary>
        </member>
        <member name="F:Engine.DynamicSoundEffect.NoteDsharp">
            <summary>
            D#
            </summary>
        </member>
        <member name="F:Engine.DynamicSoundEffect.NoteE">
            <summary>
            E
            </summary>
        </member>
        <member name="F:Engine.DynamicSoundEffect.NoteF">
            <summary>
            F
            </summary>
        </member>
        <member name="F:Engine.DynamicSoundEffect.NoteFsharp">
            <summary>
            F#
            </summary>
        </member>
        <member name="F:Engine.DynamicSoundEffect.NoteG">
            <summary>
            G
            </summary>
        </member>
        <member name="F:Engine.DynamicSoundEffect.NoteGsharp">
            <summary>
            G#
            </summary>
        </member>
        <member name="F:Engine.DynamicSoundEffect.NoteA">
            <summary>
            A
            </summary>
        </member>
        <member name="F:Engine.DynamicSoundEffect.NoteAsharp">
            <summary>
            A#
            </summary>
        </member>
        <member name="F:Engine.DynamicSoundEffect.NoteB">
            <summary>
            B
            </summary>
        </member>
        <member name="F:Engine.DynamicSoundEffect.octave4">
            <summary>
            Octave 4 frequecies c,c#, d, d#, e, f, f#, g, g#, a, a#, b
            </summary>
        </member>
        <member name="M:Engine.DynamicSoundEffect.Frequency(System.Int32,System.Int32)">
            <summary>
            returns the frequency of a note in a given octave
            </summary>
            <param name="note">Not from the static values DynamicSoundEffect.C etc...</param>
            <param name="octave">0 to 8 - you can go out of this range but results won't be pleasant</param>
            <returns>Frequency for this note</returns>
        </member>
        <member name="F:Engine.DynamicSoundEffect.dsei">
            <summary>
            the actual sound effect instance
            </summary>
        </member>
        <member name="F:Engine.DynamicSoundEffect.buffer">
            <summary>
            buffer for the samples that your BufferNeeded method needs to fill
            </summary>
        </member>
        <member name="F:Engine.DynamicSoundEffect.bufferSize">
            <summary>
            The size of the buffer
            </summary>
        </member>
        <member name="F:Engine.DynamicSoundEffect.TotalTimePlaying">
            <summary>
            the total time this sound effect has been playing
            </summary>
        </member>
        <member name="M:Engine.DynamicSoundEffect.#ctor(System.Int32,Microsoft.Xna.Framework.Audio.AudioChannels,System.Single)">
            <summary>
            Creates a new dynamic sound effect
            </summary>
            <param name="sampleRate"></param>
            <param name="channels"></param>
            <param name="sampleLength">length of sample that you will create in seconds</param>
        </member>
        <member name="M:Engine.DynamicSoundEffect.Pulse(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            produces a saw tooth wave form sample
            </summary>
            <param name="frequency">frequency of sound wave</param>
            <param name="time">Time period of this sample</param>
            <param name="amp">Amplitude for this wave form</param>
            <param name="dutyCycle">cut off</param>
            <returns>sample</returns>
        </member>
        <member name="M:Engine.DynamicSoundEffect.SawTooth(System.Double,System.Double,System.Double)">
            <summary>
            produces a saw tooth wave form sample
            </summary>
            <param name="frequency">frequency of sound wave</param>
            <param name="time">Time period of this sample</param>
            <param name="amp">Amplitude for this wave form</param>
            <returns>sample</returns>
        </member>
        <member name="M:Engine.DynamicSoundEffect.Noise(System.Double)">
            <summary>
            generates random noise at amplitude given
            </summary>
            <param name="amp"></param>
            <returns></returns>
        </member>
        <member name="M:Engine.DynamicSoundEffect.Square(System.Double,System.Double,System.Double)">
            <summary>
            produces a square wave form sample
            </summary>
            <param name="frequency">frequency of sound wave</param>
            <param name="time">Time period of this sample</param>
            <param name="amp">Amplitude for this wave form</param>
            <returns>sample</returns>
        </member>
        <member name="M:Engine.DynamicSoundEffect.Triangle(System.Double,System.Double,System.Double)">
            <summary>
            produces a Triangle  wave form sample
            </summary>
            <param name="frequency">frequency of sound wave</param>
            <param name="time">Time period of this sample</param>
            <param name="amp">Amplitude for this wave form</param>
            <returns>sample</returns>
        </member>
        <member name="M:Engine.DynamicSoundEffect.Sine(System.Double,System.Double,System.Double)">
            <summary>
            produces a sine wave form sample
            </summary>
            <param name="frequency">frequency of sound wave</param>
            <param name="time">Time period of this sample</param>
            <param name="amp">Amplitude for this wave form</param>
            <returns>sample</returns>
        </member>
        <member name="M:Engine.DynamicSoundEffect.BufferNeeded(System.Object,System.EventArgs)">
            <summary>
            specifies the code needed to fill the audio buffer to enable the sound to continue playing
            you must ensure you call base.SubmitBuffer(sender, e) at the end of your code to ensure the base method completes its jobs
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Engine.DynamicSoundEffect.SetBuffer(System.Int32,System.Int16)">
            <summary>
            sets the two bytes in little endian format from the 16 bit sample
            </summary>
            <param name="i">position in byte buffer to set next two bytes from</param>
            <param name="currentSample">the 16 bit value to re-order using little endian format</param>
        </member>
        <member name="T:Engine.DynamicTexture">
            <summary>
            creates a dynamic texture that can be manipulated at runtime for various effects
            </summary>
        </member>
        <member name="F:Engine.DynamicTexture.tex">
            <summary>
            texture created
            </summary>
        </member>
        <member name="F:Engine.DynamicTexture.pixels">
            <summary>
            pixels of the texture
            </summary>
        </member>
        <member name="P:Engine.DynamicTexture.BackColour">
            <summary>
            the default colour of the texture
            </summary>
        </member>
        <member name="M:Engine.DynamicTexture.#ctor(System.Int32,System.Int32,Microsoft.Xna.Framework.Color,Engine.EngineManager)">
            <summary>
            constructs a dynamic texture object
            </summary>
            <param name="width">pixels wide</param>
            <param name="height">pixels high</param>
            <param name="col">default background colour</param>
            <param name="engine">reference to game engine manager GM.engineM</param>
        </member>
        <member name="M:Engine.DynamicTexture.SetPixel(System.Int32,System.Int32,Microsoft.Xna.Framework.Color)">
            <summary>
            sets an individual pixel in the texture, no bound checking
            </summary>
            <param name="x">horizontal location</param>
            <param name="y">vertical location</param>
            <param name="col">colour to set</param>
        </member>
        <member name="M:Engine.DynamicTexture.GetPixel(System.Int32,System.Int32)">
            <summary>
            gets the pixel colour at given co-ordinates, performs no bounds checking
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Engine.DynamicTexture.Fill(Microsoft.Xna.Framework.Color)">
            <summary>
            Fills entire texture with a colour
            </summary>
            <param name="colour"></param>
        </member>
        <member name="M:Engine.DynamicTexture.SetTexture">
            <summary>
            applies the pixels to the texture
            </summary>
        </member>
        <member name="M:Engine.DynamicTexture.Dispose">
            <summary>
            removes the resources of the texture, call this from cleanup
            </summary>
        </member>
        <member name="T:Engine.EffectCue">
            <summary>
            A holder for storing an effect instance that needs managing
            </summary>
        </member>
        <member name="F:Engine.EffectCue.onLoopOrEnd">
            <summary>
            holds the callback (if any) to be executed when effect loops or ends
            </summary>
        </member>
        <member name="F:Engine.EffectCue.name">
            <summary>
            the name for this particular instance of the sound effect
            This is different to the effectname
            </summary>
        </member>
        <member name="F:Engine.EffectCue.effectName">
            <summary>
            holds the name of the sound effect this instance is using
            </summary>
        </member>
        <member name="P:Engine.EffectCue.BaseEffectName">
            <summary>
            gets the name of the sound effect this instance is using
            </summary>
        </member>
        <member name="F:Engine.EffectCue.effectInstance">
            <summary>
            holds the instance of the sound effect being generated
            </summary>
        </member>
        <member name="F:Engine.EffectCue.appliedEffects">
            <summary>
            holds the special audioEffects to apply to this effectcue
            </summary>
        </member>
        <member name="F:Engine.EffectCue.mySprite">
            <summary>
            reference to the sprite for use with Panning (and 3d panning)
            </summary>
        </member>
        <member name="F:Engine.EffectCue.BasePitch">
            <summary>
            The pitch you want the audioEffect to have before doppler effects are applied
            </summary>
        </member>
        <member name="F:Engine.EffectCue.SpeedOfSound">
            <summary>
            Default speed of sound in air is ~ 343 m/s but you can change this for
            doppler effects in different materials
            </summary>
        </member>
        <member name="F:Engine.EffectCue.DopplerSoftness">
            <summary>
            Alters the overall pitch change effect of the doppler shift. Higher is harsher change
            </summary>
        </member>
        <member name="F:Engine.EffectCue.loopLimit">
            <summary>
            Number of times for the effect to loop if at all
            only affects managed effects!
            </summary>
        </member>
        <member name="F:Engine.EffectCue.originalLoopLimit">
            <summary>
            holds the original number of loops requested
            this will be used when call backs are triggered per loop
            </summary>
        </member>
        <member name="P:Engine.EffectCue.MaxVolume">
            <summary>
            volume to use before any effects are applied
            </summary>
        </member>
        <member name="F:Engine.EffectCue.ZeroVolumeDistance">
            <summary>
            holds the distance after which the volume will be zero
            </summary>
        </member>
        <member name="F:Engine.EffectCue.FullPanDistance">
            <summary>
            the distance after which either full left or full right panning is applied
            </summary>
        </member>
        <member name="F:Engine.EffectCue.Zignore">
            <summary>
            if true ignores the Z component of position information
            (just does XY comparisons of distance)
            </summary>
        </member>
        <member name="F:Engine.EffectCue.ViewerSprite">
            <summary>
            holds the second sprite with which to compare for sprite relative based effects
            </summary>
        </member>
        <member name="F:Engine.EffectCue.debugValue">
            <summary>
            Holds a string version of current Volume, Pitch and Pan
            </summary>
        </member>
        <member name="F:Engine.EffectCue.ViewerPosition">
            <summary>
            holds the position with which to compare when doing position based effects
            </summary>
        </member>
        <member name="M:Engine.EffectCue.#ctor(System.String,System.String,Engine.AudioCallBack)">
            <summary>
            Creates a new instance of the EffectCue
            </summary>
            <param name="instanceName">The name to give the instance of this sound effect</param>
            <param name="soundEffectName">The name to give the sound effect</param>
            <param name="acb">The subroutine to call when the effect loops</param>
        </member>
        <member name="T:Engine.IEngineManager">
            <summary>
            interface for picking up the engine from within other components
            </summary>
        </member>
        <member name="P:Engine.IEngineManager.Version">
            <summary>
            Specified the current version of the engine
            </summary>
        </member>
        <member name="T:Engine.EngineManager">
            <summary>
            The overall manager of the engine
            </summary>
        </member>
        <member name="F:Engine.EngineManager._spriteList">
            <summary>
            Holds all active sprites
            </summary>
        </member>
        <member name="P:Engine.EngineManager.SpriteList">
            <summary>
            gets the entire sprite list for loop processing
            </summary>
        </member>
        <member name="P:Engine.EngineManager.SpriteCount">
            <summary>
            count of the number of sprites currently being managed
            </summary>
        </member>
        <member name="F:Engine.EngineManager._pendingSprites">
            <summary>
            holds all sprites waiting to be added to the main list
            while processing of list is going on
            </summary>
        </member>
        <member name="F:Engine.EngineManager._listBeingUsed">
            <summary>
            incremental locking system for main sprite list
            </summary>
        </member>
        <member name="F:Engine.EngineManager.ClearScreen">
            <summary>
            if true the screen is cleared before rendering
            </summary>
        </member>
        <member name="F:Engine.EngineManager.ScreenColour">
            <summary>
            The colour to clear the screen to
            </summary>
        </member>
        <member name="F:Engine.EngineManager.LineRenderMax">
            <summary>
            maximum number of lines that can be rendered
            </summary>
        </member>
        <member name="F:Engine.EngineManager.RenderMax">
            <summary>
            maximum number of sprites that can be rendered
            </summary>
        </member>
        <member name="F:Engine.EngineManager.ZRange">
            <summary>
            the depth of the rendering engine, sprites whose Z is outside of this range will not be drawn
            currently set to 100,000 so -50000 to 50000 will be drawn
            </summary>
        </member>
        <member name="F:Engine.EngineManager.ZHalfRange">
            <summary>
            half of rendering range to avoid a calculation when rendering
            </summary>
        </member>
        <member name="F:Engine.EngineManager.ZRangeInv">
            <summary>
            inverse for multiplication instead of division ops
            </summary>
        </member>
        <member name="F:Engine.EngineManager.lineRenderListSimple">
            <summary>
            holds the linked of lines to be rendered 
            </summary>
        </member>
        <member name="P:Engine.EngineManager.LineRenderList">
            <summary>
            gets the entire line render contents as a list
            </summary>
        </member>
        <member name="F:Engine.EngineManager.renderList">
            <summary>
            holds lists of sprites to render for each layer (sprites, hud and text layers)
            </summary>
        </member>
        <member name="F:Engine.EngineManager.renderListHistory">
            <summary>
            holds a reference to the history items that need to be rendered
            </summary>
        </member>
        <member name="F:Engine.EngineManager.renderCount">
            <summary>
            holds counts for sprites drawn in each layer
            </summary>
        </member>
        <member name="F:Engine.EngineManager.renderCountHistory">
            <summary>
            holds counts for history sprite rendering
            </summary>
        </member>
        <member name="F:Engine.EngineManager.lineRenderCount">
            <summary>
            holds the counts for lines held for rendering in each sprite layer
            </summary>
        </member>
        <member name="F:Engine.EngineManager.ParticleRenderCount">
            <summary>
            holds information stating rendering for each layer with particles 
            </summary>
        </member>
        <member name="F:Engine.EngineManager.linesRendered">
            <summary>
            holds number of lines rendered per layer
            </summary>
        </member>
        <member name="F:Engine.EngineManager.particlesRendered">
            <summary>
            holds number of particles rendered per layer
            </summary>
        </member>
        <member name="P:Engine.EngineManager.LineRenderCounts">
            <summary>
            gets the line render counts for each render layer
            </summary>
        </member>
        <member name="F:Engine.EngineManager.renderProperties">
            <summary>
            render properties for the sprites and text
            </summary>
        </member>
        <member name="F:Engine.EngineManager.SystemFont">
            <summary>
            Holds the system font
            </summary>
        </member>
        <member name="F:Engine.EngineManager.viewport">
            <summary>
            holds the current rendering viewports of the engine
            If you wish to render more than one view than add a new viewport value, 
            it will be picked up automatically
            </summary>
        </member>
        <member name="P:Engine.EngineManager.View">
            <summary>
            provides quick access to the default viewport
            </summary>
        </member>
        <member name="F:Engine.EngineManager.activePlayerViews">
            <summary>
            holds the id's of the current viewports to use for rendering
            held in the viewport list
            </summary>
        </member>
        <member name="P:Engine.EngineManager.WorldRectangle">
            <summary>
            gets the current world dimensions as a rectangle
            </summary>
        </member>
        <member name="P:Engine.EngineManager.WorldBox">
            <summary>
            gets the current world dimensions as a box
            </summary>
        </member>
        <member name="M:Engine.EngineManager.WorldSize(System.Int32,System.Int32,System.Int32)">
            <summary>
            sets the size of the world
            </summary>
            <param name="width">width in pixels</param>
            <param name="height">height in pixels</param>
            <param name="depth">depth in pixels</param>
        </member>
        <member name="M:Engine.EngineManager.WorldSize(Microsoft.Xna.Framework.Rectangle)">
            <summary>
            Sets the size of the world based on the dimensions of rectangle given
            </summary>
            <param name="area">the rectangle whose width and height will be used to set size of world</param>
        </member>
        <member name="M:Engine.EngineManager.WorldSize(System.Int32,System.Int32)">
            <summary>
            sets the size of the world
            </summary>
            <param name="width">width in pixels</param>
            <param name="height">height in pixels</param>
        </member>
        <member name="P:Engine.EngineManager.WorldWidth">
            <summary>
            gets the current width of the world
            </summary>
        </member>
        <member name="P:Engine.EngineManager.WorldDepth">
            <summary>
            gets the depth height of the world
            </summary>
        </member>
        <member name="P:Engine.EngineManager.WorldHeight">
            <summary>
            gets the current height of the world
            </summary>
        </member>
        <member name="P:Engine.EngineManager.Version">
            <summary>
            gets the current version number of the engine
            </summary>
        </member>
        <member name="F:Engine.EngineManager.DebugDisplay">
            <summary>
            holds the engine debug display settings
            </summary>
        </member>
        <member name="F:Engine.EngineManager.DebugPosition">
            <summary>
            The position to render the general debug information
            </summary>
        </member>
        <member name="F:Engine.EngineManager.DebugAttributes">
            <summary>
            default debug attributes for the general debug display
            </summary>
        </member>
        <member name="F:Engine.EngineManager.Paused">
            <summary>
            determines if the system is paused or not
            </summary>
        </member>
        <member name="F:Engine.EngineManager.collisionBin">
            <summary>
            holds the collision bins for the engine - MAKE PUBLIC FOR TESTING
            </summary>
        </member>
        <member name="M:Engine.EngineManager.#ctor(Microsoft.Xna.Framework.Game,Engine.TileMapManager,Engine.EventManager,Engine.TextManager,Engine.FontBank,Engine.AudioManager)">
            <summary>
            constructs the engine manager
            </summary>
            <param name="game"></param>
            <param name="tileMapManager"></param>
            <param name="eventManager"></param>
            <param name="textManager"></param>
            <param name="fontBank"></param>
            <param name="audioManager"></param>
        </member>
        <member name="M:Engine.EngineManager.#ctor(Microsoft.Xna.Framework.Game,Engine.TileMapManager,Engine.EventManager,Engine.TextManager,Engine.AudioManager)">
            <summary>
            constructs the engine manager
            </summary>
            <param name="game"></param>
            <param name="tileMapManager"></param>
            <param name="eventManager"></param>
            <param name="textManager"></param>
            <param name="audioManager"></param>
        </member>
        <member name="M:Engine.EngineManager.Game_Exiting(System.Object,System.EventArgs)">
            <summary>
            marks game as closing so other components can determine if they can abandon functions
            particularly the threaded loader
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Engine.EngineManager.Initialize">
            <summary>
            Initialises the component
            </summary>
        </member>
        <member name="M:Engine.EngineManager.LoadContent">
            <summary>
            loads and sets up all resources needed by the engine
            </summary>
        </member>
        <member name="M:Engine.EngineManager.GetTextureX2(Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            creates a new texture that contains doubled pixels from the given one
            </summary>
            <param name="textureToDouble">texture to double up</param>
            <returns>a new texture double the size</returns>
        </member>
        <member name="M:Engine.EngineManager.TextureFromPixelArray(System.UInt32[],System.Int32,System.Int32)">
            <summary>
            Creates a texture from an unsigned array of pixels
            This can be used to create dynamic textures
            </summary>
            <param name="pixels">linear array containing corrent number of pixels</param>
            <param name="width">width of texture</param>
            <param name="height">height of texture</param>
            <returns>texture with pixels set</returns>
        </member>
        <member name="M:Engine.EngineManager.TextureFromPixelArray(Microsoft.Xna.Framework.Color[],System.Int32,System.Int32)">
            <summary>
            Creates a texture from an color array of pixels
            This can be used to create dynamic textures
            </summary>
            <param name="pixels">linear array containing corrent number of pixels</param>
            <param name="width">width of texture</param>
            <param name="height">height of texture</param>
            <returns>texture with pixels set</returns>
        </member>
        <member name="M:Engine.EngineManager.NewTexture(System.Int32,System.Int32)">
            <summary>
            Creates a new texture
            This can be used to create dynamic textures
            </summary>
            <param name="width">width of texture</param>
            <param name="height">height of texture</param>
            <returns>texture of size requested</returns>
        </member>
        <member name="M:Engine.EngineManager.TextureMaskFromSprite(Engine.Sprite,System.Int32,Engine.InterpretAlpha,System.Int32)">
            <summary>
            creates a masked texture for the given frame of a sprite
            </summary>
            <param name="s">Sprite to grab mask frame from</param>
            <param name="frame">frame numebr to mask</param>
            <param name="alphaChoice">How to interpret alpha values</param>
            <param name="tolerance">only works with InterpretAlpha.makeOpaque alpha (0-255) value to accept as transparent</param>
            <returns>texture requested or null if no frame exists</returns>
        </member>
        <member name="M:Engine.EngineManager.TextureMaskFromSprite(Engine.Sprite,System.Int32,Engine.InterpretAlpha)">
            <summary>
            creates a masked texture for the given frame of a sprite
            </summary>
            <param name="s">Sprite to grab mask frame from</param>
            <param name="frame">frame numebr to mask</param>
            <param name="alphaChoice">How to interpret alpha values</param>
            <returns>texture requested or null if no frame exists</returns>
        </member>
        <member name="M:Engine.EngineManager.TextureMaskList(Engine.Sprite,System.Collections.Generic.List{Microsoft.Xna.Framework.Graphics.Texture2D}@,Engine.InterpretAlpha,System.Int32)">
            <summary>
            creates a list of masked textures for the given sprite
            </summary>
            <param name="s">Sprite to grab mask frame from</param>
            <param name="textures">A list of textures to store the items in</param>
            <param name="alphaChoice">How to interpret alpha values</param>
            <param name="tolerance">only works with InterpretAlpha.makeOpaque alpha (0-255) value to accept as transparent</param>
        </member>
        <member name="M:Engine.EngineManager.TextureMaskList(Engine.Sprite,System.Collections.Generic.List{Microsoft.Xna.Framework.Graphics.Texture2D}@,Engine.InterpretAlpha)">
            <summary>
            creates a list of masked textures for the given sprite
            </summary>
            <param name="s">Sprite to grab mask frame from</param>
            <param name="textures">A list of textures to store the items in</param>
            <param name="alphaChoice">How to interpret alpha values</param>
        </member>
        <member name="M:Engine.EngineManager.TextureFilledMaskList(Engine.Sprite,System.Collections.Generic.List{Microsoft.Xna.Framework.Graphics.Texture2D}@,Engine.InterpretAlpha,System.Int32)">
            <summary>
            creates a list of filled (edge to edge) masked textures for the given sprite
            </summary>
            <param name="s">Sprite to grab mask frame from</param>
            <param name="textures">A list of textures to store the items in</param>
            <param name="alphaChoice">How to interpret alpha values</param>
            <param name="tolerance">only works with InterpretAlpha.makeOpaque alpha (0-255) value to accept as transparent, use 0 to ignore full opaque only</param>
        </member>
        <member name="M:Engine.EngineManager.TextureFilledMaskFromSprite(Engine.Sprite,System.Int32,Engine.InterpretAlpha,System.Int32)">
            <summary>
            creates a filled (edge to edge) masked texture for the given frame of a sprite
            </summary>
            <param name="s">Sprite to grab mask frame from</param>
            <param name="frame">frame numebr to mask</param>
            <param name="alphaChoice">How to interpret alpha values</param>
            <param name="tolerance">only works with InterpretAlpha.makeOpaque alpha (0-255) value to accept as transparent, use 0 to ignore full opaque only</param>
            <returns>texture requested or null if no frame exists</returns>
        </member>
        <member name="F:Engine.EngineManager.digits">
            <summary>
            holds an array of uint arrays (jagged array)
            </summary>
        </member>
        <member name="M:Engine.EngineManager.CaptureDigitArrays">
            <summary>
            takes pixel data from system font digits and places in arrays
            so they can be used to dynamically create texture data
            </summary>
        </member>
        <member name="M:Engine.EngineManager.CreateTriangles">
            <summary>
            creates a simple 32x32 triangle pointing upwards in white so it can be coloured
            </summary>
        </member>
        <member name="M:Engine.EngineManager.CreateDiscs">
            <summary>
            creates a few different scaled white circle textures to be used as bullets etc...
            These come from the ShinyBalls texture
            </summary>
        </member>
        <member name="M:Engine.EngineManager.CreateTargets">
            <summary>
            creates a simple 32x32 target sprite with white in fill so it can be coloured
            does a black and white one at the same time
            </summary>
        </member>
        <member name="M:Engine.EngineManager.CreateGrid">
            <summary>
            creates the Tex.Grid (2000by2000) with numbers saving dll space
            </summary>
        </member>
        <member name="M:Engine.EngineManager.CreateNumberGrid">
            <summary>
            creates the simple grid of square blocks of numbers for animation testing
            </summary>
        </member>
        <member name="M:Engine.EngineManager.PlaceNum(System.Int32,System.Int32,System.Int32,Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            places a number at a given x, y position in a texture
            </summary>
            <param name="x">x position to start drawing</param>
            <param name="y">y position to start drawing</param>
            <param name="number">the number to draw</param>
            <param name="tex">texture to place it in</param>
        </member>
        <member name="M:Engine.EngineManager.UnloadContent">
            <summary>
            releases resources
            </summary>
        </member>
        <member name="F:Engine.EngineManager.activeCollision">
            <summary>
            specifies the collision system to use, the default is the
            dynamic engine
            </summary>
        </member>
        <member name="F:Engine.EngineManager.coDefault">
            <summary>
            where the sprite being tested is a circle (it needs to determine how to respond to other sprites)
            </summary>
        </member>
        <member name="F:Engine.EngineManager.SpriteFontSystem">
            <summary>
            A default SpriteFont for simple text rendering
            This will not be able to take advantage of the sophisticated animated Text system
            but is fine for static text. Ask about SpriteFonts to create your own static fonts
            or about defining a more jazzy fontbank system
            </summary>
        </member>
        <member name="F:Engine.EngineManager.finalPassBatch">
            <summary>
            don't think this is used
            </summary>
        </member>
        <member name="F:Engine.EngineManager.PostProcessBlur">
            <summary>
            The postprocessing blur system
            </summary>
        </member>
        <member name="F:Engine.EngineManager.SimpleEffectGray">
            <summary>
            holds the simple grayscale effect
            </summary>
        </member>
        <member name="F:Engine.EngineManager.SimpleEffectSepia">
            <summary>
            holds the simple sepia effect
            </summary>
        </member>
        <member name="F:Engine.EngineManager.SimpleEffectColor">
            <summary>
            over bright image rendering
            ??? MENTION THE OTHER EFFECTS AVAILABLE
            </summary>
        </member>
        <member name="F:Engine.EngineManager.SimpleEffectOverlay">
            <summary>
            let's pixel colour be based on a separate overlay texture.
            This texture must be set using ?????
            </summary>
        </member>
        <member name="F:Engine.EngineManager.offscreenTargets">
            <summary>
            holds render targets for sprite processing
            </summary>
        </member>
        <member name="P:Engine.EngineManager.ViewportFullScreen">
            <summary>
            gets a standard fullscreen viewport
            </summary>
        </member>
        <member name="P:Engine.EngineManager.SpriteListInUse">
            <summary>
            returns true 
            </summary>
        </member>
        <member name="M:Engine.EngineManager.LockSpriteList">
            <summary>
            locks the sprite list prior to processing in some form
            </summary>
        </member>
        <member name="M:Engine.EngineManager.UnlockSpriteList">
            <summary>
            unlocks sprite list, if any pending requests exist the sprite are added to the full sprite list
            </summary>
        </member>
        <member name="F:Engine.EngineManager.enginePeriod">
            <summary>
            holds the current update timespan period
            </summary>
        </member>
        <member name="F:Engine.EngineManager.Up">
            <summary>
            holds a value indicating whether app is live or closing
            </summary>
        </member>
        <member name="M:Engine.EngineManager.Update(Microsoft.Xna.Framework.GameTime)">
            <summary>
            performs engine updates
            </summary>
            <param name="gameTime"></param>
        </member>
        <member name="F:Engine.EngineManager._logicActive">
            <summary>
            determines if sprite updates and collisions should continue to be processed
            </summary>
        </member>
        <member name="M:Engine.EngineManager.CancelLogic">
            <summary>
            stops sprite processing and collision processing for the current update
            use this when you want to change state and abandon all logical processing until new state is active
            </summary>
        </member>
        <member name="M:Engine.EngineManager.SpriteCollisions(Engine.WorkUnit)">
            <summary>
            process sprite collisions
            </summary>
            <param name="wu">The work unit to process</param>
        </member>
        <member name="P:Engine.EngineManager.newState">
            <summary>
            delegate to call when changing state, you can change state at anytime but this
            can have in some circumstances fatal consequences to dependencies and logic fall through
            </summary>
        </member>
        <member name="M:Engine.EngineManager.BringOutTheDead">
            <summary>
            removes any sprites that have died before we attempt to render them
            </summary>
        </member>
        <member name="M:Engine.EngineManager.RenderList(Engine.WorkUnit)">
            <summary>
            Produces the list of sprites to render to the screen
            </summary>
            <param name="wu">The work unit to process</param>
        </member>
        <member name="M:Engine.EngineManager.OnScreen(Engine.Sprite)">
            <summary>
            works out if sprite on screen, based on its layers view associations
            </summary>
            <param name="s">sprite to examine</param>
            <returns>true if it should be rendered</returns>
        </member>
        <member name="M:Engine.EngineManager.OnScreen(Engine.SpriteHistory)">
            <summary>
            Works out if history item is on screen (roughly)
            </summary>
            <param name="sh">history item to exam</param>
            <returns>true if it should be rendered</returns>
        </member>
        <member name="M:Engine.EngineManager.AddLine(Engine.Line)">
            <summary>
            adds a line to the engine manager for rendering. For now you add this once like a sprite and the engine will keep drawing it.
            If you want to change the position of the line do this from your line reference. Set the alpha to 0 to make a line dissapear.
            If you want to get rid of all the lines then use ClearLineList()
            </summary>
            <param name="lineToDraw">the line definition that the engine is supposed to draw</param>
        </member>
        <member name="M:Engine.EngineManager.RemoveLine(Engine.Line)">
            <summary>
            attempts to remove the given line from the line list
            </summary>
            <param name="lineToRemove">The line to remove from the engines render list</param>
        </member>
        <member name="M:Engine.EngineManager.LineRemoveOwners(Engine.OwnerInfo)">
            <summary>
            attempts to remove any lines that match the specified owner given and the reference given
            </summary>
            <param name="ownerInfo">The owner info (track manager reference)</param>
            <remarks>If you want to remove all the lines of an owner, leave IdReference and idSubReference as -1.
            If you want to remove a specific set of lines, set the IdReference to the particular line to remove.
            if you want to remove a specific line, set the IdReference and IdSubreference appropriately</remarks>
        </member>
        <member name="M:Engine.EngineManager.ClearLineList">
            <summary>
            clear all the lines set to be drawn by the engine
            </summary>
        </member>
        <member name="M:Engine.EngineManager.AddSprite(Engine.SpriteBase)">
            <summary>
            adds a basic sprite to the manager, this will just be drawn at its
            current position
            </summary>
            <param name="s">The SpriteBase types sprite (or basic sprite) to add</param>
        </member>
        <member name="F:Engine.EngineManager._basicSprites">
            <summary>
            holds the basic sprites, those that just get rendered
            </summary>
        </member>
        <member name="M:Engine.EngineManager.AddSprite(Engine.Sprite)">
            <summary>
            Adds a sprite to the managed list of sprites
            </summary>
            <param name="s">The sprite you wish to add</param>
        </member>
        <member name="M:Engine.EngineManager.AddSprite">
            <summary>
            Adds a sprite to the managed sprite list returning the sprite for additional settings.
            You can use this to create a sprite with one line of code, for example
            <code>
            Sprite s = new Sprite();
            engineM.AddSprite(s);
            
            can be replaced with
            
            Sprite s = engineM.AddSprite();
            </code>
            </summary>
        </member>
        <member name="M:Engine.EngineManager.KillFirstSpriteType(System.Int32)">
            <summary>
            Kills the first sprite found with the type given, if a funeral is
            associated then it will be executed
            </summary>
            <param name="type">The type of sprite to kill</param>
        </member>
        <member name="M:Engine.EngineManager.KillSpriteType(System.Int32)">
            <summary>
            kills all sprites found of the given type, any funerals will be called
            </summary>
            <param name="type">the type to kill</param>
        </member>
        <member name="M:Engine.EngineManager.ClearSprites">
            <summary>
            removes all sprites from system
            must only use this from a newState delegate call
            </summary>
        </member>
        <member name="M:Engine.EngineManager.GetFirstSpriteType(System.Int32)">
            <summary>
            returns the first sprite we can find of the given type,
            useful if you have single type sprites such as insertcoin or pressstart
            </summary>
            <param name="type">the type to search for</param>
            <returns>the sprite found ir null if non exist</returns>
        </member>
        <member name="M:Engine.EngineManager.GetSpriteList(System.Collections.Generic.List{Engine.Sprite}@,System.Int32)">
            <summary>
            fills a list of all the sprites of a certain type
            </summary>
            <param name="list">The List of Sprite to fill</param>
            <param name="type">the type of sprite to locate</param>
            <returns>the list of sprites, if none found this will be null test for it</returns>
        </member>
        <member name="M:Engine.EngineManager.GetSpriteList(System.Int32)">
            <summary>
            returns a list of sprites containing the given type requested
            </summary>
            <param name="type">Sprite type to return (the number you allocated for this type)</param>
            <returns>Request list of sprites, ensure to check for an empty list before processing</returns>
        </member>
        <member name="M:Engine.EngineManager.GetSprite(Engine.Sprite)">
            <summary>
            returns a sprite with a particular id if it exists
            </summary>
            <param name="thisSprite">The sprite to obtain</param>
            <returns>The sprite or null if not found</returns>
        </member>
        <member name="M:Engine.EngineManager.GetSprite(System.Int32)">
            <summary>
            returns a sprite with a particular id if it exists
            </summary>
            <param name="spriteId">The id of the sprite to obtain</param>
            <returns>The sprite or null if not found</returns>
        </member>
        <member name="M:Engine.EngineManager.RemoveSprite(Engine.Sprite)">
            <summary>
            Attempts to remove from the spritelist
            </summary>
            <param name="thisSprite">the sprite to be removed</param>
        </member>
        <member name="M:Engine.EngineManager.RemoveSprite(System.Int32)">
            <summary>
            Attempts to remove from the spritelist
            </summary>
            <param name="thisId">the id of the sprite to be removed</param>
        </member>
        <member name="M:Engine.EngineManager.RemoveSpriteType(System.Int32)">
            <summary>
            Removes all sprites of a given type
            </summary>
            <param name="type">The type of sprite we wish to remove</param>
            <remarks>Removes the sprites from the list without calling funeral handlers</remarks>
        </member>
        <member name="M:Engine.EngineManager.RemoveFirstSpriteType(System.Int32)">
            <summary>
            removes the first sprite encountered of the given type
            </summary>
            <param name="type">the type of sprite to look for</param>
        </member>
        <member name="F:Engine.EngineManager.descZ">
            <summary>
            creates an instance of the Z sorter
            </summary>
        </member>
        <member name="F:Engine.EngineManager._pointS">
            <summary>
            sprite ref during point checking
            </summary>
        </member>
        <member name="M:Engine.EngineManager.PointInSprite(Microsoft.Xna.Framework.Vector2,System.Int32[])">
            <summary>
            looks for the first sprite of the type given that contains the point
            </summary>
            <param name="point">the position to look inside a sprite</param>
            <param name="type">the array containing types of sprites to search for</param>
        </member>
        <member name="M:Engine.EngineManager.PointInSpriteView(Microsoft.Xna.Framework.Vector2,System.Int32[],System.Int32)">
            <summary>
            looks for the first sprite of the type given that contains the point in the given viewport
            </summary>
            <param name="point">the position to look inside a sprite</param>
            <param name="type">the array containing types of sprites to search for</param>
            <param name="viewIndex">The viewport to look for</param>
        </member>
        <member name="M:Engine.EngineManager.PointInSprite(Microsoft.Xna.Framework.Vector2,System.Int32)">
            <summary>
            looks for the first sprite of the type given that contains the point
            </summary>
            <param name="point">the position to look inside a sprite</param>
            <param name="type">the type of sprite to search for</param>
        </member>
        <member name="M:Engine.EngineManager.PointInSpriteView(Microsoft.Xna.Framework.Vector2,System.Int32,System.Int32)">
            <summary>
            looks for the first sprite of the type given that contains the point in the given viewport
            </summary>
            <param name="point">the position to look inside a sprite</param>
            <param name="type">the type of sprite to search for</param>
            <param name="viewIndex">The viewport to look for</param>
        </member>
        <member name="M:Engine.EngineManager.PointInSprite(Microsoft.Xna.Framework.Vector2)">
            <summary>
            looks for the first sprite of the type given that contains the point
            </summary>
            <param name="point">the position to look inside a sprite</param>
        </member>
        <member name="M:Engine.EngineManager.PointInSpriteViewRadius(Microsoft.Xna.Framework.Vector2)">
            <summary>
            looks for the first sprite that contains the point for main viewport, based in it's Radius value
            </summary>
            <param name="point">the position to look inside a sprite</param>
        </member>
        <member name="M:Engine.EngineManager.PointInSpriteViewRadius(System.Int32,Microsoft.Xna.Framework.Vector2)">
            <summary>
            looks for the first sprite of the type given that contains the point , based in it's Radius value
            </summary>
            <param name="point">the position to look inside a sprite</param>
            <param name="type">sprite type to look at</param>
        </member>
        <member name="M:Engine.EngineManager.PointInSpriteViewRadius(Microsoft.Xna.Framework.Vector2,System.Int32,System.Int32)">
            <summary>
            looks for the first sprite of the type given that contains the point for the given view index, based in it's Radius value
            </summary>
            <param name="point">the position to look inside a sprite</param>
            <param name="viewIndex">The viewport to look for</param>
            <param name="type">sprite type to look at</param>
        </member>
        <member name="M:Engine.EngineManager.PointInSpriteViewRadius(Microsoft.Xna.Framework.Vector2,System.Int32)">
            <summary>
            looks for the first sprite of the type given that contains the point for the given view index, based in it's Radius value
            </summary>
            <param name="point">the position to look inside a sprite</param>
            <param name="viewIndex">The viewport to look for</param>
        </member>
        <member name="M:Engine.EngineManager.PointInSpriteView(Microsoft.Xna.Framework.Vector2,System.Int32)">
            <summary>
            looks for the first sprite of the type given that contains the point for the given view index
            </summary>
            <param name="point">the position to look inside a sprite</param>
            <param name="viewIndex">The viewport to look for</param>
        </member>
        <member name="M:Engine.EngineManager.HistorySnapper(Engine.Sprite)">
            <summary>
            snaps the current history settings for the sprite
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:Engine.EngineManager.SpriteUpdate(Engine.WorkUnit)">
            <summary>
            updates a subset of the sprite list in prep for multithreading support
            need to do some tests on this this is a rough version not full version yet.
            </summary>
            <param name="wu">the workunit to process</param>
            <returns>number of sprites updated</returns>
        </member>
        <member name="F:Engine.EngineManager.fadeAmount">
            <summary>
            global fadeamount for colour fading is not re-entrant
            </summary>
        </member>
        <member name="F:Engine.EngineManager.sh">
            <summary>
            history worker
            </summary>
        </member>
        <member name="M:Engine.EngineManager.ToggleFullScreen">
            <summary>
            asks the engine to switch screen modes from/to full screen and window mode
            </summary>
        </member>
        <member name="F:Engine.EngineManager.spritesDrawn">
            <summary>
            holds number of sprites drawn
            </summary>
        </member>
        <member name="P:Engine.EngineManager.SpritesDrawn">
            <summary>
            returns number of sprites drawn this frame
            </summary>
        </member>
        <member name="F:Engine.EngineManager.historyDrawn">
            <summary>
            holds number of sprites drawn
            </summary>
        </member>
        <member name="P:Engine.EngineManager.HistoryDrawn">
            <summary>
            returns number of sprites drawn this frame
            </summary>
        </member>
        <member name="P:Engine.EngineManager.TotalDrawn">
            <summary>
            gets total sprite related items drawn to buffer
            </summary>
        </member>
        <member name="F:Engine.EngineManager.scalefocal">
            <summary>
            holds pre-calculated scale and focal length of layer
            </summary>
        </member>
        <member name="F:Engine.EngineManager.updated">
            <summary>
            holds number of sprites that were update during last update by Engine (paused sprites are not counted)
            </summary>
        </member>
        <member name="M:Engine.EngineManager.ProcessLineRenderCounts">
            <summary>
            iterate through line list so we can determine if we need to render any lines to a particular layer
            </summary>
        </member>
        <member name="M:Engine.EngineManager.ProcessParticleRendering">
            <summary>
            determines if we need to be rendering any particles on each layer
            </summary>
        </member>
        <member name="M:Engine.EngineManager.AddParticles(Engine.ParticleSet)">
            <summary>
            tell engine these particles need rendering, this must be done once only, you need to remove the particles by changing their alive status
            if all the particles need to go then use RemoveParticles(particleSet) or ClearAllParticles()
            </summary>
            <param name="particleSet">Particleset to draw only those marked alive will be rendered, although you could kill these yourself</param>
        </member>
        <member name="M:Engine.EngineManager.RemoveParticles(Engine.ParticleSet)">
            <summary>
            removes completely a particle set from the rendering pipeline
            </summary>
            <param name="particleSet"></param>
        </member>
        <member name="M:Engine.EngineManager.ClearAllParticles">
            <summary>
            removes all particle sets from the rendering pipeline
            </summary>
        </member>
        <member name="M:Engine.EngineManager.Draw(Microsoft.Xna.Framework.GameTime)">
            <summary>
            draw the game!
            </summary>
            <param name="gameTime"></param>
        </member>
        <member name="M:Engine.EngineManager.SpriteDebugText(Engine.Sprite)">
            <summary>
            adds text for debugging output to the text manager
            </summary>
            <param name="s">Sprite being looked at</param>
        </member>
        <member name="M:Engine.EngineManager.EngineDebugText">
            <summary>
            produces the general engine debug text
            </summary>
        </member>
        <member name="M:Engine.EngineManager.ShowMatrix(Microsoft.Xna.Framework.Matrix)">
            <summary>
            Puts a matrix into a nice format for display
            </summary>
            <param name="m">The matirx to display</param>
            <returns>a stringbuilder object containing the matrix</returns>
        </member>
        <member name="P:Engine.EngineManager.LastSprite">
            <summary>
            gets the last sprite added to the engine manager
            </summary>
        </member>
        <member name="T:Engine.EngineResource">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Engine.EngineResource.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Engine.EngineResource.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Engine.EngineResource.BackupFont">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:Engine.EngineResource.FontSheet">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:Engine.EngineResource.grayscale">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:Engine.EngineResource.Overlay">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:Engine.EngineResource.PostEffects">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:Engine.EngineResource.sepia">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:Engine.EngineResource.Shinyballs">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:Engine.EngineResource.SystemFont">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:Engine.EngineResource.WhiteOut">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="T:Engine.InterpretAlpha">
            <summary>
            specfies how to use alpha values
            </summary>
        </member>
        <member name="F:Engine.InterpretAlpha.preserve">
            <summary>
            keep alpha value intact, so we maintain individual pixel transparency, for graduated pixel effects
            </summary>
        </member>
        <member name="F:Engine.InterpretAlpha.makeOpaque">
            <summary>
            take any non zero alpha value and treat it as opaque (solid)
            </summary>
        </member>
        <member name="T:Engine.LineType">
            <summary>
            speficies the type of line being held
            </summary>
        </member>
        <member name="F:Engine.LineType.Undefined">
            <summary>
            An empty line
            </summary>
        </member>
        <member name="F:Engine.LineType.PointLength">
            <summary>
            A line specified by a point, a length and an angle
            </summary>
        </member>
        <member name="F:Engine.LineType.PointAndDirectionVector">
            <summary>
            a line specifed by a point vector and a direction vector describing the length and angle
            </summary>
        </member>
        <member name="F:Engine.LineType.TwoPoints">
            <summary>
            a line specified by two points
            </summary>
        </member>
        <member name="F:Engine.LineType.PolygonClosed">
            <summary>
            multiple verticies specifying a closed shape
            </summary>
        </member>
        <member name="F:Engine.LineType.PolygonOpen">
            <summary>
            multiple vertices specifying an open shape
            </summary>
        </member>
        <member name="T:Engine.TileWashMode">
            <summary>
            specifies how to use colour washing when rendering TileMaps
            </summary>
        </member>
        <member name="F:Engine.TileWashMode.Tile">
            <summary>
            use the individual Tiles, colour wash information (default)
            </summary>
        </member>
        <member name="F:Engine.TileWashMode.Global">
            <summary>
            use the TileMaps Wash property
            </summary>
        </member>
        <member name="F:Engine.TileWashMode.ColourMap">
            <summary>
            use the colour Map values
            </summary>
        </member>
        <member name="T:Engine.TileMapOverlay">
            <summary>
            specifies what overaly information should be shown
            </summary>
        </member>
        <member name="F:Engine.TileMapOverlay.coordinates">
            <summary>
            show co-ordinates of tiles
            </summary>
        </member>
        <member name="F:Engine.TileMapOverlay.contents">
            <summary>
            show the contents of the tile
            </summary>
        </member>
        <member name="F:Engine.TileMapOverlay.collisionContents">
            <summary>
            show the contents of the corresponding collision tile
            </summary>
        </member>
        <member name="F:Engine.TileMapOverlay.alphavalue">
            <summary>
            shows the alpha value of the alpha map (must be enabled)
            </summary>
        </member>
        <member name="T:Engine.Shape">
            <summary>
            a generic shape to treat the sprite as during collision processing
            </summary>
        </member>
        <member name="F:Engine.Shape.circle">
            <summary>
            assume the sprite is circular
            </summary>
        </member>
        <member name="F:Engine.Shape.rectangle">
            <summary>
            assume the sprite is rectangular
            </summary>
        </member>
        <member name="T:Engine.TagDisplay">
            <summary>
            how the marker should work with the menu
            </summary>
            <remarks>These should not need to be set manually they are set when you
            specify how the tag works with the track such as TagFollowSelection()</remarks>
        </member>
        <member name="F:Engine.TagDisplay.followSelection">
            <summary>
            places tag at sprite position using specified tag alignment
            </summary>
        </member>
        <member name="F:Engine.TagDisplay.trackPosition">
            <summary>
            places tag at position along a track that a sprite menu item will 
            eventually occupy
            </summary>
        </member>
        <member name="T:Engine.MenuType">
            <summary>
            specifies whether this is a text or sprite based menu
            </summary>
            <remarks>Sprite menus are much more flexible</remarks>
        </member>
        <member name="F:Engine.MenuType.sprite">
            <summary>
            uses the sprite engine and track system to manipulate and show the menu items
            </summary>
        </member>
        <member name="F:Engine.MenuType.text">
            <summary>
            uses text engine to display menu choices
            </summary>
        </member>
        <member name="T:Engine.MenuSelectMode">
            <summary>
            Specifies how a menu selects the current MenuItem, you should not need to manually
            set this value
            </summary>
        </member>
        <member name="F:Engine.MenuSelectMode.tag">
            <summary>
            Menu Item at the same position as the tag is marked for selection.
            </summary>
            <remarks>
            This should only be used on track based menus as the tag needs to be at exactly
            at the same position as a MenuItem using
            TagMakeSelection()
            </remarks>
        </member>
        <member name="F:Engine.MenuSelectMode.user">
            <summary>
            Menu items are selected by using the Next(), Previous(), SelectAt methods.
            You will need to specify how the tag (if any) highlights the selction using
            TagFollowSelection()
            </summary>
        </member>
        <member name="T:Engine.scoreOrder">
            <summary>
            identifies the type of the score table
            </summary>
        </member>
        <member name="F:Engine.scoreOrder.HighScore">
            <summary>
            A standard score table where the 1st score is the highest
            </summary>
        </member>
        <member name="F:Engine.scoreOrder.LowScore">
            <summary>
            A low score table where 1st score is the lowest
            </summary>
        </member>
        <member name="T:Engine.Fade">
            <summary>
            Colour fading methods used by sprite fade system
            based on the Z value of a sprite
            </summary>
            <remarks>Used for fade effects for 3D sprites</remarks>
        </member>
        <member name="F:Engine.Fade.alpha">
            <summary>
            change the alpha transparency component only
            </summary>
        </member>
        <member name="F:Engine.Fade.colour">
            <summary>
            change the colour components RGB only
            </summary>
        </member>
        <member name="F:Engine.Fade.colourAndAlpha">
            <summary>
            change all components ARGB
            </summary>
        </member>
        <member name="T:Engine.EndOfTrackAction">
            <summary>
            States what should happen when a sprite reaches the end of its current track
            </summary>
        </member>
        <member name="F:Engine.EndOfTrackAction.random">
            <summary>
            at end of track pick another track from those associated with the Sprite
            </summary>
            <remarks>Great for random boss movement patterns</remarks>
        </member>
        <member name="F:Engine.EndOfTrackAction.detach">
            <summary>
            forces the sprite to leave the track and continue in the direction it was last moving
            </summary>
            <remarks>Nice to use if you turn gravity on for a sprite once its detached if you use 
            an OnTrackEnd handler to alter the sprites properties</remarks>
        </member>
        <member name="F:Engine.EndOfTrackAction.wrap">
            <summary>
            start again on the current track
            </summary>
            <remarks>Useful for fancy menu like sega 3d ones for name entry</remarks>
        </member>
        <member name="F:Engine.EndOfTrackAction.reverse">
            <summary>
            go backwards along the current track
            </summary>
            <remarks>Nice to use for display or target type tracks</remarks>
        </member>
        <member name="F:Engine.EndOfTrackAction.kill">
            <summary>
            kill the sprite at the end of the track
            </summary>
            <remarks>Can use for explosion effects in conjuction with a Sprite funeral</remarks>
        </member>
        <member name="F:Engine.EndOfTrackAction.next">
            <summary>
            move on to the start of the next track
            </summary>
            <remarks>Use if you want a sprite to follow a specific sequence of tracks.
            The order is governed by the order you used the Sprite.AddTrack() methods</remarks>
        </member>
        <member name="F:Engine.EndOfTrackAction.stop">
            <summary>
            Halt sprite at the end of the track
            </summary>
            <remarks>Use if you want a sprite to travel to the end and the stop and do something
            like launch a bullet at the player (see the yellow circular star force enemies)
             use in conjuction with OnTrackEnd handler. After firing you can ask the Sprite to
             follow a second track to move off screen again.</remarks>
        </member>
        <member name="T:Engine.TrackStepMode">
            <summary>
            States how the sprite should move along the track
            </summary>
            <remarks>Discrete step is for manually control of a track</remarks>
        </member>
        <member name="F:Engine.TrackStepMode.discreteStep">
            <summary>
            operate using a fixed step 
            move along a certain number of points during each update
            </summary>
        </member>
        <member name="F:Engine.TrackStepMode.pixelsPerSec">
            <summary>
            approximate a time to travel along so many pixels of the track
            in the same way as sprite velocity works
            </summary>
        </member>
        <member name="T:Engine.duplicateEffect">
            <summary>
            Determines what happens if a duplicate effect with the same instance name is played
            </summary>
        </member>
        <member name="F:Engine.duplicateEffect.dontPlay">
            <summary>
            if an effect with the same instance name is currently playing
            abandon playing this new instance
            </summary>
        </member>
        <member name="F:Engine.duplicateEffect.restartCurrent">
            <summary>
            if an effect with the same instance name is currently playing
            then stop it and start it again
            </summary>
        </member>
        <member name="F:Engine.duplicateEffect.createAnotherInstance">
            <summary>
            if an effect with the same instance name is currently playing
            then create a unique instance name and play this effect as well
            </summary>
        </member>
        <member name="T:Engine.audioEffect">
            <summary>
            Specifies which audio effects to apply to a managed sound effect
            </summary>
        </member>
        <member name="F:Engine.audioEffect.None">
            <summary>
            apply no effects
            </summary>
        </member>
        <member name="F:Engine.audioEffect.PanAroundViewport">
            <summary>
            Pan left and right depending on relation of sprite to Viewport centre
            </summary>
        </member>
        <member name="F:Engine.audioEffect.DopplerAroundViewport">
            <summary>
            Alter pitch based on travel towards/from the Viewport centre
            </summary>
        </member>
        <member name="F:Engine.audioEffect.VolumeAroundViewport">
            <summary>
            Alter volume based on distance from Viewport centre
            </summary>
        </member>
        <member name="F:Engine.audioEffect.AllAroundViewport">
            <summary>
            applies all 3 effects, doppler, pan and volume for viewer at viewport
            </summary>
        </member>
        <member name="F:Engine.audioEffect.PanAroundPosition">
            <summary>
            Pan left and right depending on relation of sprite to the viewer at the given position
            </summary>
        </member>
        <member name="F:Engine.audioEffect.DopplerAroundPosition">
            <summary>
            Alter pitch based on travel towards/from the viewer at the given position
            </summary>
        </member>
        <member name="F:Engine.audioEffect.VolumeAroundPosition">
            <summary>
            Alter volume based on distance from viewer at the given position
            </summary>
        </member>
        <member name="F:Engine.audioEffect.AllAroundPosition">
            <summary>
            applies all 3 effects, doppler, pan and volume for viewer at the given position
            </summary>
        </member>
        <member name="F:Engine.audioEffect.PanAroundSprite">
            <summary>
            Pan left and right depending on relation of sprite to viewer at the given sprite
            </summary>
        </member>
        <member name="F:Engine.audioEffect.DopplerAroundSprite">
            <summary>
            Alter pitch based on travel towards/from viewer at the given sprite
            </summary>
        </member>
        <member name="F:Engine.audioEffect.VolumeAroundSprite">
            <summary>
            Alter volume based on distance from to viewer at the given sprite
            </summary>
        </member>
        <member name="F:Engine.audioEffect.AllAroundSprite">
            <summary>
            applies all 3 effects, doppler, pan and volume for viewer at the given sprite
            </summary>
        </member>
        <member name="T:Engine.UpdateMode">
            <summary>
            Determines how the sprites position should be updated by the Engine Manager
            </summary>
            <remarks>Most of the time these will be automatically set based on the modes
            you are using for a sprite (track, velocities etc...)</remarks>
        </member>
        <member name="F:Engine.UpdateMode.manual">
            <summary>
            Engine does animation
            </summary>
        </member>
        <member name="F:Engine.UpdateMode.automatic">
            <summary>
            under direct user control or through velocities
            </summary>
        </member>
        <member name="F:Engine.UpdateMode.automaticTrack">
            <summary>
            follow a track using track fields
            </summary>
        </member>
        <member name="F:Engine.UpdateMode.manualTrack">
            <summary>
            follow a track but under user control (step when wanted)
            </summary>
        </member>
        <member name="F:Engine.UpdateMode.none">
            <summary>
            don't attempt to move or add gravity to this sprite
            </summary>
        </member>
        <member name="T:Engine.DirectionAccuracy">
            <summary>
            Specify underlying direction accuracy in direction methods
            </summary>
            <remarks>free will give you the exact angle towards something and ordinals will 
            force the angle to be 0, 90, 180 or 270 degrees</remarks>
        </member>
        <member name="F:Engine.DirectionAccuracy.ordinals">
            <summary>
            Closest to North, South, East or West
            </summary>
        </member>
        <member name="F:Engine.DirectionAccuracy.free">
            <summary>
            Allow specific angle in direction
            </summary>
        </member>
        <member name="T:Engine.LimitAction">
            <summary>
            Actions to be taken once a Sprite meets or passes the limit box edge that is defined
            </summary>
            <remarks>The limit box can be any given rectangular or 3d box area or
             the current position of the ViewPort. Limit boxes are only active once a sprite fully enters them,
             if you are having trouble with a limit box make sure you make it visible using
             Limit.Show()</remarks>
        </member>
        <member name="F:Engine.LimitAction.nothing">
            <summary>
            no boundary control
            </summary>
        </member>
        <member name="F:Engine.LimitAction.bounce">
            <summary>
            make sprite bounce back in opposite direction
            </summary>
            <remarks>Nice for keeping a sprite within the boundaries of screen or rectangle. 
            Such as in breakout/arkanoid type games</remarks>
        </member>
        <member name="F:Engine.LimitAction.bounceZonly">
            <summary>
            Performs a bounce but only bothers checking the front and back of the limit box
            </summary>
            <remarks>Great when used in conjuction with Z gravity and auto sprite scaling
            to create a throbbing sprite</remarks>
        </member>
        <member name="F:Engine.LimitAction.bounceAlign">
            <summary>
            make sprite bounce back in opposite direction but align with collided edge
            </summary>
            <remarks>Only use this if you want the sprite to start its bounce aligned to the
            edge of the limit box, you might get odd effects when doing this</remarks>
        </member>
        <member name="F:Engine.LimitAction.wrap">
            <summary>
            make sprite appear on other side of limit box
            </summary>
            <remarks>Aligns the sprite with the opposite edge of limit box. Which can cause
            odd effects with groups of sprites following each other, use wrapExact instead.</remarks>
        </member>
        <member name="F:Engine.LimitAction.wrapExact">
            <summary>
            makes sprite appear on other side of limit box taking
            account of exact position when leaving the limit box
            </summary>
            <remarks>
            use this for scrolling text or groups of sprites for an Asteroid wrapping effect
            </remarks>
        </member>
        <member name="F:Engine.LimitAction.wrapXBounceY">
            <summary>
            only wrap in X direction, but bounce in Y direction
            </summary>
            <remarks>Use this if you want the sprite to wrap horizontally but fall under gravity</remarks>
        </member>
        <member name="F:Engine.LimitAction.wrapYBounceX">
            <summary>
            only wrap in Y direction, but bounce in X direction
            </summary>
            <remarks>Use this if you want the sprite to wrap vertically but bounce off the sides</remarks>
        </member>
        <member name="F:Engine.LimitAction.stopAt">
            <summary>
            make sprite stop moving in axis of limit box and align with collided edge
            </summary>
            <remarks>If a sprite hits the vertical edges of limit box then its horizontal
            velocity is stopped, it can still move vertically until it hits the top or
             bottom of the limit box</remarks>
        </member>
        <member name="F:Engine.LimitAction.stopFirstTouch">
            <summary>
            make the sprite stop moving if any of borders are touched
            </summary>
            <remarks>Useful for title graphics where you want a sprite to stop in a specific
            horizontal or vertical position but dont want to worry about exact size of limit box required</remarks>
        </member>
        <member name="F:Engine.LimitAction.stopThenKill">
            <summary>
            make sprite stop moving in axis of limit box and kill if no velocity set
            </summary>
            <remarks>Works like stop but if sprite has no velocity it will be killed</remarks>
        </member>
        <member name="F:Engine.LimitAction.killPast">
            <summary>
            kill sprite once outside limit box
            </summary>
            <remarks>Use this to remove sprites once they have gone past the viewport 
            (unless you want them to come back on screen). This will remove them without them
            flashing off while still visible</remarks>
        </member>
        <member name="F:Engine.LimitAction.killTouch">
            <summary>
            kill sprite as soon as it touches limit box
            </summary>
            <remarks>Greate for implementing electric fences etc...</remarks>
        </member>
        <member name="F:Engine.LimitAction.killInside">
            <summary>
            kill sprite as soon as it enters the limit box
            </summary>
            <remarks>The sprite has to fit inside the limit box
            Useful for setting defence boundaries around turrets etc..
            </remarks>
        </member>
        <member name="F:Engine.LimitAction.killPastXBounceY">
            <summary>
            kills sprite if goes past X limit box, but bounces on Y
            </summary>
        </member>
        <member name="F:Engine.LimitAction.killPastXStopY">
            <summary>
            kills a sprite if it goes past the left/right boundaries and 
            stops sprites vertical movement if it touches top/bottom
            </summary>
        </member>
        <member name="F:Engine.LimitAction.killPastYStopX">
            <summary>
            killPastYStopX, kills a sprite if it goes past top/bottom 
            boundaries and stops sprites horizontal movement if it touches left/right
            </summary>
        </member>
        <member name="F:Engine.LimitAction.inform">
            <summary>
            Notify using AtLimit property
            </summary>
            <remarks>Use this in conjuction with an UpdateHandler to determine when sprite
            hits an edge</remarks>
        </member>
        <member name="F:Engine.LimitAction.informAlign">
            <summary>
            Notify by setting AtBoundary to true and align with collided edge
            </summary>
            <remarks>Use this in conjuction with an UpdateHandler to determine when sprite
            hits an edge, this can be seen in use in the Space Invaders code. As soon as one
            invader hits the limit box all the invaders are then dropped down a line</remarks>
        </member>
        <member name="F:Engine.LimitAction.turnOffGravity">
            <summary>
            Turns gravity off once collided and aligns sprite with limit box
            </summary>
            <remarks>Use this when you want a sprite to stop falling after you have
            made it move under gravity</remarks>
        </member>
        <member name="F:Engine.LimitAction.turnOffGravityBottomOnly">
            <summary>
            Turns off gravity but only if contact with bottom of limit box occurs
            </summary>
        </member>
        <member name="F:Engine.LimitAction.fireEvent">
            <summary>
            executes the sprite update routine specified using OnLimit(). You need to handle any other actions
            you want to apply to the sprite yourself, the event will continue to fire if your
            sprite is still at the limit box, so you need to ensure that you set OnLimit = null if you do not want this behaviour
            </summary>
        </member>
        <member name="T:Engine.AnimationMethod">
            <summary>
            Determines how the sprite should be animated
            </summary>
            <remarks>onUpdate, onRate and onMoveDiatance work at the moment, 
            onUpdateRate hasn't been implemented yet</remarks>
        </member>
        <member name="F:Engine.AnimationMethod.paused">
            <summary>
            waiting for a resume (no other animation states can be set until Resume is called)
            </summary>
        </member>
        <member name="F:Engine.AnimationMethod.none">
            <summary>
            no animation
            </summary>
        </member>
        <member name="F:Engine.AnimationMethod.onUpdate">
            <summary>
            change frame when sprite is updated, which is controlled by the UpdateRate of the sprite
            <remarks>Can be used to give a space invaders type of animation</remarks>
            </summary>
        </member>
        <member name="F:Engine.AnimationMethod.onRate">
            <summary>
            The sprite will be animated when the specified number of seconds have passed
            </summary>
        </member>
        <member name="F:Engine.AnimationMethod.onMoveDistance">
            <summary>
            change frame whenever the sprite moves further than a specified 
            number of pixels
            <remarks>This is great for walking characters, you'll need to play with the distance
            before animation looks realistic, you may get scooby doo slidy animation effects otherwise</remarks>
            </summary>
        </member>
        <member name="T:Engine.LastFrameAction">
            <summary>
            Determines what happens when the animation reaches the last frame in the specified sequence
            </summary>
            <remarks>More animation methods need implementing but I don't know what they are yet</remarks>
        </member>
        <member name="F:Engine.LastFrameAction.continueInterrupted">
            <summary>
            continue animation of the state that was interrupted when this one started
            </summary>
        </member>
        <member name="F:Engine.LastFrameAction.restartInterrupted">
            <summary>
            restarts the animation of the state that was interrupted when this one started
            </summary>
        </member>
        <member name="F:Engine.LastFrameAction.gotoNextState">
            <summary>
            moves to the next animation state, resetting the current one first
            </summary>
        </member>
        <member name="F:Engine.LastFrameAction.gotoPreviousState">
            <summary>
            moves to the previous animation state, resetting the current one first
            </summary>
        </member>
        <member name="F:Engine.LastFrameAction.halt">
            <summary>
            similar to stop but does not change animation method or state but 
            keeps displaying last frame in range until manually reverted to a previous state
            </summary>
        </member>
        <member name="F:Engine.LastFrameAction.stop">
            <summary>
            if animation has gone past start or end of available animation frames
            remain at that position
            </summary>
        </member>
        <member name="F:Engine.LastFrameAction.stopThenFirst">
            <summary>
            if animation has gone past start or end of available animation frames 
            revert to first frame in sequence and stop animation
            </summary>
        </member>
        <member name="F:Engine.LastFrameAction.repeat">
            <summary>
            if animation has gone past start or end of available animation frames
            go back to first frame and continue
            </summary>
        </member>
        <member name="F:Engine.LastFrameAction.reverse">
            <summary>
            if animation has gone past start or end then reverse direction
            </summary>
        </member>
        <member name="F:Engine.LastFrameAction.kill">
            <summary>
            if animation has gone past start or end of available animation frames
            kill the sprite ha ha!!
            </summary>
            <remarks>Very useful for running an animation then making a sprite dissapear</remarks>
        </member>
        <member name="T:Engine.Debug">
            <summary>
            A series of flags to allow the selection of specifc debug output
            </summary>
            <remarks>use the following format for selecting the info to display
            EngineDebugShow(Debug.fps | Debug.sprite | Debug.layers)</remarks>
        </member>
        <member name="F:Engine.Debug.none">
            <summary>
            no debug output
            </summary>
        </member>
        <member name="F:Engine.Debug.fps">
            <summary>
            show Frames per Second
            </summary>
        </member>
        <member name="F:Engine.Debug.viewport">
            <summary>
            Show Viewport position
            </summary>
        </member>
        <member name="F:Engine.Debug.sprite">
            <summary>
            Show Sprites updated and Drawn
            </summary>
        </member>
        <member name="F:Engine.Debug.tileMap">
            <summary>
            Show info on all active tileMaps
            </summary>
        </member>
        <member name="F:Engine.Debug.text">
            <summary>
            show text sprite information
            </summary>
        </member>
        <member name="F:Engine.Debug.collisions">
            <summary>
            show collisions checks, comparisions and collisions
            </summary>
        </member>
        <member name="F:Engine.Debug.binStats">
            <summary>
            show collision bin totals
            </summary>
        </member>
        <member name="F:Engine.Debug.resAndWorld">
            <summary>
            shows current resolution and world size settings
            </summary>
        </member>
        <member name="F:Engine.Debug.renderLayerProperties">
            <summary>
            Show detailed info about sprite layers and associated info
            </summary>
        </member>
        <member name="F:Engine.Debug.tileMapMatrix">
            <summary>
            displays the matrix used by the particular tileSheet layer
            </summary>
        </member>
        <member name="F:Engine.Debug.renderLayerMatrix">
            <summary>
            displays the transformation matrix used by the particular sprite layer
            </summary>
        </member>
        <member name="F:Engine.Debug.viewer">
            <summary>
            displays the current viewerposition and viewer mode
            </summary>
        </member>
        <member name="F:Engine.Debug.bins">
            <summary>
            information about collision bin items
            </summary>
        </member>
        <member name="F:Engine.Debug.version">
            <summary>
            displays the engine version being used
            </summary>
        </member>
        <member name="F:Engine.Debug.tileMapOverlay">
            <summary>
            if ShowOverlay is true then the overlay for this tilemap will be shown
            </summary>
        </member>
        <member name="F:Engine.Debug.lines">
            <summary>
            Displays total number of lines being rendered
            </summary>
        </member>
        <member name="F:Engine.Debug.particles">
            <summary>
            Displays particles rendered and which layers are active
            </summary>
        </member>
        <member name="F:Engine.Debug.message">
            <summary>
            displays a simple list of all the active message subscriptions
            </summary>
        </member>
        <member name="F:Engine.Debug.events">
            <summary>
            displays active events
            </summary>
        </member>
        <member name="F:Engine.Debug.eventsFull">
            <summary>
            displays full event information for all active events
            </summary>
        </member>
        <member name="F:Engine.Debug.all">
            <summary>
            show all information
            </summary>
        </member>
        <member name="T:Engine.ViewSplit">
            <summary>
            specifies a way to split a given viewport region
            </summary>
        </member>
        <member name="F:Engine.ViewSplit.horizontal">
            <summary>
            split a region horizontally (a top and a bottom)
            </summary>
        </member>
        <member name="F:Engine.ViewSplit.vertical">
            <summary>
            split a region vertically (a left and a right)
            </summary>
        </member>
        <member name="F:Engine.ViewSplit.equal">
            <summary>
            split a region into equal size regions (quarters for a 4 viewports)
            </summary>
        </member>
        <member name="T:Engine.TileMapType">
            <summary>
            specifies the type of tilemap
            </summary>
        </member>
        <member name="F:Engine.TileMapType.back">
            <summary>
            a background tilemap rendered before any sprites
            </summary>
        </member>
        <member name="F:Engine.TileMapType.middle">
            <summary>
            tilemap rendered after sprite layers zero and one
            </summary>
        </member>
        <member name="F:Engine.TileMapType.front">
            <summary>
            a foreground tilemap rendered after the 4 sprite layers
            </summary>
        </member>
        <member name="F:Engine.TileMapType.final">
            <summary>
            A special tilemap that is rendered after all scene rendering even text.
            </summary>
            <remarks>This can be used to wash the entire scene, fade in/fade out swipe style effects,
            when used in conjuction with an Event to adjust the colorWash of a TileSheet</remarks>
        </member>
        <member name="T:Engine.Align">
            <summary>
            how to interpret x and y positions of sprites and text
            </summary>
            <remarks>Use one of the bottom methods when using animation frames that have different heights</remarks>
        </member>
        <member name="F:Engine.Align.top">
            <summary>
            X position is centred, Y position is top,
            </summary>
        </member>
        <member name="F:Engine.Align.topLeft">
            <summary>
            X position is left, Y position is top, 
            </summary>
        </member>
        <member name="F:Engine.Align.left">
            <summary>
            X position is left, Y position is centred, 
            </summary>
        </member>
        <member name="F:Engine.Align.bottomLeft">
            <summary>
            X position is left, Y position is bottom, 
            </summary>
        </member>
        <member name="F:Engine.Align.bottom">
            <summary>
            X position is centred, Y position is bottom, 
            </summary>
        </member>
        <member name="F:Engine.Align.bottomRight">
            <summary>
            X position is right, Y position is bottom, 
            </summary>
        </member>
        <member name="F:Engine.Align.right">
            <summary>
            X position is right, Y position is centred, 
            </summary>
        </member>
        <member name="F:Engine.Align.topRight">
            <summary>
            X position is right, Y position is top, 
            </summary>
        </member>
        <member name="F:Engine.Align.centre">
            <summary>
            X position is centred, Y position is centred, 
            </summary>
        </member>
        <member name="T:Engine.SpriteDebug">
            <summary>
            used to select what debug information to display for a sprite
            </summary>
        </member>
        <member name="F:Engine.SpriteDebug.physical">
            <summary>
            displays the physical properties MASS, Friction and e
            </summary>
        </member>
        <member name="F:Engine.SpriteDebug.position">
            <summary>
            displays Position, alignment and layer information of sprite
            </summary>
        </member>
        <member name="F:Engine.SpriteDebug.rectangle">
            <summary>
            displays sprite rectangle information,
            Texture rectangle for frame, collision rectangle, which may be same as  and the destination rectangle which is offset
            </summary>
        </member>
        <member name="F:Engine.SpriteDebug.ordinalValues">
            <summary>
            NOT IMPLEMENTED YET:The Left, Right, Top and Bottom extents of the sprite
            </summary>
        </member>
        <member name="F:Engine.SpriteDebug.frame">
            <summary>
            displays Animation information for the sprite, such as current frame number,
            animation range and the frame rate if set
            </summary>
            <remarks>This needs expanding</remarks>
        </member>
        <member name="F:Engine.SpriteDebug.rotation">
            <summary>
            displays rotation angle and sprite scale information
            </summary>
            <remarks>Needs expanding</remarks>
        </member>
        <member name="F:Engine.SpriteDebug.trackPosition">
            <summary>
            displays track information for the sprite, track position and fractional position, 
            speed in pixels per second for sprites using TravelWithSpeed() and the actual physical
            position of the sprite based on its current track position
            </summary>
        </member>
        <member name="F:Engine.SpriteDebug.text">
            <summary>
            displays the StorageText property of the sprite
            </summary>
        </member>
        <member name="F:Engine.SpriteDebug.id">
            <summary>
            displays the unique id of the sprite
            </summary>
        </member>
        <member name="F:Engine.SpriteDebug.appearance">
            <summary>
            display the colour wash and alpha value
            </summary>
        </member>
        <member name="F:Engine.SpriteDebug.information">
            <summary>
            display the contents of the StorageInformation property of the sprite
            </summary>
        </member>
        <member name="F:Engine.SpriteDebug.hits">
            <summary>
            displays the number of hits(collisions) this sprite as endured
            </summary>
            <remarks>Use this to check that a sprite does what you expect after a certain number of hits,
            for instance you may want to change the animation frame of a boss after 10 hits to show
            some damage effect</remarks>
        </member>
        <member name="F:Engine.SpriteDebug.history">
            <summary>
            Displays position history for a sprite (a maximum of 20 items)
            </summary>
        </member>
        <member name="F:Engine.SpriteDebug.limit">
            <summary>
            displays limit box information: limit box, Size (width, height and depth),
            Action to take, Whether limit box is active and whether it is visible
            </summary>
            <remarks>limit boxes are only activated once a sprite enters them</remarks>
        </member>
        <member name="F:Engine.SpriteDebug.update">
            <summary>
            displays update rate and elapsed time information for the sprite
            </summary>
            <remarks>Update force a sprite to wait for a certain number of seconds before being
            allowed to move, this is how the space invaders move</remarks>
        </member>
        <member name="F:Engine.SpriteDebug.velocity">
            <summary>
            velocity information
            </summary>
        </member>
        <member name="F:Engine.SpriteDebug.scale">
            <summary>
            scale information including scale velocity
            </summary>
        </member>
        <member name="F:Engine.SpriteDebug.elapsed">
            <summary>
            shows the time elapsed for a sprite with an updateRate
            </summary>
        </member>
        <member name="F:Engine.SpriteDebug.none">
            <summary>
            don't display any debug output, the default value
            </summary>
        </member>
        <member name="F:Engine.SpriteDebug.all">
            <summary>
            display all available debug information
            </summary>
        </member>
        <member name="T:Engine.RotateDirection">
            <summary>
            specifies a rotation to either left or right
            </summary>
        </member>
        <member name="F:Engine.RotateDirection.cw">
            <summary>
            clockwise (right 90)
            </summary>
        </member>
        <member name="F:Engine.RotateDirection.ccw">
            <summary>
            anti-clockwise (left 90)
            </summary>
        </member>
        <member name="T:Engine.Direction">
            <summary>
            A direction value that can be interrogated
            for oridnal based information used for collisions etc...
            This may be superseeded as it is not currently used
            </summary>
        </member>
        <member name="F:Engine.Direction.up">
            <summary>
            Up
            </summary>
        </member>
        <member name="F:Engine.Direction.down">
            <summary>
            down
            </summary>
        </member>
        <member name="F:Engine.Direction.left">
            <summary>
            left
            </summary>
        </member>
        <member name="F:Engine.Direction.right">
            <summary>
            right
            </summary>
        </member>
        <member name="F:Engine.Direction.upRight">
            <summary>
            up and right
            </summary>
        </member>
        <member name="F:Engine.Direction.downRight">
            <summary>
            down and right
            </summary>
        </member>
        <member name="F:Engine.Direction.upLeft">
            <summary>
            up and left
            </summary>
        </member>
        <member name="F:Engine.Direction.downLeft">
            <summary>
            down and left
            </summary>
        </member>
        <member name="T:Engine.EnergyBarDirection">
            <summary>
            specifies which way to create an energy bar and when is aligned and full
            </summary>
            <remarks>Energy are sprite images that have all the frames calculated so that
            as you animate them more of the full image is shown. This can be used to show how full
            a bottle is, or make simple shutter effects</remarks>
        </member>
        <member name="F:Engine.EnergyBarDirection.SlideLeftAppear">
            <summary>
            Start with a sprite not visible then slide into view moving left. Use right alignment for best effect
            </summary>
        </member>
        <member name="F:Engine.EnergyBarDirection.SlideRightDissapear">
            <summary>
            Start with a sprite visible then slide out of  view moving right. Use right alignment for best effect
            </summary>
        </member>
        <member name="F:Engine.EnergyBarDirection.SlideRightAppear">
            <summary>
            Start with a sprite not visible then slide into view moving right. Use left alignment for best effect
            </summary>
        </member>
        <member name="F:Engine.EnergyBarDirection.SlideLeftDissapear">
            <summary>
            Start with a sprite visible then slide out of view moving left. Use left alignment for best effect
            </summary>
        </member>
        <member name="F:Engine.EnergyBarDirection.SlideUpAppear">
            <summary>
            Start with a sprite not visible then slide into view moving up. Use bottom alignment for best effect
            </summary>
        </member>
        <member name="F:Engine.EnergyBarDirection.SlideDownDissapear">
            <summary>
            Start with a sprite visible then slide out of view moving down. Use bottom alignment for best effect
            </summary>
        </member>
        <member name="F:Engine.EnergyBarDirection.SlideDownAppear">
            <summary>
            Start with a sprite not visible then slide into view moving down. Use top alignment for best effect
            </summary>
        </member>
        <member name="F:Engine.EnergyBarDirection.SlideUpDissapear">
            <summary>
            Start with a sprite visible then slide out of view moving up. Use top alignment for best effect
            </summary>
        </member>
        <member name="T:Engine.SlideMethod">
            <summary>
            Specifies how a sprite should be sliced up when using DefineSlidingFrames()
            </summary>
        </member>
        <member name="F:Engine.SlideMethod.SlideLeftAppear">
            <summary>
            Start with a sprite not visible then slide into view moving left. Use right alignment for best effect
            </summary>
        </member>
        <member name="F:Engine.SlideMethod.SlideRightDissapear">
            <summary>
            Start with a sprite visible then slide out of  view moving right. Use right alignment for best effect
            </summary>
        </member>
        <member name="F:Engine.SlideMethod.SlideRightAppear">
            <summary>
            Start with a sprite not visible then slide into view moving right. Use left alignment for best effect
            </summary>
        </member>
        <member name="F:Engine.SlideMethod.SlideLeftDissapear">
            <summary>
            Start with a sprite visible then slide out of view moving left. Use left alignment for best effect
            </summary>
        </member>
        <member name="F:Engine.SlideMethod.SlideUpAppear">
            <summary>
            Start with a sprite not visible then slide into view moving up. Use bottom alignment for best effect
            </summary>
        </member>
        <member name="F:Engine.SlideMethod.SlideDownDissapear">
            <summary>
            Start with a sprite visible then slide out of view moving down. Use bottom alignment for best effect
            </summary>
        </member>
        <member name="F:Engine.SlideMethod.SlideDownAppear">
            <summary>
            Start with a sprite not visible then slide into view moving down. Use top alignment for best effect
            </summary>
        </member>
        <member name="F:Engine.SlideMethod.SlideUpDissapear">
            <summary>
            Start with a sprite visible then slide out of view moving up. Use top alignment for best effect
            </summary>
        </member>
        <member name="T:Engine.SpriteStatus">
            <summary>
            
            </summary>
        </member>
        <member name="T:Engine.PassThroughEvent">
            <summary>
            a special event that when triggered can call another method and pass on
            a given object, this can be any type of object
            the method given as callme will need to cast the object to the correct type to use it
            </summary>
        </member>
        <member name="F:Engine.PassThroughEvent.callee">
            <summary>
            storage for the method to call when event triggers
            </summary>
        </member>
        <member name="F:Engine.PassThroughEvent.data">
            <summary>
            data to pass on to callee
            </summary>
        </member>
        <member name="M:Engine.PassThroughEvent.#ctor(System.Single,System.Object,System.Action{System.Object,Engine.Event})">
            <summary>
            Creates a special event that when triggered will pass an object onto the specified method
            </summary>
            <param name="delay">initial delay before calling pass through</param>
            <param name="data">data to send on when elapsed</param>
            <param name="callme">method to pass the data object to, which accepts an object parameter which then needs casting to the correct type</param>
        </member>
        <member name="M:Engine.PassThroughEvent.Handler">
            <summary>
            sends the object data and a reference to the event (for removal) onto to its final destination can be overriden
            </summary>
        </member>
        <member name="T:Engine.Event">
            <summary>
            Defines either a timer or event
            </summary>
        </member>
        <member name="F:Engine.Event._tickHandler">
            <summary>
            storage for the tick delegates address
            </summary>
        </member>
        <member name="P:Engine.Event.TickHandler">
            <summary>
            name of void subroutine (which accepts an Event parameter) to call when time elapses
            </summary>
        </member>
        <member name="F:Engine.Event.OnKilled">
            <summary>
            holds a delegate to run when the event is killed by the Event Manager must accept an Event parameter
            </summary>
        </member>
        <member name="F:Engine.Event._timeSoFar">
            <summary>
            holds the current elapsed timer for this period
            </summary>
        </member>
        <member name="F:Engine.Event.totalTimeElapsed">
            <summary>
            total time the event has been active
            </summary>
        </member>
        <member name="F:Engine.Event.timeToLive">
            <summary>
            if the totalTimeElapsed is greater than this value then the Event will be released
            </summary>
        </member>
        <member name="F:Engine.Event.raiseOnce">
            <summary>
            states that the event should be removed once elapsed
            </summary>
        </member>
        <member name="F:Engine.Event.Interval">
            <summary>
            holds the period of the timer/event in seconds
            </summary>
        </member>
        <member name="F:Engine.Event._initialise">
            <summary>
            states whether timer/event should be initialised during next eventmanager update
            </summary>
        </member>
        <member name="F:Engine.Event._elapsed">
            <summary>
            states whether the timer/event has elapsed
            </summary>
        </member>
        <member name="F:Engine.Event.Paused">
            <summary>
            states whether the timer/event is paused
            </summary>
        </member>
        <member name="F:Engine.Event.Active">
            <summary>
            States whether this event is currently being managed
            </summary>
        </member>
        <member name="F:Engine.Event.AutoReset">
            <summary>
            determines if event manager should reset timer once elapsed
            This will be the action you want for things like key delay timers
            but sometimes you will want to keep testing to see if a timer has still 
            elapsed so you would not want it reset
            </summary>
        </member>
        <member name="F:Engine.Event.Ticks">
            <summary>
            number of times the event has elapsed (happened)
            </summary>
        </member>
        <member name="P:Engine.Event.TimeRemaining">
            <summary>
            time remaing before event is removed from EventManager
            </summary>
            <remarks>Only makes sense for event that have time limits and are active.
            Really this is for debugging purposes</remarks>
        </member>
        <member name="F:Engine.Event._killMePlease">
            <summary>
            identifies events and timers scheduled for removal
            </summary>
        </member>
        <member name="P:Engine.Event.TimeToRemove">
            <summary>
            gets a value (true or false) stating whether this timer should be removed
            </summary>
        </member>
        <member name="M:Engine.Event.KillMe">
            <summary>
            sets the timer/event to be remove next update
            </summary>
        </member>
        <member name="F:Engine.Event.Name">
            <summary>
            An name used for display purposes only
            </summary>
        </member>
        <member name="F:Engine.Event.Counter">
            <summary>
            holds an internal counter for generating a name for unamed events or timers
            </summary>
        </member>
        <member name="M:Engine.Event.#ctor(System.Single,System.String)">
            <summary>
            creates a manually monitored EventTimer
            </summary>
            <param name="displayName">The name of the event</param>
            <param name="seconds">interval of eventtimer in seconds</param>
        </member>
        <member name="M:Engine.Event.#ctor(System.Single,System.String,Engine.EventHandler)">
            <summary>
            Creates an event and its handler 
            </summary>
            <param name="seconds">interval of eventtimer in seconds</param>
            <param name="displayName">The name of the event</param>
            <param name="tickHandler">The Event subroutine to run when the timer expires</param>
        </member>
        <member name="M:Engine.Event.#ctor(Engine.EventHandler)">
            <summary>
            Creates a event running at the event managers maximum update rate
            </summary>
            <param name="tickHandler"></param>
        </member>
        <member name="M:Engine.Event.CheckTime(System.Single,System.Boolean)">
            <summary>
            Looks at the eventtimer and if it has elapsed sets elapsed to true
            If a handler exists it is called and the timer is reset
            </summary>
            <param name="period">timer passed since last check</param>
            <param name="reset">A value that can ensure a timer is reset automatically</param>
            <remarks>Called by the EventManager so don't use directly</remarks>
            <returns>the elapsed state of the timer true if elapsed, false if not</returns>
        </member>
        <member name="M:Engine.Event.Initialise">
            <summary>
            initialises the timer
            </summary>
        </member>
        <member name="M:Engine.Event.Reset(System.Single)">
            <summary>
            Resets the eventtimer for next use
            </summary>
        </member>
        <member name="P:Engine.Event.ElapsedSoFar">
            <summary>
            Gets the current elapsed time for a timer
            </summary>
        </member>
        <member name="P:Engine.Event.Elapsed">
            <summary>
            gets the status of the eventtimer
            </summary>
        </member>
        <member name="P:Engine.Event.ReadyToInitialise">
            <summary>
            gets true if this eventtimer needs initialising
            </summary>
        </member>
        <member name="P:Engine.Event.HandlerName">
            <summary>
            NOT NEEDED YET gets the name of the handler if it exists for this timer
            </summary>
        </member>
        <member name="T:Engine.EventManager">
            http://msdn.microsoft.com/en-us/library/system.diagnostics.stopwatch.aspx
            look at this for high resolution timer hopefully to allow this to run better
             <summary>
             This class is in charge of timers and event management and also in charge of update and draw timing
             </summary>
        </member>
        <member name="F:Engine.EventManager.period">
            <summary>
            holds the current period for the event managers timing update
            </summary>
        </member>
        <member name="P:Engine.EventManager.Delta">
            <summary>
            fraction of time during the current update
            </summary>
        </member>
        <member name="F:Engine.EventManager.fps">
            <summary>
            The number of frames drawn during the last second
            </summary>
        </member>
        <member name="P:Engine.EventManager.GameFPS">
            <summary>
            gets number of frames drawn during the last second
            </summary>
        </member>
        <member name="M:Engine.EventManager.AddTimer(Engine.Event)">
            <summary>
            Adds a new timer to monitor which will be manually checked for time up
            </summary>
            <param name="eventDefinition">An TimerData defintion containing the timer details</param>
            <returns>-1 if failed to build timer and 1 if successful</returns>
        </member>
        <member name="M:Engine.EventManager.AddEvent(Engine.Event)">
            <summary>
            Adds a new timer to monitor
            </summary>
            <param name="eventDefinition">An event details definition that contains the information for the event</param>
            <returns>-1 if failed to build timer and 1 if successful</returns>
        </member>
        <member name="M:Engine.EventManager.AddEventRaiseOnce(Engine.Event)">
            <summary>
            Adds a new event to monitor which will call a supplied method when it expires but only once
            </summary>
            <param name="eventDefinition">An event details definition that contains the information for the event
            to occur</param>
        </member>
        <member name="P:Engine.EventManager.ResetDuplicate">
            <summary>
            if true a duplicate event will be reset if it already exists - only used by AddEventRaiseOnce
            </summary>
        </member>
        <member name="M:Engine.EventManager.DelayCall(System.Single,Engine.EventHandler)">
            <summary>
            A quick way of launching a subroutine after a specified amount of time
            </summary>
            <param name="delayTime">time before calling subroutine</param>
            <param name="subroutineToCall">subroutine to call after time is over</param>
            <returns>a reference to the event if you was to intercept and cancel</returns>
        </member>
        <member name="M:Engine.EventManager.DelayCallResetDuplicate(System.Single,Engine.EventHandler)">
            <summary>
            A quick way of launching a subroutine after a specified amount of time, will reset existing event if it already exists
            </summary>
            <param name="delayTime">time before calling subroutine</param>
            <param name="subroutineToCall">subroutine to call after time is over</param>
        </member>
        <member name="M:Engine.EventManager.AddEventRaiseUntil(Engine.Event,System.Single)">
            <summary>
            Adds an event that will run for so many seconds before it is then killed off
            </summary>
            <param name="eventDefinition">An event details definition that contains the information for the event</param>
            <param name="timeToLive">The number of seconds this event should keep running</param>
        </member>
        <member name="M:Engine.EventManager.ResetAll">
            <summary>
            resets all active events
            </summary>
        </member>
        <member name="M:Engine.EventManager.Reset(Engine.Event)">
            <summary>
            Resets the given timerData object
            </summary>
            <param name="eventDefinition">The event or timer object to reset</param>
        </member>
        <member name="M:Engine.EventManager.Reset(System.String)">
            <summary>
            attempts to reset the named event or timer object
            </summary>
            <param name="debugName">The event or timer name to reset</param>
        </member>
        <member name="M:Engine.EventManager.PauseAllBut(System.Collections.Generic.List{Engine.Event})">
            <summary>
            Pauses all events except those given in the list
            </summary>
            <param name="leaveThese">list of events to not pause</param>
        </member>
        <member name="M:Engine.EventManager.PauseAllBut(System.Collections.Generic.List{System.String})">
            <summary>
            Pauses all events except those with the names given in the list
            </summary>
            <param name="leaveThese">list of event names to not pause</param>
        </member>
        <member name="M:Engine.EventManager.PauseAll">
            <summary>
            pauses all current events
            </summary>
        </member>
        <member name="M:Engine.EventManager.Pause(Engine.Event)">
            <summary>
            pauses the specific event
            </summary>
            <param name="eventDefinition">The event object to pause</param>
        </member>
        <member name="M:Engine.EventManager.Pause(System.String)">
            <summary>
            pauses the specific event
            </summary>
            <param name="debugName">The given name of the event/timer to pause</param>
        </member>
        <member name="M:Engine.EventManager.GetActiveEvent(System.String)">
            <summary>
            gets an active dynamically created event (those that are created when a call is made to EventManager.Add)
            This allows you to obtain a reference to an event so its properties can be examined
            </summary>
            <param name="debugName">The name given when the event was created</param>
            <returns>The named event if found and null if it does not exist</returns>
        </member>
        <member name="M:Engine.EventManager.ResumeAll">
            <summary>
            Restarts all paused event timers.
            </summary>
            <remarks>They will probably need resetting first</remarks>
        </member>
        <member name="M:Engine.EventManager.Resume(Engine.Event)">
            <summary>
            Restarts the given event timer
            </summary>
            <param name="eventDefinition">The event or timer to reset</param>
            <remarks>Make sure you reset the timer before unpausing it</remarks>
        </member>
        <member name="M:Engine.EventManager.Resume(System.String)">
            <summary>
            Restarts the given event timer
            </summary>
            <param name="debugName">The given name of the event/timer to resume</param>
        </member>
        <member name="M:Engine.EventManager.Elapsed(Engine.Event)">
            <summary>
            Check to see if the given event has elapsed
            </summary>
            <param name="eventDefinition">the event to check</param>
            <returns>True if elapsed, false if not</returns>
        </member>
        <member name="M:Engine.EventManager.Elapsed(System.String)">
            <summary>
            Check to see if the given event has elapsed
            </summary>
            <param name="debugName">the event/timer debugname to check</param>
            <returns>True if elapsed, false if not</returns>
        </member>
        <member name="M:Engine.EventManager.Remove(Engine.Event)">
            <summary>
            Removes the given timer/event from the list
            </summary>
            <param name="eventDefinition">The event or timer object to reset</param>
        </member>
        <member name="M:Engine.EventManager.Remove(System.String)">
            <summary>
            attempts to remove an event with the given name, handy for dynamically created events
            </summary>
            <param name="debugName">The degbug name you assigned to the event when it was created</param>
        </member>
        <member name="M:Engine.EventManager.RemoveAllBut(System.Collections.Generic.List{System.String})">
            <summary>
            removes all events except those that have the given debug names specified in string array
            </summary>
            <param name="keepThese">an array of debug names to keep active</param>
        </member>
        <member name="M:Engine.EventManager.RemoveAllBut(System.Collections.Generic.List{Engine.Event})">
            <summary>
            removes all events except those specified in event array
            </summary>
            <param name="keepThese">an array of Event objects to keep active</param>
        </member>
        <member name="M:Engine.EventManager.RemoveAll">
            <summary>
            Bins all events no handlers are called
            </summary>
        </member>
        <member name="M:Engine.EventManager.GetEventTimer(Engine.Event)">
            <summary>
            searches for given event using the object
            </summary>
            <param name="eventDefinition">the EventTimer object</param>
            <returns>the index of the eventtimer</returns>
        </member>
        <member name="M:Engine.EventManager.GetEventTimer(System.String)">
            <summary>
            attempts to locate and event given its debug name
            </summary>
            <param name="debugName">the debugname to search for</param>
            <returns></returns>
        </member>
        <member name="M:Engine.EventManager.Exists(Engine.Event)">
            <summary>
            Determines if the given timer currently exists
            </summary>
            <param name="eventDefinition">The TimerData you wish to look for</param>
            <returns>True means the timer exists, false means it doesn't</returns>
        </member>
        <member name="M:Engine.EventManager.Exists(System.String)">
            <summary>
            Determines if the given timer currently exists
            </summary>
            <param name="debugName">the event/timer debugname to check</param>
            <returns>True means the timer exists, false means it doesn't</returns>
        </member>
        <member name="P:Engine.EventManager.TimerList">
            <summary>
            gets a list of type string containing all known timers
            </summary>
            <returns>A List of String which can be processed using a For loop</returns>
            <remarks>If there are no timers then the the Count property will be 0</remarks>
        </member>
        <member name="M:Engine.EventManager.TimerStringReturn(System.String)">
            <summary>
            Returns a string containing all known timers
            </summary>
            <returns>A string containing all the timers separated by a comma</returns>
            <remarks>This can be quite useful for displaying using DrawText (use a resonable small font scale 0.15f or 0.2f) if
            you have quite a few timers and can help you see quickly whether timers exist</remarks>
        </member>
        <member name="M:Engine.EventManager.TimerStringReturnElapsed(System.String)">
            <summary>
            Returns a string containing all known timers and their current time state
            </summary>
            <returns>A string containing all the timers separated by a comma</returns>
            <remarks>This can be quite useful for displaying using DrawText (use a resonable small font scale 0.15f or 0.2f) if
            you have quite a few timers and can help you see quickly whether timers exist</remarks>
        </member>
        <member name="M:Engine.EventManager.TimerStringReturnElapsedInterval(System.String)">
            <summary>
            Returns a string containing all known timers and their current time state andinterval
            </summary>
            <returns>A string containing all the timers separated by a comma</returns>
            <remarks>This can be quite useful for displaying using DrawText (use a resonable small font scale 0.15f or 0.2f) if
            you have quite a few timers and can help you see quickly whether timers exist</remarks>
        </member>
        <member name="P:Engine.EventManager.TimerStringLines">
            <summary>
            gets a string containing all known timers
            </summary>
            <returns>Returns a string containing all known timers presented on a separate line</returns>
        </member>
        <member name="P:Engine.EventManager.TimerStringLinesElapsed">
            <summary>
            gets a string containing all known timers and their current elapsed time (to 3 decimal places)
            </summary>
            <returns>Returns a string containing all known timers presented on a separate line</returns>
        </member>
        <member name="P:Engine.EventManager.TimerStringLinesElapsedInterval">
            <summary>
            gets a string containing all known timers their interval and current elapsed time (to 3 decimal places)
            </summary>
            <returns>Returns a string containing all known timers presented on a separate line</returns>
        </member>
        <member name="P:Engine.EventManager.TimerString">
            <summary>
            gets a string containing all known timers
            </summary>
            <returns>A string containing all the timers separated by a comma</returns>
        </member>
        <member name="M:Engine.EventManager.ToString">
            <summary>
            gets a string containing all known timers, separated by a space
            </summary>
            <returns></returns>
        </member>
        <member name="M:Engine.EventManager.GetNextName">
            <summary>
            returns a new unique timer name
            </summary>
            <returns></returns>
        </member>
        <member name="M:Engine.EventManager.#ctor(Microsoft.Xna.Framework.Game)">
            <summary>
            Creates the event manager syncing rendering to the screen refresh rate
            and at the default of 120Hz for the update logic
            </summary>
            <param name="game">The game object</param>
        </member>
        <member name="M:Engine.EventManager.#ctor(Microsoft.Xna.Framework.Game,System.Single,System.Boolean)">
            <summary>
            Creates the event manager specifying the frame rate and draw sync type
            </summary>
            <param name="game">the game object</param>
            <param name="desiredUpdateRate">target engine update rate - set to -1 to run unthrottled</param>
            <param name="syncToRetrace">true will sync drawing to refresh rate of monitor,
            set to false if wanting to run as fast as updateRate (if possible)</param>
        </member>
        <member name="M:Engine.EventManager.Draw(Microsoft.Xna.Framework.GameTime)">
            <summary>
            calculate number of frames rendered
            </summary>
            <param name="gameTime"></param>
        </member>
        <member name="F:Engine.EventManager.elapsedUpdateTimeSoFar">
            <summary>
            holds the fractional number of seconds that have occured during this second of updates
            </summary>
        </member>
        <member name="F:Engine.EventManager.updates">
            <summary>
            holds the number of updates that occured so far during the current second
            </summary>
        </member>
        <member name="F:Engine.EventManager.gameUpdates">
            <summary>
            holds the last number of updates performed during the last second
            </summary>
        </member>
        <member name="P:Engine.EventManager.GameUpdates">
            <summary>
            gets the number of game logic updates that occured during the last second
            </summary>
        </member>
        <member name="M:Engine.EventManager.Update(Microsoft.Xna.Framework.GameTime)">
            <summary>
            updates the internal state of all managed timers
            </summary>
            <param name="gameTime"></param>
        </member>
        <member name="P:Engine.EventManager.MaximumRate">
            <summary>
            returns a value for maximum rate of event processing (based on update rate of engine).
            This is useful for setting events that need to check player input.
            </summary>
        </member>
        <member name="M:Engine.EventManager.DrawFPS">
            <summary>
            Displays FPS in title window
            </summary>
        </member>
        <member name="P:Engine.EventManager.UpdateText">
            <summary>
            gets a piece of text containing update and frame rate data
            </summary>
        </member>
        <member name="T:Engine.Ifader">
            <summary>
            an interface for a class that accepts a floating point fade value generated by the Fader class
            </summary>
        </member>
        <member name="P:Engine.Ifader.AcceptFadeValue">
            <summary>
            accepts a floating point value between 0 and 1
            </summary>
        </member>
        <member name="T:Engine.Fader">
            <summary>
            creates a Fader object that will morph a value between 0 and 1 (either descending or ascending)
            </summary>
        </member>
        <member name="T:Engine.Fader.Direction">
            <summary>
            specifies whether something is fading in or out
            </summary>
        </member>
        <member name="F:Engine.Fader.Direction.fadeup">
            <summary>
            increases value from 0 to 1
            </summary>
        </member>
        <member name="F:Engine.Fader.Direction.fadedown">
            <summary>
            decreases value from 1 to 0
            </summary>
        </member>
        <member name="F:Engine.Fader.upper">
            <summary>
            holds upper stop or clamp value
            </summary>
        </member>
        <member name="F:Engine.Fader.lower">
            <summary>
            holds lower stop or clamp value
            </summary>
        </member>
        <member name="F:Engine.Fader.dFade">
            <summary>
            the change to apply to the alpha value
            </summary>
        </member>
        <member name="F:Engine.Fader.currentValue">
            <summary>
            the current value for the alpha
            </summary>
        </member>
        <member name="F:Engine.Fader.evFade">
            <summary>
            the event managing the change in alpha
            </summary>
        </member>
        <member name="F:Engine.Fader.faderHost">
            <summary>
            holds the object reference to the Ifader implementator
            </summary>
        </member>
        <member name="F:Engine.Fader.myEventManagerRef">
            <summary>
            my ref to the event manager
            </summary>
        </member>
        <member name="M:Engine.Fader.#ctor(Engine.Ifader,System.Single,Engine.Fader.Direction,Engine.EventManager,System.Single,System.Single)">
            <summary>
            constructor to generate the value changer, which stops when we reach the limit
            </summary>
            <param name="fadeobject">object that implements the Ifader interface ready to accept fade values</param>
            <param name="fadeTime">the time in seconds to fade between the lower and upper limit</param>
            <param name="direction">fade in or out</param>
            <param name="eventManager">A reference to the event manager</param>
            <param name="lowerlimit">The lower limit for the fade range</param>
            <param name="upperlimit">The upper limit for the fade range</param>
        </member>
        <member name="M:Engine.Fader.#ctor(Engine.Ifader,System.Single,Engine.Fader.Direction,Engine.EventManager)">
            <summary>
            constructor to generate the value changer, which stops at the limits of 0 or 1
            </summary>
            <param name="fadeobject">object that implements the Ifader interface ready to accept fade values</param>
            <param name="fadeTime">the time to fade between 0 and 1</param>
            <param name="direction">fade in or out</param>
            <param name="eventManager">A reference to the event manager</param>
        </member>
        <member name="M:Engine.Fader.ValueChange">
            <summary>
            performs the change in the alpha value
            </summary>
        </member>
        <member name="M:Engine.Fader.Remove">
            <summary>
            removes the fader when finished with
            </summary>
        </member>
        <member name="T:Engine.FontBank">
            <summary>
            stores font definitions for use with the engines sprite text system.
            This is not the xna SpriteFont system - if you want to use that you'll need to create
            your own drawing system
            </summary>
        </member>
        <member name="F:Engine.FontBank.digi">
            <summary>
            digits string
            </summary>
        </member>
        <member name="F:Engine.FontBank.ALPHA">
            <summary>
            uppercase alphabetic characters
            </summary>
        </member>
        <member name="F:Engine.FontBank.alpha">
            <summary>
            lowercase alphabetic characters
            </summary>
        </member>
        <member name="F:Engine.FontBank.fontTex">
            <summary>
            The texture for the fonts
            </summary>
        </member>
        <member name="F:Engine.FontBank.vector">
            <summary>
            A vector graphic styled font as used on asteroids, Tempest, Starwars etc...
            </summary>
        </member>
        <member name="F:Engine.FontBank.arcadeLarge">
            <summary>
            Classic arcade font as used on early 80's machines, upper and lowercase the same
            </summary>
        </member>
        <member name="P:Engine.FontBank.Arcade">
            <summary>
            use arcadeLarge in preference to this (it's the same thing)
            </summary>
        </member>
        <member name="F:Engine.FontBank.arcadePixel">
            <summary>
            classic arcade font as used on early 80's machines, this uses one to one pixel ratio, so all characters are 8 pixels high
            </summary>
        </member>
        <member name="F:Engine.FontBank.gradius">
            <summary>
            gradius from Konami
            </summary>
        </member>
        <member name="F:Engine.FontBank.silkworm">
            <summary>
            Font used on the arcade game Silkworm by Tecmo
            </summary>
        </member>
        <member name="F:Engine.FontBank.digit">
            <summary>
            just a series of digits (don't know why made it private)
            </summary>
        </member>
        <member name="F:Engine.FontBank.intellivision">
            <summary>
            Font based on the classic Mattel 80's game console
            </summary>
        </member>
        <member name="F:Engine.FontBank.autobahn">
            <summary>
            Futuristic black letter font
            </summary>
        </member>
        <member name="F:Engine.FontBank.asimov">
            <summary>
            Font styled after fonts used on covers of Issac Asimov books
            </summary>
        </member>
        <member name="F:Engine.FontBank.year1943">
            <summary>
            Font used by Capcom games such as Gun.smoke and 1943 etc...
            </summary>
        </member>
        <member name="F:Engine.FontBank.mappy">
            <summary>
            Font based on the one used in the Mappy sequel Hopping mappy
            </summary>
        </member>
        <member name="F:Engine.FontBank.imagic">
            <summary>
            Font based on the font designed by ex-Atari employees
            who created superbly technical and awesome Atari 2600 VCS games
            one of my favourite old school games designers
            </summary>
        </member>
        <member name="F:Engine.FontBank.robotron">
            <summary>
            The font used on Williams unbeatable classic (often cloned)
            shoot-em up Robotron
            </summary>
        </member>
        <member name="F:Engine.FontBank.coward">
            <summary>
            Spooky looking font
            </summary>
        </member>
        <member name="F:Engine.FontBank.atarianBold">
            <summary>
            Atari font in a bold style
            </summary>
        </member>
        <member name="F:Engine.FontBank.atarian">
            <summary>
            Atari font in normal style
            </summary>
        </member>
        <member name="F:Engine.FontBank.byte256">
            <summary>
            Fantastic retro sci-fi font (70's) seen in many films and TV
            shows of the time (such as tv show Space 1999 and the film Silent running)
            </summary>
        </member>
        <member name="M:Engine.FontBank.CreateFonts(Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            sets up any sprite fonts you wish to use
            </summary>
        </member>
        <member name="M:Engine.FontBank.Asimov">
            <summary>
            Define using arcadeFont a simple character set
            this must be the first texture in the TextureBank as it is used by the 
            debugging output
            </summary>
        </member>
        <member name="M:Engine.FontBank.ArcadeLarge">
            <summary>
            Define using arcadeFont a simple character set
            this must be the first texture in the TextureBank as it is used by the 
            debugging output, lowercase same as uppercase
            </summary>
        </member>
        <member name="M:Engine.FontBank.AutoBahnFont">
            <summary>
            Defines the AutoBahnFont
            </summary>
        </member>
        <member name="M:Engine.FontBank.IntellivisionFont">
            <summary>
            Definesthe Intellivision font
            </summary>
        </member>
        <member name="M:Engine.FontBank.SilkwormFont">
            <summary>
            Define using arcadeFont a simple character set
            this must be the first texture in the TextureBank as it is used by the 
            debugging output
            </summary>
        </member>
        <member name="M:Engine.FontBank.CreateTerminal(Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            create a monospaced font by default
            </summary>
            <param name="txSystemFont"></param>
            <returns></returns>
        </member>
        <member name="M:Engine.FontBank.CreateSystemFont(Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            Creates the internal system font
            </summary>
            <returns></returns>
        </member>
        <member name="T:Engine.FontSprite">
            <summary>
            Defines a fontsprite for use with text rendering
            </summary>
        </member>
        <member name="P:Engine.FontSprite.CharSet">
            <summary>
            gets or sets the character set of the font
            </summary>
        </member>
        <member name="P:Engine.FontSprite.Height">
            <summary>
            specifies the highest character
            </summary>
        </member>
        <member name="P:Engine.FontSprite.LowerCase">
            <summary>
            specifies if font contains lower case characters
            </summary>
        </member>
        <member name="P:Engine.FontSprite.UpperCase">
            <summary>
            specifies if font contains upper case characters
            </summary>
        </member>
        <member name="P:Engine.FontSprite.Proportionate">
            <summary>
            specifies whether font should be render proportionate or monospaced
            </summary>
        </member>
        <member name="P:Engine.FontSprite.Monospace">
            <summary>
            specifies whether a font should be rendered using fixed width character spacing
            if true then the WidestChar value will be used for spacing. WidestChar can be adjusted to effect the results
            </summary>
        </member>
        <member name="P:Engine.FontSprite.WidestChar">
            <summary>
            specifies the widest character for monospace rendering, this can be modified along with kerning values to
            get the required results when monospacing a proportional font
            </summary>
        </member>
        <member name="F:Engine.FontSprite.widestCharacter">
            <summary>
            set when Character set is first defined
            used to reset width when it's been messed about with
            </summary>
        </member>
        <member name="M:Engine.FontSprite.ResetMonoSpacedWidth">
            <summary>
            restores mono space width to it's default
            </summary>
        </member>
        <member name="F:Engine.FontSprite.monospace">
            <summary>
            used to determine whether font is to be rendered using proportial or mono spacing
            </summary>
        </member>
        <member name="M:Engine.FontSprite.#ctor(System.String,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Defines a new FontSprite
            </summary>
            <param name="charSet"></param>
            <param name="height"></param>
            <param name="lowerCase"></param>
            <param name="upperCase"></param>
            <param name="proportionate"></param>
        </member>
        <member name="M:Engine.FontSprite.CharacterFrameNumber(System.String)">
            <summary>
            Returns the frame number of the FontSprite required to render this given character 
            </summary>
            <param name="character">A character in the character set of the font</param>
            <returns>the frame index for this character</returns>
        </member>
        <member name="M:Engine.FontSprite.CharacterFrameNumber(System.Char)">
            <summary>
            Returns the frame number of the FontSprite required to render this given character 
            </summary>
            <param name="character">A character in the character set of the font</param>
            <returns>the frame index for this character</returns>
        </member>
        <member name="P:Engine.FontSprite.CurrentCharacterHeight">
            <summary>
            Gets the Height of the Font
            </summary>
            <remarks>Assumes that all the font characters are the same height</remarks>
        </member>
        <member name="P:Engine.FontSprite.CurrentCharacterWidth">
            <summary>
            gets the width of the current character
            </summary>
        </member>
        <member name="M:Engine.FontSprite.CharacterFrameSize(System.String)">
            <summary>
            returns the rectangle (raw) used on the texture of the specific character in this font
            </summary>
            <param name="character">The character to look up from the font</param>
            <returns>The rectangle used to define the character</returns>
        </member>
        <member name="M:Engine.FontSprite.CharacterFrameWidth(System.String)">
            <summary>
            returns the width in pixels of the specific character in this font
            </summary>
            <param name="character">The character to look up from the font</param>
            <returns>The width in pixels of the character</returns>
        </member>
        <member name="M:Engine.FontSprite.CharacterFrameWidth(System.Char)">
            <summary>
            returns the width in pixels of the specific character in this font
            </summary>
            <param name="character">The character to look up from the font</param>
            <returns>The width in pixels of the character</returns>
        </member>
        <member name="P:Engine.FontSprite.Name">
            <summary>
            gets or sets the general name of the font
            </summary>
        </member>
        <member name="T:Engine.GravityWell">
            <summary>
            Defines a gravity well that can act upon a sprite if associated
            </summary>
        </member>
        <member name="F:Engine.GravityWell.Location">
            <summary>
            The position of this gravity well
            </summary>
        </member>
        <member name="F:Engine.GravityWell._PointMass">
            <summary>
            The mass of this gravity well in GigaTonnes (this diminishes over distance in a linear way
            </summary>
            <remarks>I will improve the simulation of these in future versions</remarks>
        </member>
        <member name="F:Engine.GravityWell.GM">
            <summary>
            gravitational constant
            </summary>
        </member>
        <member name="F:Engine.GravityWell.preCalc">
            <summary>
            pre calculated value
            </summary>
        </member>
        <member name="M:Engine.GravityWell.#ctor(Microsoft.Xna.Framework.Vector3,System.Single)">
            <summary>
            Creates a new GravityWell specifying its location and Mass in Giga Tonnes
            </summary>
            <param name="location">The location of the well</param>
            <param name="gigaTonnes">The mass of the gravity from this location in Giga Tonnes
            (billions of Kilograms), the higher the Mass the harder the pull</param>
            <remarks>You will need to experiment with the location and Mass of the 
            GravityWells in order to achieve the desired effects</remarks>
        </member>
        <member name="P:Engine.GravityWell.PointMass">
            <summary>
            gets or sets the point mass for the well in GigaTonnes
            </summary>
        </member>
        <member name="T:Engine.HBMaths">
            <summary>
            A collection of maths helper functions
            mainly for items not available in compact framework
            </summary>
        </member>
        <member name="M:Engine.HBMaths.GetCWNormal(Microsoft.Xna.Framework.Vector2)">
            <summary>
            gets the normal to the direction vector in a clockwise (cw) direction (+90 degrees)
            </summary>
            <param name="direction">Vector to get normal of</param>
            <returns>CW normal</returns>
        </member>
        <member name="M:Engine.HBMaths.GetCCWNormal(Microsoft.Xna.Framework.Vector2)">
            <summary>
            gets the normal to the direction vector in an anti clockwise (ccw) direction (-90 degrees)
            </summary>
            <param name="direction">Vector to get normal of</param>
            <returns>CCW normal</returns>
        </member>
        <member name="M:Engine.HBMaths.GetCWNormal(Microsoft.Xna.Framework.Vector3)">
            <summary>
            gets the normal to the direction vector in a clockwise (cw) direction (+90 degrees)
            </summary>
            <param name="direction">Vector to get normal of</param>
            <returns>CW normal</returns>
        </member>
        <member name="M:Engine.HBMaths.GetCCWNormal(Microsoft.Xna.Framework.Vector3)">
            <summary>
            gets the normal to the direction vector in an anti clockwise (ccw) direction (-90 degrees)
            </summary>
            <param name="direction">Vector to get normal of</param>
            <returns>CCW normal</returns>
        </member>
        <member name="M:Engine.HBMaths.GenTRIG">
            <summary>
            Generates a lookup table for sine and cos
            </summary>
        </member>
        <member name="M:Engine.HBMaths.Sin(System.Single)">
            <summary>
            returns the lookup table version of angle given, in the range 0-359
            </summary>
            <param name="angle">in degrees</param>
            <returns>Sine of angle given</returns>
        </member>
        <member name="M:Engine.HBMaths.Cos(System.Int32)">
            <summary>
            returns the lookup table version of angle given
            </summary>
            <param name="angle">in degrees</param>
            <returns>Cosine of angle given</returns>
        </member>
        <member name="M:Engine.HBMaths.#ctor">
            <summary>
            constructor
            </summary>
        </member>
        <member name="M:Engine.HBMaths.DivRem(System.Int32,System.Int32)">
            <summary>
            produces a remainder for the integer division
            </summary>
            <param name="a">The numerator (the number to divide into)</param>
            <param name="b">The denominator (the number to divide by)</param>
            <returns>The remainder for the division</returns>
        </member>
        <member name="M:Engine.HBMaths.Mod(System.Int32,System.Int32)">
            <summary>
            NOT WRITTEN YET:Performs modulus arithmetic on the 2 integers supplied
            </summary>
            <param name="a">The number to perform the modulus on</param>
            <param name="b">the modulo number</param>
            <returns>the remainder</returns>
            <remarks>Works with negative values % doesn't for some reason</remarks>
        </member>
        <member name="T:Engine.HighScore">
            <summary>
            holds and manipulates high scores
            </summary>
        </member>
        <member name="T:Engine.HighScore.Column">
            <summary>
            defines an attribute of the highscore table
            (each represents a column of data)
            </summary>
        </member>
        <member name="F:Engine.HighScore.Column.Name">
            <summary>
            The name of the attribute
            </summary>
        </member>
        <member name="F:Engine.HighScore.Column.DataType">
            <summary>
            The data type represented by the attribute (integer, string etc...)
            </summary>
        </member>
        <member name="F:Engine.HighScore.Column.MaxLength">
            <summary>
            sets maximum length for the column based on example given
            </summary>
        </member>
        <member name="F:Engine.HighScore._scoreOrder">
            <summary>
            holds the sorting order for this highscore table
            defaults to highscore table
            </summary>
        </member>
        <member name="P:Engine.HighScore.ScoreOrder">
            <summary>
            gets or sets the order of the score table, by default this is set to HighScore so biggest
            value will appear at top, but if doing a quickest time based score system then you need to
            set this to a LowScore
            </summary>
        </member>
        <member name="F:Engine.HighScore._scoreTable">
            <summary>
            holds the highscore information
            </summary>
        </member>
        <member name="F:Engine.HighScore._attributes">
            <summary>
            Holds a list of the names of each attribute
            to make it easy to extract individual columns
            </summary>
        </member>
        <member name="F:Engine.HighScore._maxDigits">
            <summary>
            holds the maximum digits that can be displayed
            </summary>
        </member>
        <member name="F:Engine.HighScore._max">
            <summary>
            holds the maximum size of the score table
            </summary>
        </member>
        <member name="M:Engine.HighScore.#ctor">
            <summary>
            Creates a highscore table
            </summary>
        </member>
        <member name="M:Engine.HighScore.#ctor(Engine.scoreOrder)">
            <summary>
            Allows you to specify either a low score or high score table
            </summary>
            <param name="so">Specify either a low score or high score table</param>
        </member>
        <member name="M:Engine.HighScore.ClearTable">
            <summary>
            Generates an empty table
            Does not alter any attributes
            </summary>
        </member>
        <member name="P:Engine.HighScore.MaximumDigits">
            <summary>
            gets or sets the maximum number of digits to display for scores
            </summary>
        </member>
        <member name="M:Engine.HighScore.Top(System.Int32)">
            <summary>
            Gets the top entry for that particualr column
            you will need to cast the object to use it (string)Top(1) if this is the name
            </summary>
            <param name="column">column value to return</param>
            <returns>entry requested from the top of the table</returns>
        </member>
        <member name="M:Engine.HighScore.Bottom(System.Int32)">
            <summary>
            Gets the Bottom entry for that particualr column
            you will need to cast the object to use it (int)Bottom(0) if this is the score
            </summary>
            <param name="column">column value to return</param>
            <returns>entry requested from bottom of table</returns>
        </member>
        <member name="P:Engine.HighScore.TopScore">
            <summary>
            gets the top score from the score table, if your scores are bigger than 2 billion then use TopScoreLarge
            </summary>
            <value>Returns an int value representing the score or -1 if no scores exist</value>
        </member>
        <member name="P:Engine.HighScore.TopScoreLarge">
            <summary>
            gets the top score from the table in full 64bit integer format
            </summary>
        </member>
        <member name="P:Engine.HighScore.BottomScore">
            <summary>
            gets the bottom score from the score table, if your scores are bigger than 2 billion then use BottomScoreLarge
            </summary>
            <value>Returns an int value representing the score or -1 if no scores exist</value>
        </member>
        <member name="P:Engine.HighScore.BottomScoreLarge">
            <summary>
            gets the bottom score from the table in full 64bit integer format
            </summary>
        </member>
        <member name="P:Engine.HighScore.MaximumEntries">
            <summary>
            gets or sets the maximum number of entries in the table
            </summary>
        </member>
        <member name="P:Engine.HighScore.TableDetails">
            <summary>
            gets or sets the entire score table for manual processing and serialisation?
            </summary>
        </member>
        <member name="P:Engine.HighScore.ColumnDetails">
            <summary>
            gets or sets the Attribute list for manual processing 
            </summary>
        </member>
        <member name="P:Engine.HighScore.Entries">
            <summary>
            returns the number of entries in the table
            </summary>
        </member>
        <member name="P:Engine.HighScore.RowCount">
            <summary>
            returns the number of Rows entries in the table
            </summary>
        </member>
        <member name="P:Engine.HighScore.ColumnCount">
            <summary>
            gets the number of attributes defined for the score table
            </summary>
            <value>A number representing the number of columns available in the table</value>
        </member>
        <member name="M:Engine.HighScore.DefineColumn(System.String,System.Object)">
            <summary>
            defines an attribute for the higscores
            </summary>
            <param name="columnName">The name you wish to give this attribute (column of data)</param>
            <param name="exampleMaximum">An example of the maximum calue of the data that will be stored in this attribute</param>
            <remarks>The method needs an example of the data so it can record its base data type.
            This allows further methods to validate the score entries as they are given</remarks>
            <example>This example show you how to create a high score object
            and add an initial attribute to to it, assumes that an instance of HighScore
            has already been created and called highScoreTable in GameValues.
            <code>HighScore highScoreTable = new HighScoreTable();</code>
            Here is the example.
            <code>
                    /// &lt;summary&gt;
                    /// Attempt to load the highscores from the save file
                    /// or set defaults if it doesn't exist
                    /// &lt;/summary&gt;
                    public void DefineHighScore()
                    {
                            //set the default scores
                            //set attributes and maximum size
                            highScoreTable.MaximumEntries = 3;
                            //first attribute must be a score give a name and an example
                            highScoreTable.DefineColumn("score", 1000);
                            //the second attribute is called name, the example is HB
                            highScoreTable.DefineColumn("name", "H B");
            
                            // create an individual highscore entry
                            List&lt;Object&gt; scoreEntry = new List&lt;Object&gt;();
            
                            // add the highscore to the table
                            scoreEntry.Add(2000);
                            scoreEntry.Add("HB");
                            highScoreTable.AddScore(scoreEntry);
            
                            // add the next score entry
                            scoreEntry = new List&lt;Object&gt;();
                            scoreEntry.Add(1500);
                            scoreEntry.Add("ED");
                            highScoreTable.AddScore(scoreEntry);
            
                            // add the next score entry
                            scoreEntry = new List&lt;Object&gt;();
                            scoreEntry.Add(1000);
                            scoreEntry.Add("EZY");
                            highScoreTable.AddScore(scoreEntry);
                    }
            </code>
            </example>
        </member>
        <member name="M:Engine.HighScore.NameExist(System.String)">
            <summary>
            Checks attribute names to see if given name exists
            </summary>
            <param name="name">The attribute name we want to search for</param>
            <returns>True if found, false is blank or not found</returns>
        </member>
        <member name="M:Engine.HighScore.AddScore(System.Collections.Generic.List{System.Object})">
            <summary>
            adds a new score to the high score list
            </summary>
            <param name="newScore">A list of objects that make up the attributes for the score entry</param>
            <returns>the position score inserted into high score table if added successfully,
            -1 if an error occured or the position after the list one in the list, if the score wasn't high enough</returns>
            <remarks>If the </remarks>
            <example>This example show you how to create a high score object
            and add an initial attribute to to it
            <code>
                    /// &lt;summary&gt;
                    /// Attempt to load the highscores from the save file
                    /// or set defaults if it doesn't exist
                    /// &lt;/summary&gt;
                    public void DefineHighScore()
                    {
                            //set the default scores
                            //set attributes and maximum size
                            highScoreTable.MaximumEntries = 3;
                            //first attribute must be a score give a name and an example
                            highScoreTable.DefineColumn("score", 1000);
                            //the second attribute is called name, the example is HB
                            highScoreTable.DefineColumn("name", "H B");
            
                            // create an individual highscore entry
                            List&lt;Object&gt; scoreEntry = new List&lt;Object&gt;();
            
                            // add the highscore to the table
                            scoreEntry.Add(2000);
                            scoreEntry.Add("HB");
                            highScoreTable.AddScore(scoreEntry);
            
                            // add the next score entry
                            scoreEntry = new List&lt;Object&gt;();
                            scoreEntry.Add(1500);
                            scoreEntry.Add("ED");
                            highScoreTable.AddScore(scoreEntry);
            
                            // add the next score entry
                            scoreEntry = new List&lt;Object&gt;();
                            scoreEntry.Add(1000);
                            scoreEntry.Add("EZY");
                            highScoreTable.AddScore(scoreEntry);
                    }
            </code>
            </example>
        </member>
        <member name="M:Engine.HighScore.ScoreValid(System.Collections.Generic.List{System.Object})">
            <summary>
            Verifies whether a score meets the types specifed
            </summary>
            <param name="newScore">The score to be validated</param>
            <returns>True to say it is a valid score or false to say it doesn't match</returns>
        </member>
        <member name="M:Engine.HighScore.GetRowObject(System.Int32)">
            <summary>
            Gets a specific highscore entry from the table
            </summary>
            <param name="row">This position in the table we wish to extract scores from
            the position starts at 0 for the first one and so on</param>
            <returns>A list containing the attributes for the selected row in the score table</returns>
            <remarks>If no score appears at the position given the return object will be null
            this should be checked for</remarks>
        </member>
        <member name="M:Engine.HighScore.GetRowString(System.Int32,System.String)">
            <summary>
            Gets a specific highscore entry from the table
            </summary>
            <param name="row">This position in the table we wish to extract scores from
            the position starts at 0 for the first one and so on</param>
            <param name="delimiter">The string to place between attributes of the score</param>
            <returns>A string containing the attributes for the selected score separated by delimiter given.
            If row doesn't exist then ERROR will be returned in the string</returns>
            <remarks>If no score appears at the position given the return object will be null
            this should be checked for</remarks>
            <example>This example shows how to retrieve using GetEntryString and Count 
            the scores to display using DrawText. 
            You would need to place this code inside your DrawText subroutine
            <code>
            for (int i = 0; i &lt; highScoreTable.Count; i++)
                gameManager.DrawText("fontsheet", highScoreTable.RowReturnAsString(i, " - "),
                                                   300, 200 + i * 40, new TextProperty(0.6f, 1, Color.Blue));
            </code>
            The output would be something like this (based on other high score examples)
            <code>
            2000 - HB
            1500 - ED
            1000 - EZY
            </code>
            </example>
        </member>
        <member name="M:Engine.HighScore.GetRowStringRank(System.Int32,System.String)">
            <summary>
            returns a formatted score row including a rank number (assumes the column is named RANK - 4 characters long)
            </summary>
            <param name="row">This position in the table we wish to extract scores from
            the position starts at 0 for the first one and so on</param>
            <param name="delimiter">The string to place between attributes of the score</param>
            <returns>A string containing the attributes for the selected score separated by delimiter given.
            If row doesn't exist then ERROR will be returned in the string</returns>
            <returns>A string containing the attributes for the selected score separated by delimiter given.
            If row doesn't exist then ERROR will be returned in the string</returns>
        </member>
        <member name="M:Engine.HighScore.GetColumnHeadingsString(System.String)">
            <summary>
            Returns a crudelly formated string containing the headings from
            the score table
            </summary>
            <param name="delimiter">String to pad the between the headings</param>
            <returns>A string of column headings</returns>
        </member>
        <member name="M:Engine.HighScore.ScoreCheck(System.Int64)">
            <summary>
            Checks to see if the score given would make the highscore table
            </summary>
            <param name="score">The score to be checked against the highscore table</param>
            <returns>the position the score would occupy in the table.
            0 indicates 1st place, 1 indicates 2nd place, and so on, -1 indicates not good enough</returns>
            <example>This example checks a score when a game ends and calls GetName() sub which sets playerName 
            before adding the score if it is good enough.
            <code>
            if (highScoreTable.CheckScore(score) != -1)
            {
                GetName();
                //create a score entry object
                List&lt;Object&gt; scoreEntry = new List&lt;Object&gt;();
            
                // add the highscore to the table
                scoreEntry.Add(2000);
                scoreEntry.Add(playerName);
                highScoreTable.AddScore(scoreEntry);
            }
            StartTitle();
            </code></example>
        </member>
        <member name="M:Engine.HighScore.ScoreCheck(System.Int32)">
            <summary>
            Checks to see if the score given would make the highscore table
            </summary>
            <param name="score">The score to be checked against the highscore table</param>
            <returns>the position the score would occupy in the table.</returns>
        </member>
        <member name="M:Engine.HighScore.ScoreCheck(System.Object)">
            <summary>
            Checks to see if the score given would make the highscore table
            </summary>
            <param name="score">The score to be checked against the highscore table</param>
            <returns>the position the score would occupy in the table.</returns>
        </member>
        <member name="M:Engine.HighScore.ItemValueAsString(System.Int32,System.String)">
            <summary>
            returns the value of an attribute at a specified position in string form
            </summary>
            <param name="row">the position in the table we wish to retrieve</param>
            <param name="columnName">The name of the attribute we want the value of</param>
            <returns>The value formatted as a string or ERROR if the name or row supplied were invalid</returns>
        </member>
        <member name="M:Engine.HighScore.ItemValueAsString(System.Int32,System.Int32)">
            <summary>
            returns the value of an attribute at a specified position in string form
            </summary>
            <param name="row">the position in the table we wish to retrieve</param>
            <param name="column">The column (0 is first column) of the attribute we want the value of</param>
            <returns>The value formatted as a string or ERROR if the row or column supplied is invalid</returns>
            <example>This example demonstrates how to use the GetAttributeValueString and GetAttributeName
            to display the HighScoreTable using just the data contained within it.
            This makes this very flexable, if you change any attribute names they will automatically be displayed
            correctly
            <code>
                    /// &lt;summary&gt;
                    /// Displays the HighScore table by using the row and column accessors
                    /// &lt;/summary&gt;
                    /// &lt;remarks&gt;Firstly displays the names of all the attributes then the rest of the table&lt;/remarks&gt;
                    public void DrawHighScores()
                    {
                        //display each of the attribute names (columns) spaced 100 pixels apart (horizontally)
                        //in white
                        for (int j = 0; j &lt; highScoreTable.Columns; j++)
                            gameManager.DrawText("fontsheet", 
                                highScoreTable.GetAttributeName(j), 300 + j*100, 200, 0.5f, 1, Color.White);
            
                        //go through each column of the score table and display the values for each attribute
                        //j loop represents the columns and the i loop represents each row
                        //each column is 100 pixels apart and each row is 40 pixels apart
                        for (int j = 0; j &lt; highScoreTable.Columns; j++)
                            for (int i = 0; i &lt; highScoreTable.Count; i++)
                            {
                                gameManager.DrawText("fontsheet", highScoreTable.GetAttributeValueAsString(i, j)
                                    , 300 + j * 100, 250 + i * 40, 0.5f, 1, Color.CornflowerBlue);
                        }
                    }
            </code>
            </example>
        </member>
        <member name="M:Engine.HighScore.ItemValueAsObject(System.Int32,System.String)">
            <summary>
            returns the value of an attribute as an object
            </summary>
            <param name="row">the position in the table we wish to retrieve</param>
            <param name="columnName">The name of the attribute we want the value of</param>
            <returns>The value in its original form or null if the row or name specified was invalid</returns>
        </member>
        <member name="M:Engine.HighScore.ItemValueAsObject(System.Int32,System.Int32)">
            <summary>
            returns the value of an attribute as an object
            </summary>
            <param name="row">the position in the table we wish to retrieve</param>
            <param name="column">The name of the attribute we want the value of</param>
            <returns>The value in its original form or null if the row or column specified was invalid</returns>
        </member>
        <member name="M:Engine.HighScore.ColumnName(System.Int32)">
            <summary>
            Gets the name of the specified column in the score table
            </summary>
            <param name="column">The column we want the name of</param>
            <returns>The name of the column or ERROR if the column specified was invalid</returns>
        </member>
        <member name="M:Engine.HighScore.ToString">
            <summary>
            Returns a partially formatted table for debugging purposes
            </summary>
            <returns>a string formatted with ~ line returns</returns>
        </member>
        <member name="M:Engine.HighScore.ToString(Engine.IntCallBack)">
            <summary>
            Gets the entire score table in a formatted string ready for text diplay
            </summary>
            <param name="scoreFormatter">A call back function that processes the format of the score </param>
            <returns></returns>
        </member>
        <member name="P:Engine.HighScore.ToStringNoHeader">
            <summary>
            gets a partially formatted table without the column headings
            This is useful for quick highscore displays in prototypes
            </summary>
        </member>
        <member name="M:Engine.HighScore.QuickList(System.Int32)">
            <summary>
            returns a simple list of the given number of top scores
            </summary>
            <param name="number">number of scores to return</param>
            <returns>Score list ready for drawing as text</returns>
        </member>
        <member name="P:Engine.HighScore.ToStringQuickList">
            <summary>
            gets a simple list of all the scores available
            </summary>
        </member>
        <member name="T:Engine.IntCallBack">
            <summary>
            pre processor for score display when using standard ToString() arrangement
            This allows formatting of the score output
            </summary>
            <param name="score"></param>
            <returns></returns>
        </member>
        <member name="T:Engine.Int64CallBack">
            <summary>
            pre processor for score display when using standard ToString() arrangement
            works with 64 bit integers
            This allows formatting of the score output
            </summary>
            <param name="score"></param>
            <returns></returns>
        </member>
        <member name="T:Engine.ICollider">
            <summary>
            implementations required for collision engine
            </summary>
        </member>
        <member name="P:Engine.ICollider.Collisions">
            <summary>
            number of collisions processed during last update
            </summary>
        </member>
        <member name="P:Engine.ICollider.Checks">
            <summary>
            number of decisions made
            </summary>
        </member>
        <member name="M:Engine.ICollider.CollisionCheck(Engine.Sprite)">
            <summary>
            performs checking of the sprite collision
            </summary>
            <param name="s">the sprite to check for collisions</param>
        </member>
        <member name="M:Engine.ICollider.ResetMetrics">
            <summary>
            initialises any metrics
            </summary>
        </member>
        <member name="T:Engine.ICollisionResponse">
            <summary>
            implentations for the handling of collisions between sprites
            </summary>
        </member>
        <member name="M:Engine.ICollisionResponse.CollisionResponse(Engine.Sprite,Engine.Sprite)">
            <summary>
            performs the necessary response to the collision between the 2 sprites
            </summary>
            <param name="s">The sprite being checked</param>
            <param name="target">the sprite hit</param>
        </member>
        <member name="T:Engine.KeyPadPair">
            <summary>
            defines a key and button that do the same task
            </summary>
        </member>
        <member name="M:Engine.KeyPadPair.#ctor(Microsoft.Xna.Framework.Input.Keys,System.Int32,Microsoft.Xna.Framework.Input.Buttons)">
            <summary>
            creates a new KeyPadPair with the specified values
            </summary>
            <param name="key">The key to check for</param>
            <param name="padnum">the pad number to check for the button pressed</param>
            <param name="button">the button to check</param>
        </member>
        <member name="T:Engine.InputManager">
            <summary>
            This is a game component that implements IUpdateable.
            </summary>
        </member>
        <member name="F:Engine.InputManager.owner">
            <summary>
            holds a reference to 
            </summary>
        </member>
        <member name="M:Engine.InputManager.TakeOwnerShip(System.Object)">
            <summary>
            used if we want to overlay input code and 
            </summary>
            <param name="newowner"></param>
        </member>
        <member name="M:Engine.InputManager.ReleaseOwnerShip(System.Object)">
            <summary>
            attempts to remove ownership of input
            </summary>
            <param name="currentowner"></param>
            <returns></returns>
        </member>
        <member name="F:Engine.InputManager.kb">
            <summary>
            A keyboard buffer using the new keyboard buffer class
            managed by the InputManager
            </summary>
        </member>
        <member name="P:Engine.InputManager.KeyBoardBuffer">
            <summary>
            A keyboard buffer using the new keyboard buffer class
            managed by the InputManager
            </summary>
        </member>
        <member name="F:Engine.InputManager.oldestMouseState">
            <summary>
            last state of the mouse
            </summary>
        </member>
        <member name="F:Engine.InputManager.latestMouseState">
            <summary>
            current state of the mouse
            </summary>
        </member>
        <member name="P:Engine.InputManager.MouseDistance">
            <summary>
            Gets the distance the mouse moved since last game update as a Vector2 Value
            </summary>
        </member>
        <member name="P:Engine.InputManager.MouseDistanceAsPoint">
            <summary>
            Gets the distance the mouse moved since last game update
            </summary>
        </member>
        <member name="P:Engine.InputManager.MouseLocation">
            <summary>
            gets the location of the mouse as a Vector2 value
            </summary>
        </member>
        <member name="P:Engine.InputManager.MouseLocationAsPoint">
            <summary>
            gets the location of the mouse as a Point value
            </summary>
        </member>
        <member name="M:Engine.InputManager.MouseReset(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Sets the mouse to the position given and resets the state
            </summary>
            <param name="newPosition">The Vector2 to place the mouse at</param>
        </member>
        <member name="M:Engine.InputManager.MouseReset(Microsoft.Xna.Framework.Point)">
            <summary>
            Sets the mouse to the position given and resets the state
            </summary>
            <param name="newPosition">The point to place the mouse at</param>
        </member>
        <member name="M:Engine.InputManager.MouseReset(System.Single,System.Single)">
            <summary>
            Sets the mouse to the position given and resets the state
            </summary>
            <param name="x">The x position to place the mouse at</param>
            <param name="y">The y position to place the mouse at</param>
        </member>
        <member name="M:Engine.InputManager.MouseLeftButtonHeld">
            <summary>
            Determines if the left mouse button is being held down (is now and was previously)
            </summary>
            <returns>True if button is being held</returns>
        </member>
        <member name="M:Engine.InputManager.MouseLeftButtonReleased">
            <summary>
            Determines if the left mouse button has just been released
            </summary>
            <returns>True if button was held previously but has just been released</returns>
        </member>
        <member name="M:Engine.InputManager.MouseLeftButtonPressed">
            <summary>
            Determines if the left mouse button has just been pressed
            </summary>
            <returns>True if button was not held previously but has just been pressed</returns>
        </member>
        <member name="M:Engine.InputManager.MouseRightButtonHeld">
            <summary>
            Determines if the right mouse button is being held down (is now and was previously)
            </summary>
            <returns>True if button is being held</returns>
        </member>
        <member name="M:Engine.InputManager.MouseRightButtonReleased">
            <summary>
            Determines if the right mouse button has just been released
            </summary>
            <returns>True if button was held previously but has just been released</returns>
        </member>
        <member name="M:Engine.InputManager.MouseRightButtonPressed">
            <summary>
            Determines if the right mouse button has just been pressed
            </summary>
            <returns>True if button was not held previously but has just been pressed</returns>
        </member>
        <member name="M:Engine.InputManager.DistanceMoved">
            <summary>
            DUPLICATED by PROPERTY
            returns the distance the mouse has moved since last check
            </summary>
            <returns>A Vector2 with the distance moved</returns>
        </member>
        <member name="F:Engine.InputManager.oldestKeyboardState">
            <summary>
            last state of keyboard
            </summary>
        </member>
        <member name="F:Engine.InputManager.latestKeyboardState">
            <summary>
            current state of keybaord
            </summary>
        </member>
        <member name="F:Engine.InputManager.latestPadState">
            <summary>
            holds the current state of the game pads
            </summary>
        </member>
        <member name="F:Engine.InputManager.oldestPadState">
            <summary>
            holds the previous state of the game pads
            </summary>
        </member>
        <member name="M:Engine.InputManager.Flush">
            <summary>
            resets input states so keypressed don't activate twice between mode changes
            </summary>
        </member>
        <member name="P:Engine.InputManager.Dragging">
            <summary>
            states if a drag operation is active. Use this to record whether you have initiated a dragging event
            </summary>
        </member>
        <member name="M:Engine.InputManager.Pressed(Engine.KeyPadPair)">
            <summary>
            determines if either the key or button on the pad specified by the KeyPadPair has been pressed (previously not down)
            </summary>
            <param name="keyButton">The KeyPadPair you want to test</param>
            <returns>true if either was pressed</returns>
        </member>
        <member name="M:Engine.InputManager.Pressed(Microsoft.Xna.Framework.Input.Keys,System.Int32,Microsoft.Xna.Framework.Input.Buttons)">
            <summary>
            determines if either the key or button on the pad specified by the KeyPadPair has been pressed (previously not down)
            </summary>
            <param name="key">The key to check for</param>
            <param name="padNum">the pad number to check for the button pressed</param>
            <param name="button">the button to check</param>
            <returns>true if either was pressed</returns>
        </member>
        <member name="M:Engine.InputManager.Released(Engine.KeyPadPair)">
            <summary>
            Determines if key was previously pressed and now not pressed
            </summary>
            <param name="keyButton">The KeyPadPair you want to test</param>
            <returns>True if key released, false if still held or never held</returns>
        </member>
        <member name="M:Engine.InputManager.Released(Microsoft.Xna.Framework.Input.Keys,System.Int32,Microsoft.Xna.Framework.Input.Buttons)">
            <summary>
            Determines if key was previously pressed and now not pressed
            </summary>
            <param name="key">The key to check for</param>
            <param name="padNum">the pad number to check for the button pressed</param>
            <param name="button">the button to check</param>
            <returns>True if key released, false if still held or never held</returns>
        </member>
        <member name="M:Engine.InputManager.Held(Engine.KeyPadPair)">
            <summary>
            Determines if a key is still being held down
            </summary>
            <param name="keyButton">The KeyPadPair you want to test</param>
            <returns>True if key is being held and was held previously, false if not held</returns>
        </member>
        <member name="M:Engine.InputManager.Held(Microsoft.Xna.Framework.Input.Keys,System.Int32,Microsoft.Xna.Framework.Input.Buttons)">
            <summary>
            Determines if a key is still being held down
            </summary>
            <param name="key">The key to check for</param>
            <param name="padNum">the pad number to check for the button pressed</param>
            <param name="button">the button to check</param>
            <returns>True if key is being held and was held previously, false if not held</returns>
        </member>
        <member name="M:Engine.InputManager.Down(Engine.KeyPadPair)">
            <summary>
            Determines if the selected button on the specified pad is currently pressed
            </summary>
            <param name="keyButton">The KeyPadPair you want to test</param>
            <returns>True if button pressed, false if not pressed</returns>
        </member>
        <member name="M:Engine.InputManager.Down(Microsoft.Xna.Framework.Input.Keys,System.Int32,Microsoft.Xna.Framework.Input.Buttons)">
            <summary>
            Determines if the selected button on the specified pad is currently pressed
            </summary>
            <param name="key">The key to check for</param>
            <param name="padNum">the pad number to check for the button pressed</param>
            <param name="button">the button to check</param>
            <returns>True if button pressed, false if not pressed</returns>
        </member>
        <member name="M:Engine.InputManager.Up(Engine.KeyPadPair)">
            <summary>
            Determines if the selected button on the specified pad is currently not pressed
            </summary>
            <param name="keyButton">The KeyPadPair you want to test</param>
            <returns>True if not pressed, false if pressed</returns>
        </member>
        <member name="M:Engine.InputManager.Up(Microsoft.Xna.Framework.Input.Keys,System.Int32,Microsoft.Xna.Framework.Input.Buttons)">
            <summary>
            Determines if the selected button on the specified pad is currently not pressed
            </summary>
            <param name="key">The key to check for</param>
            <param name="padNum">the pad number to check for the button pressed</param>
            <param name="button">the button to check</param>
            <returns>True if not pressed, false if pressed</returns>
        </member>
        <member name="M:Engine.InputManager.KeyPressed(Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            Determines if a key was just pressed
            </summary>
            <param name="key">The key to check</param>
            <returns>True if key has been pressed but wasn't previously</returns>
        </member>
        <member name="M:Engine.InputManager.KeyReleased(Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            Determines if key was previously pressed and now not pressed
            </summary>
            <param name="key">The key to check</param>
            <returns>True if key released, false if still held or never held</returns>
        </member>
        <member name="M:Engine.InputManager.KeyHeld(Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            Determines if a key is still being held down
            </summary>
            <param name="key">The key to check</param>
            <returns>True if key is being held and was held previously, false if not held</returns>
        </member>
        <member name="M:Engine.InputManager.KeyDown(Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            Determines if the key specified is currently down
            </summary>
            <param name="key">Key to check</param>
            <returns>True if key is down, false if not</returns>
        </member>
        <member name="M:Engine.InputManager.KeyUp(Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            Determines if the key specified is not pressed
            </summary>
            <param name="key">Key to check</param>
            <returns>True if key is up, false if not</returns>
        </member>
        <member name="M:Engine.InputManager.PadState(System.Int32)">
            <summary>
            Returns the current status of the given pad
            </summary>
            <param name="padNum">The number 1 to 4 of the pad you wish to look at</param>
        </member>
        <member name="M:Engine.InputManager.PadStatePrevious(System.Int32)">
            <summary>
            Returns the previous state of the selected pad
            </summary>
            <param name="padNum">The number 1 to 4 of the pad you wish to look at</param>
        </member>
        <member name="M:Engine.InputManager.Triggers(System.Int32)">
            <summary>
            Returns the triggers for the selected pad
            </summary>
            <param name="padNum">Pad to get the triggers for pad numbers in range 1 to 4</param>
            <returns>A GamePadTriggers object for the given pad</returns>
        </member>
        <member name="M:Engine.InputManager.ThumbSticks(System.Int32)">
            <summary>
            Returns the Thumbsticks for the selected pad
            </summary>
            <param name="padNum">Pad to get the Thumbsticks for pad numbers in range 1 to 4</param>
            <returns>A GamePadThumbSticks object for the given pad</returns>
        </member>
        <member name="M:Engine.InputManager.ButtonPressed(System.Int32,Microsoft.Xna.Framework.Input.Buttons)">
            <summary>
            Determines if a button was just pressed
            </summary>
            <param name="padNum">Pad number to interogate pad numbers in range 1 to 4</param>
            <param name="button">Button to check</param>
            <returns>True if button has been pressed but wasn't previously</returns>
        </member>
        <member name="M:Engine.InputManager.ButtonReleased(System.Int32,Microsoft.Xna.Framework.Input.Buttons)">
            <summary>
            Determines if key was previously pressed and now not pressed
            </summary>
            <param name="padNum">Pad number to interogate pad numbers in range 1 to 4</param>
            <param name="button">Button to check</param>
            <returns>True if key released, false if still held or never held</returns>
        </member>
        <member name="M:Engine.InputManager.ButtonHeld(System.Int32,Microsoft.Xna.Framework.Input.Buttons)">
            <summary>
            Determines if a key is still being held down
            </summary>
            <param name="padNum">Pad number to interogate pad numbers in range 1 to 4</param>
            <param name="button">Button to check</param>
            <returns>True if key is being held and was held previously, false if not held</returns>
        </member>
        <member name="M:Engine.InputManager.ButtonDown(System.Int32,Microsoft.Xna.Framework.Input.Buttons)">
            <summary>
            Determines if the selected button on the specified pad is currently pressed
            </summary>
            <param name="padNum">Pad number to interogate pad numbers in range 1 to 4</param>
            <param name="button">Button to check</param>
            <returns>True if button pressed, false if not pressed</returns>
        </member>
        <member name="M:Engine.InputManager.ButtonUp(System.Int32,Microsoft.Xna.Framework.Input.Buttons)">
            <summary>
            Determines if the selected button on the specified pad is currently not pressed
            </summary>
            <param name="padNum">Pad number to interogate pad numbers in range 1 to 4</param>
            <param name="button">Button to check</param>
            <returns>True if not pressed, false if pressed</returns>
        </member>
        <member name="M:Engine.InputManager.PadConnected(System.Int32)">
            <summary>
            Retrieves the connection status of the specified pad
            </summary>
            <param name="padNum">The pad to check connection to pad numbers in range 1 to 4</param>
            <returns>true if pad connected, false if not</returns>
        </member>
        <member name="M:Engine.InputManager.#ctor(Microsoft.Xna.Framework.Game)">
            <summary>
            Input handler
            </summary>
            <param name="game"></param>
        </member>
        <member name="M:Engine.InputManager.Initialize">
            <summary>
            Allows the game component to perform any initialization it needs to before starting
            to run.  This is where it can query for any required services and load content.
            </summary>
        </member>
        <member name="M:Engine.InputManager.ResetState">
            <summary>
            resets input states so keypressed don't activate twice between mode changes
            </summary>
        </member>
        <member name="M:Engine.InputManager.Update(Microsoft.Xna.Framework.GameTime)">
            <summary>
            Allows the game component to update itself.
            </summary>
            <param name="gameTime">Provides a snapshot of timing values.</param>
        </member>
        <member name="T:Engine.DescendingZSort">
            <summary>
            a descending Icomparer for sorting sprites on Z
            </summary>
        </member>
        <member name="M:Engine.DescendingZSort.Compare(Engine.Sprite,Engine.Sprite)">
            <summary>
            Compares the z position of 2 sprites in descending order
            </summary>
            <param name="a">The 1st sprite</param>
            <param name="b">the 2nd sprite</param>
            <returns>1 if descending, -1 if ascending</returns>
        </member>
        <member name="T:Engine.IntHelper">
            <summary>
            A collection of methods for working with integer values by Eric
            </summary>
        </member>
        <member name="M:Engine.IntHelper.Clamp(System.Int32,System.Int32,System.Int32)">
            <summary>
            Integer Clamp system
            </summary>
            <param name="value">The value checking</param>
            <param name="min">the minimum value allowed</param>
            <param name="max">the maximum value allowed</param>
            <returns>the value checked to make sure it fits withing the range specified</returns>
        </member>
        <member name="M:Engine.IntHelper.Clamp(System.Int32,System.Int32)">
            <summary>
            Integer clamp with lower value of 0
            </summary>
            <param name="value">The value checking</param>
            <param name="max">the maximum value allowed</param>
            <returns>the value checked to make sure it fits withing the range specified</returns>
        </member>
        <member name="M:Engine.IntHelper.Smallest(System.Int32,System.Int32)">
            <summary>
            Returns the smallest of two values
            </summary>
            <param name="first">first value</param>
            <param name="second">second value</param>
            <returns>the smallest of the two values</returns>
        </member>
        <member name="M:Engine.IntHelper.Largest(System.Int32,System.Int32)">
            <summary>
            Returns the largest of two values
            </summary>
            <param name="first">first value</param>
            <param name="second">second value</param>
            <returns>the largest of the two values</returns>
        </member>
        <member name="T:Engine.KeyboardBuffer">
            <summary>
            Implements a simple keyboard buffer
            </summary>
        </member>
        <member name="M:Engine.KeyboardBuffer.#ctor">
            <summary>
            constructor for the keyboard buffer
            </summary>
        </member>
        <member name="M:Engine.KeyboardBuffer.SpecifyKeyMatchingPairs(Microsoft.Xna.Framework.Input.Keys[],System.String)">
            <summary>
            Overrides the default allowable key set with one of your own.
            The lengths of both lists must be the same
            </summary>
            <param name="validKeys">An array of valid key enums</param>
            <param name="matchingCharacters">A correspoding string of matching characters</param>
        </member>
        <member name="F:Engine.KeyboardBuffer.lastKeyList">
            <summary>
            holds last set of keys pressed
            </summary>
        </member>
        <member name="F:Engine.KeyboardBuffer.pressedKeys">
            <summary>
            holds the current set of keys, used to eliminate a parameter pass
            </summary>
        </member>
        <member name="F:Engine.KeyboardBuffer.Active">
            <summary>
            Determines if the keyboard buffer is activated
            </summary>
        </member>
        <member name="M:Engine.KeyboardBuffer.On">
            <summary>
            turns on the keyboard buffer
            </summary>
        </member>
        <member name="M:Engine.KeyboardBuffer.Off">
            <summary>
            turns off the keyboard buffer
            </summary>
        </member>
        <member name="F:Engine.KeyboardBuffer.HandleEnter">
            <summary>
            if true then the Keyboard buffer will 
            </summary>
        </member>
        <member name="F:Engine.KeyboardBuffer.IgnoreEnter">
            <summary>
            if true then enter is not processed as a valid key,
            if false then ~ (line break character) will be entered into the buffer
            </summary>
        </member>
        <member name="F:Engine.KeyboardBuffer.HandleBackSpace">
            <summary>
            if true the keyboard buffer will automatically remove the last character when
            the backspace key is pressed
            </summary>
        </member>
        <member name="F:Engine.KeyboardBuffer.buffer">
            <summary>
            holds the buffered characters
            </summary>
        </member>
        <member name="P:Engine.KeyboardBuffer.GetBuffer">
            <summary>
            gets the keyboard buffer but does not clear it
            </summary>
        </member>
        <member name="P:Engine.KeyboardBuffer.GetBufferAndFlush">
            <summary>
            gets the keyboard buffer and clears it afterwords
            </summary>
        </member>
        <member name="M:Engine.KeyboardBuffer.Flush">
            <summary>
            clears the keyboard buffer
            </summary>
        </member>
        <member name="M:Engine.KeyboardBuffer.GetChar(System.Int32)">
            <summary>
            gets 
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Engine.KeyboardBuffer.LegalKey(Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            Determins if a key is legal and returns its index
            </summary>
            <param name="thisKey">The key to check</param>
            <returns>the index of the key</returns>
        </member>
        <member name="M:Engine.KeyboardBuffer.RemoveLast">
            <summary>
            removes the last entry from the buffer
            </summary>
        </member>
        <member name="M:Engine.KeyboardBuffer.AddUpper(Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            Adds the upper case value of the given key if it is in the legal list
            </summary>
            <param name="key">The key pressed</param>
        </member>
        <member name="M:Engine.KeyboardBuffer.Add(Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            Adds the lower case value of the given key if it is in the legal list
            </summary>
            <param name="key">The key pressed</param>
        </member>
        <member name="M:Engine.KeyboardBuffer.Contains(Microsoft.Xna.Framework.Input.Keys[],Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            Attempt to determine if a key exists in the given list
            </summary>
            <param name="keyList">Array of keys to look in</param>
            <param name="thisKey">Key to look for</param>
            <returns>true if key is found in list</returns>
        </member>
        <member name="M:Engine.KeyboardBuffer.Update">
            <summary>
            performs the update - called by the inputmanager
            </summary>
        </member>
        <member name="T:Engine.LC">
            <summary>
            loader class for content pipeline objects
            </summary>
        </member>
        <member name="F:Engine.LC.LoadedItem">
            <summary>
            Place where the item is stored
            </summary>
        </member>
        <member name="T:Engine.Limit">
            <summary>
            performs limit checking for the sprite
            </summary>
        </member>
        <member name="F:Engine.Limit.Area">
            <summary>
            the area of the limit box
            </summary>
        </member>
        <member name="F:Engine.Limit.Wash">
            <summary>
            the colour wash for the box when drawn
            </summary>
        </member>
        <member name="F:Engine.Limit.Alpha">
            <summary>
            the alpha of the box when drawn
            </summary>
        </member>
        <member name="P:Engine.Limit.LimitCallBack">
            <summary>
            a sprite handler called when we respond to the limit box settings
            </summary>
        </member>
        <member name="F:Engine.Limit.boss">
            <summary>
            holds a reference to the sprite
            </summary>
        </member>
        <member name="F:Engine.Limit.Show">
            <summary>
            determines whether the limit box is displayed or not
            </summary>
        </member>
        <member name="F:Engine.Limit.UseViewport">
            <summary>
            if true limit box is generated as the viewport area rather than the physical limit box
            </summary>
        </member>
        <member name="F:Engine.Limit.AtLimit">
            <summary>
            true if sprite is interacting with the limit box
            </summary>
        </member>
        <member name="F:Engine.Limit.RestrictionActive">
            <summary>
            determines if the limit box is active. 
            Set this to true after performing LimitInitialise() if you need items to immediately respond to limit box
            in cases where you may generate sprites that may drift ouf screen and never wrap or be killed, leaving unaccessible sprites
            </summary>
        </member>
        <member name="F:Engine.Limit.Action">
            <summary>
            determines what action is taken when we interact with the limit box
            </summary>
        </member>
        <member name="F:Engine.Limit._workArea">
            <summary>
            scratch area to keep garbage down during Check
            </summary>
        </member>
        <member name="M:Engine.Limit.#ctor(Engine.Sprite)">
            <summary>
            constructor accepting the owner of the limit box
            </summary>
            <param name="myBoss"></param>
        </member>
        <member name="M:Engine.Limit.Clone">
            <summary>
            Returns a cloned copy of the limit settings
            </summary>
            <returns>a new instance that is a copy of this limit box</returns>
        </member>
        <member name="M:Engine.Limit.ViewPortAction(Engine.LimitAction)">
            <summary>
            Sets up and activates a limit box based on the current position of the viewport
            </summary>
            <param name="action">the action to take at the limits</param>
        </member>
        <member name="M:Engine.Limit.RegionAction(Microsoft.Xna.Framework.Rectangle,Engine.LimitAction)">
            <summary>
            Sets up and activates a limit box
            </summary>
            <param name="area">the rectangle that represents the limits for this sprite</param>
            <param name="action">the action to take at the limits</param>
        </member>
        <member name="M:Engine.Limit.RegionAction(Engine.Box,Engine.LimitAction)">
            <summary>
            Sets up and activates a limit box
            </summary>
            <param name="regionBox">the box that represents the limits for this sprite</param>
            <param name="action">the action to take at the limits</param>
        </member>
        <member name="F:Engine.Limit._work_view">
            <summary>
            holds a ref to the default viewport
            </summary>
        </member>
        <member name="M:Engine.Limit.Check">
            <summary>
            Checks Sprite against the boundary limit and performs action required
            </summary>
        </member>
        <member name="T:Engine.Line">
            <summary>
            holds the definition of a single line
            </summary>
        </member>
        <member name="F:Engine.Line.Owner">
            <summary>
            specifies the owner object of a particular line
            </summary>
        </member>
        <member name="P:Engine.Line.Vertices">
            <summary>
            Access to vertices defined for line
            </summary>
        </member>
        <member name="F:Engine.Line.verts">
            <summary>
            internal access to the verts
            </summary>        
        </member>
        <member name="F:Engine.Line.settings">
            <summary>
            internal access
            </summary>
        </member>
        <member name="P:Engine.Line.Settings">
            <summary>
            gets or sets the lineData for this line
            </summary>
        </member>
        <member name="P:Engine.Line.Type">
            <summary>
            gets the line type of this line
            </summary>
        </member>
        <member name="P:Engine.Line.Length">
            <summary>
            gets or sets the length of the line in Position, length angle mode
            </summary>
        </member>
        <member name="M:Engine.Line.CalcAverageDepth">
            <summary>
            calculates the average depth between 2 points when they change
            </summary>
        </member>
        <member name="M:Engine.Line.CalcAngleBetween">
            <summary>
            calculates the angle between two points when points change
            </summary>
        </member>
        <member name="M:Engine.Line.CalcLength">
            <summary>
            calculates distance between 2 points when values change in two points specified line
            </summary>
        </member>
        <member name="F:Engine.Line.angle">
            <summary>
            holds the angle in radians. if manually accessing this remember to add on PIOver2
            </summary>
        </member>
        <member name="P:Engine.Line.Angle">
            <summary>
            the angle of the line in degrees, 0 is north straight up
            </summary>
        </member>
        <member name="M:Engine.Line.#ctor">
            <summary>
            creates a dummy line
            </summary>
        </member>
        <member name="M:Engine.Line.#ctor(Microsoft.Xna.Framework.Vector3,System.Single,System.Single)">
            <summary>
            specifies a line as a position, length and angle
            </summary>
            <param name="position">the position the line starts at</param>
            <param name="length">length in pixels of the line</param>
            <param name="angle">the angle of the line in degrees</param>
        </member>
        <member name="M:Engine.Line.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>
            specifies a line between 2 points
            </summary>
            <param name="startPoint">the starting point</param>
            <param name="endPoint">the end point</param>
        </member>
        <member name="M:Engine.Line.#ctor(Microsoft.Xna.Framework.Vector3[],Engine.LineType)">
            <summary>
            specifies either a line from a position vector and a direction vector or creates an open or closed polygon
            </summary>
            <param name="data">if creating a PointAndDirectionVector line pass the position vector as the first item in the array and the direction vector as the second
            .if passing polygon data pass each vertice in order in the data array</param>
            <param name="polygonLineType">pass either PointAndDirectionVector, PolygonClosed or PolgonOpen - any other values are ignored</param>
        </member>
        <member name="M:Engine.Line.CleanUp">
            <summary>
            called by engine when line is removed from drawing
            override and make sure the line cleans up any resources allocated
            </summary>
        </member>
        <member name="M:Engine.Line.Draw(Engine.EngineManager,Microsoft.Xna.Framework.Graphics.SpriteBatch,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Called by the engine ?? draws the line using the given spritebatch and viewport offset
            </summary>
            <param name="em">reference to engine manager</param>
            <param name="sb">Spritebatch to use</param>
            <param name="offset">offset to apply if world coords</param>
            <param name="layerDisplacement">displacement setting for the layer</param>
        </member>
        <member name="T:Engine.LineData">
            <summary>
            specifies basic line information for rendering
            </summary>
        </member>
        <member name="P:Engine.LineData.Alpha">
            <summary>
            specifies alpha value for rendering, defaults to 1
            </summary>
        </member>
        <member name="P:Engine.LineData.Thickness">
            <summary>
            specifies thickness in pixels of line, defaults to 1
            </summary>
        </member>
        <member name="F:Engine.LineData.thickness">
            <summary>
            holds the thickness value for the line
            </summary>
        </member>
        <member name="F:Engine.LineData.RotationCentre">
            <summary>
            holds adjusted rotation centre for thickness adjustment
            </summary>
        </member>
        <member name="P:Engine.LineData.Wash">
            <summary>
            specifies wash to use for rendering, defaults to White
            </summary>
        </member>
        <member name="F:Engine.LineData.layer">
            <summary>
            specifies the renderlayer to use those with sprites, defaults to SpriteZero
            </summary>
        </member>
        <member name="P:Engine.LineData.Layer">
            <summary>
            specifies the renderlayer to use those with sprites, defaults to SpriteZero.
             You can only render to sprite layers and the Hud layer other layer types will be rejected
            </summary>
        </member>
        <member name="P:Engine.LineData.WorldCoordinates">
            <summary>
            specifies whether this is using world of view coordinates
            </summary>
        </member>
        <member name="F:Engine.LineData.textureOverride">
            <summary>
            holds a different texture to use to draw lines
            </summary>
        </member>
        <member name="P:Engine.LineData.TextureOverride">
            <summary>
            gets or sets a texture to use in preference to the single white pixel.
            set to null to use the single white pixel. the line rendered uses the whole texture
            </summary>
        </member>
        <member name="M:Engine.LineData.#ctor">
            <summary>
            default line data
            </summary>
        </member>
        <member name="M:Engine.LineData.Clone">
            <summary>
            clones a line style (so we have separate references)
            </summary>
            <returns>a new line style with the same settings as this one</returns>
        </member>
        <member name="T:Engine.Loader">
            <summary>
            performs background loading of content
            </summary>
        </member>
        <member name="T:Engine.Loader.TextureLoaded">
            <summary>
            a delegate subroutine called when a particular texture has been loaded
            </summary>
            <param name="texture">the texture that's just been loaded</param>
            <param name="filename">the filename of the texture, so you can check for each specific texture</param>
        </member>
        <member name="T:Engine.Loader.AudioLoaded">
            <summary>
            a delegate subroutine called when a particular audio file has been loaded
            </summary>
            <param name="soundName">The name you gave to the audio file (not the filename)</param>
            <param name="soundEffect">a boolean which if true means this is a sound effect, if false its a song</param>
        </member>
        <member name="F:Engine.Loader.loadList">
            <summary>
            holds a list of the content files to be loaded
            </summary>
        </member>
        <member name="F:Engine.Loader.loadCount">
            <summary>
            keeps track of number of assets loaded
            </summary>
        </member>
        <member name="P:Engine.Loader.AssetCount">
            <summary>
            gets the number of assets set for managed loading
            </summary>
        </member>
        <member name="P:Engine.Loader.NumberLoaded">
            <summary>
            gets the number of assets currently loaded
            </summary>
        </member>
        <member name="P:Engine.Loader.LoadComplete">
            <summary>
            Is true if asset loading is complete
            </summary>
        </member>
        <member name="F:Engine.Loader.am">
            <summary>
            the reference to the audio manager
            </summary>
        </member>
        <member name="M:Engine.Loader.#ctor(Microsoft.Xna.Framework.Game)">
            <summary>
            Creates a PreLoader that does not use the new audioManager class
            </summary>
            <param name="game">The game object</param>
        </member>
        <member name="M:Engine.Loader.Initialize">
            <summary>
            Allows the game component to perform any initialization it needs to before starting
            to run.  This is where it can query for any required services and load content.
            </summary>
        </member>
        <member name="M:Engine.Loader.Update(Microsoft.Xna.Framework.GameTime)">
            <summary>
            Allows the game component to update itself.
            </summary>
            <param name="gameTime">Provides a snapshot of timing values.</param>
        </member>
        <member name="M:Engine.Loader.Start(System.Int32)">
            <summary>
            Starts the preloader running asynchronously in another thread, the sleep delay
            allows the engine to get a little more time to do its work (even tho' this runs on 
            another thread)
            </summary>
            <param name="sleepTime">Amount of milliseconds to wait between each load</param>
        </member>
        <member name="M:Engine.Loader.AssetLoadManager">
            <summary>
            Performs the asynchronus loading of the specified assets
            </summary>
        </member>
        <member name="M:Engine.Loader.End">
            <summary>
            Destroys any remaining data in the pre-loader
            the pre-loader can then be use later on in the game if required
            </summary>
        </member>
        <member name="M:Engine.Loader.LoadNextAsset">
            <summary>
            loads a texture every time an event is triggered
            </summary>
        </member>
        <member name="M:Engine.Loader.AddAsset(System.String,System.Type)">
            <summary>
            adds an asset to the load manager
            </summary>
            <param name="Filename">the filename of the asset</param>
            <param name="assetType">the type of the asset set using
            typeof(Texture2D), typeof(SoundEffect) or typeof(song)</param>
        </member>
        <member name="M:Engine.Loader.AddTexture(System.String)">
            <summary>
            adds a texture asset to the load manager
            </summary>
            <param name="filename">the filename of the texture (without the extension)</param>
        </member>
        <member name="M:Engine.Loader.AddTexture(Engine.Loader.TextureLoaded,System.String)">
            <summary>
            adds a texture asset to the load manager and requests that a delegate be called once it has been loaded
            </summary>
            <param name="textureStore">A delegate to handle the loaded texture</param>
            <param name="filename">the filename of the texture (without the extension)</param>
        </member>
        <member name="M:Engine.Loader.AddSong(System.String,System.String)">
            <summary>
            Add a song asset to the load manager
            </summary>
            <param name="songName">The name to pass to the audio manager for 
            the song name</param>
            <param name="filename">The filename of the song (without the extension)</param>
        </member>
        <member name="M:Engine.Loader.AddSong(Engine.Loader.AudioLoaded,System.String,System.String)">
            <summary>
            loads a song in the background and passes this on to the audio manager, calling a delegate with the details
            </summary>
            <param name="tellMe">the delegate subroutine to run when the song as been loaded</param>
            <param name="songName">The name to pass to the audio manager for 
            the song name</param>
            <param name="filename">The filename of the song (without the extension)</param>
        </member>
        <member name="M:Engine.Loader.AddSoundEffect(Engine.Loader.AudioLoaded,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="tellMe"></param>
            <param name="soundName">The name to pass to the audio manager for 
            the sound effect</param>
            <param name="filename">The filename of the soundEffect (without the extension)</param>
        </member>
        <member name="M:Engine.Loader.AddSoundEffect(System.String,System.String)">
            <summary>
            Add a soundEffect asset to the load manager
            </summary>
            <param name="soundName">The name to pass to the audio manager for 
            the sound effect</param>
            <param name="filename">The filename of the soundEffect (without the extension)</param>
        </member>
        <member name="M:Engine.Loader.AddAsset(System.String,System.String,System.Type)">
            <summary>
            adds an sound asset to the manager and automatically loads it into the audiomanager for you
            </summary>
            <param name="soundName">The name to pass to the audio manager for 
            the song or sound effect</param>
            <param name="Filename">the filename of the song or soound effect</param>
            <param name="assetType">the type of the asset set using
            typeof(SoundEffect) or typeof(song)</param>
        </member>
        <member name="M:Engine.Loader.GetLoadedAsset(System.Int32)">
            <summary>
            retreives the asset at the given index
            </summary>
            <param name="index">A valid index for this asset request
            if you have 8 assets then the first will be 0 and the last will be 7.
            If the index is invalid then null is returned</param>
            <returns>The asset request which will need casting or a null value if it hasn't loaded or doesn't exist</returns>
        </member>
        <member name="T:Engine.Menu">
            <summary>
            Organises menu items into a menu
            </summary>
        </member>
        <member name="F:Engine.Menu.OriginatorBaseCode">
            <summary>
            holds the base value to be applied to menu items for textstore ownership
            </summary>
        </member>
        <member name="F:Engine.Menu.menuM">
            <summary>
            reference to the menu manager
            </summary>
        </member>
        <member name="F:Engine.Menu.track">
            <summary>
            holds a reference to the track used if any
            </summary>
        </member>
        <member name="F:Engine.Menu._menuType">
            <summary>
            specifies whether we have a sprite menu or text menu
            so the menu manager can handle
            </summary>
        </member>
        <member name="P:Engine.Menu.MenuType">
            <summary>
            gets the type of menu we have
            </summary>
            <value>The type of menu set either sprite or text</value>
        </member>
        <member name="F:Engine.Menu._selectionMode">
            <summary>
            specifies how menu items should be selected
            </summary>
        </member>
        <member name="F:Engine.Menu.wrap">
            <summary>
            controls whether selction wraps or not, default is true menu will wrap
            </summary>
        </member>
        <member name="F:Engine.Menu._showAll">
            <summary>
            determines if only selected itme is visible or all are visible
            </summary>
        </member>
        <member name="F:Engine.Menu.Name">
            <summary>
            The name of the menu for debug purposes
            </summary>
        </member>
        <member name="F:Engine.Menu.Items">
            <summary>
            The menu items for this menu
            </summary>
        </member>
        <member name="P:Engine.Menu.GetItems">
            <summary>
            gets the list of items in this menu
            </summary>
        </member>
        <member name="F:Engine.Menu.Tag">
            <summary>
            the tag or marker used with this menu (if it exists)
            </summary>
        </member>
        <member name="F:Engine.Menu._tracksInUse">
            <summary>
            Indicates whether this menu used a track from the trackbank
            </summary>
        </member>
        <member name="F:Engine.Menu._selected">
            <summary>
            holds the currently selected menu item
            </summary>
        </member>
        <member name="F:Engine.Menu._previousSelection">
            <summary>
            holds previous selection so we don't do animation range changes
            </summary>
        </member>
        <member name="F:Engine.Menu.Visible">
            <summary>
            states whether the menu is visible or not
            </summary>
        </member>
        <member name="F:Engine.Menu.moving">
            <summary>
            used to indicate if the menu items are travelling along a track to a certain position
            </summary>
        </member>
        <member name="F:Engine.Menu.distanceTillStop">
            <summary>
            The number of track positions to visit before stopping
            </summary>
        </member>
        <member name="F:Engine.Menu.startPosition">
            <summary>
            the start position of the first item moveing along a track
            </summary>
        </member>
        <member name="F:Engine.Menu._stepAmount">
            <summary>
            the number of points on a track to visit while automatically moving
            </summary>
        </member>
        <member name="F:Engine.Menu._trackOffset">
            <summary>
            holds the spacing offset specified for all items along the track
            </summary>
        </member>
        <member name="P:Engine.Menu.TrackMenuOffset">
            <summary>
            gets the track positions between menu items on the track specified
            </summary>
        </member>
        <member name="F:Engine.Menu.id">
            <summary>
            shared id for incrementing
            </summary>
        </member>
        <member name="F:Engine.Menu.myId">
            <summary>
            holds the unique reference for this menu, currently only used
            to identify who drew menu text, that needs removing from the pending list
            </summary>
        </member>
        <member name="M:Engine.Menu.#ctor">
            <summary>
            Constructor for Menu, to define a sprite menu
            </summary>
            <remarks>This is retained for back compatability but will be depreciated</remarks>
        </member>
        <member name="M:Engine.Menu.#ctor(System.String,Engine.MenuType)">
            <summary>
            Constructor accepts a trackBank object so tracks can be assigned to menu items
            and the marker if present
            </summary>
            <param name="debugName">the name to give to the menu, the one to be used to access it later</param>
            <param name="type">Whether you want a sprite or text menu</param>
        </member>
        <member name="M:Engine.Menu.CleanUp">
            <summary>
            overridable called when a menu is removed
            add code to remove/kill any other resources managed by the menu (helper/friend sprites, events etc...)
            if you don't they could still be active
            </summary>
        </member>
        <member name="P:Engine.Menu.ShowAll">
            <summary>
            gets or sets the value of the ShowAll state
            </summary>
            <remarks>Set to false to enable only selected item to be seen, this is useful
            if you want to place all menu items on top of each for simple selection</remarks>
        </member>
        <member name="M:Engine.Menu.WrapYes">
            <summary>
            Makes menu selection go back to the start when Next or Previous used
            </summary>
        </member>
        <member name="M:Engine.Menu.WrapNo">
            Makes menu stop at Start or End when Next or Previous used
        </member>
        <member name="M:Engine.Menu.ItemsShowAll">
            <summary>
            ensures all menu items are visible (use select and deselect handlers to highlight
            current selection or use a tag
            </summary>
        </member>
        <member name="M:Engine.Menu.ItemsShowSelectedOnly">
            <summary>
            ensures only selecte menu item is visible no select deselect handlers are necessary
            </summary>
        </member>
        <member name="P:Engine.Menu.SelectionMode">
            <summary>
            Specifies the way in which menu items are selected
            </summary>
        </member>
        <member name="M:Engine.Menu.TagMakeSelection(Engine.MenuTag,System.Int32)">
            <summary>
            Makes the selected item that which is at the same track position as the tag
            </summary>
            <param name="tag">The menuTag to use with the menu</param>
            <param name="trackPosition">The track position for the tag</param>
        </member>
        <member name="M:Engine.Menu.TagFollowSelection(Engine.MenuTag)">
            <summary>
            makes the tag move to the currently selected menu item using the given alignment
            </summary>
            <param name="tag">The menu tag object to use with the menu</param>
        </member>
        <member name="M:Engine.Menu.AlignTag(Engine.Align)">
            <summary>
            Specifies the alignment mode for the menus tag
            </summary>
            <param name="alignment">The alignment mode to use</param>
        </member>
        <member name="P:Engine.Menu.TagZDifference">
            <summary>
            gets or sets the tags Zdifference, which by default is -1.
            If negative the tag will appear behind the menu sprite
            If positive the tag will appear in front of the menu sprite
            </summary>
        </member>
        <member name="M:Engine.Menu.TagSetTrackPosition(System.Int32)">
            <summary>
            Moves the tag to the specified track position
            </summary>
            <param name="position"></param>
        </member>
        <member name="P:Engine.Menu.Selected">
            <summary>
            gets the index of the currently selected item
            </summary>
        </member>
        <member name="P:Engine.Menu.SelectedName">
            <summary>
            gets the name of the currently selected menu item
            </summary>
        </member>
        <member name="P:Engine.Menu.SelectedMenuItem">
            <summary>
            Retrieves the currently selected menu item
            </summary>
            <value>Will be set to null if no menu item selected</value>
        </member>
        <member name="M:Engine.Menu.GetNamedItemIndex(System.String)">
            <summary>
            returns the index of the named MenuItem
            </summary>
            <param name="name">the name to search for</param>
            <returns>the index of the item</returns>
        </member>
        <member name="P:Engine.Menu.SelectedSprite">
            <summary>
            gets the sprite currently selected
            </summary>
        </member>
        <member name="P:Engine.Menu.Count">
            <summary>
            gets the number of items in the menu
            </summary>
        </member>
        <member name="M:Engine.Menu.RefreshDisplay2">
            <summary>
            Updates the menu display making sure any highlighting is appropriate
            </summary>
        </member>
        <member name="M:Engine.Menu.Next">
            <summary>
            Selects the next item in the menu
            </summary>
        </member>
        <member name="M:Engine.Menu.Next(System.Int32)">
            <summary>
            Selects the item further down the list by the step given
            </summary>
            <param name="step">The number of items along the list to go</param>
            <remarks>Can be used to implement moving up and down in a tabular menu list</remarks>
        </member>
        <member name="M:Engine.Menu.Previous">
            <summary>
            selects the previous item in the menu
            </summary>
        </member>
        <member name="M:Engine.Menu.Previous(System.Int32)">
            <summary>
            Selects the item further up the list by the step given
            </summary>
            <param name="step">The number of items along the list to go</param>
            <remarks>Can be used to implement moving up and down in a tabular menu list</remarks>
        </member>
        <member name="M:Engine.Menu.SelectItem(Engine.MenuItem)">
            <summary>
            Select the given menuItem
            </summary>
            <param name="menuItem">The menu item which is part of this menu</param>
        </member>
        <member name="M:Engine.Menu.SelectItem(System.Int32)">
            <summary>
            selects a specific item in the menu
            </summary>
            <param name="thisPosition">The position in the list of menu items to select</param>
        </member>
        <member name="M:Engine.Menu.SelectItem(System.String)">
            <summary>
            Selects the named menu item
            </summary>
            <param name="name">The name of the menu item</param>
        </member>
        <member name="M:Engine.Menu.SelectItemTrack(Engine.MenuItem,System.Int32)">
            <summary>
            Selects the menu item on a track advancing menu
            </summary>
            <param name="menuItem">The menu item which is part of this menu</param>
            <param name="stepspeed">how quick to make the steps towards item</param>
        </member>
        <member name="M:Engine.Menu.SelectItemTrack(System.String,System.Int32)">
            <summary>
            Selects the named menu item on a track advancing menu
            </summary>
            <param name="name">the name of the item we want to select</param>
            <param name="stepspeed">how quick to make the steps towards item</param>
        </member>
        <member name="M:Engine.Menu.SelectItemTrack(System.Int32,System.Int32)">
            <summary>
            Selects the named menu item on a track advancing menu
            </summary>
            <param name="thisPosition">the index of the item we want to select</param>
            <param name="stepspeed">how quick to make the steps towards item</param>
        </member>
        <member name="M:Engine.Menu.JigSpacers(System.Int32,System.Int32)">
            <summary>
            This is not working properly
            </summary>
            <param name="distance">The total number of points to distribute over</param>
            <param name="step">The number of points to skip for each menu item</param>
            <returns></returns>
        </member>
        <member name="M:Engine.Menu.TrackAndSpacing(Engine.TrackDefinition,System.Int32)">
            <summary>
            Specifies the positions the menu items should be placed at
            </summary>
            <param name="trackToFollow">The track to use</param>
            <param name="offset">The distance along the track to place each menu item (starts at 0)</param>
        </member>
        <member name="M:Engine.Menu.TrackResetPositions">
            <summary>
            Resets a track based menu to its original positions
            </summary>
        </member>
        <member name="M:Engine.Menu.TrackAdvanceAutoMenuItems(System.Int32,System.Int32)">
            <summary>
            Advance all menu items along a track moving a fixed number of menu items before stopping
            </summary>
            <param name="stepAmount">Number of track positions to move during each advance</param>
            <param name="menuPositions">The number of menu items to scroll through before stopping</param>
        </member>
        <member name="M:Engine.Menu.TrackRewindAutoMenuItems(System.Int32,System.Int32)">
            <summary>
            Rewinds all menu items along a track moving a fixed number of menu items before stopping
            </summary>
            <param name="stepAmount">Number of track positions to move during each advance</param>
            <param name="menuPositions">The number of menu items to scroll through before stopping</param>
        </member>
        <member name="M:Engine.Menu.TrackAdvanceAuto(System.Int32,System.Int32)">
            <summary>
            Advances all menu items along a track for a specified number of track positions
            </summary>
            <param name="stepAmount">The number of track positions to move during each update</param>
            <param name="distanceToMove">The total number of track positions to move before stopping</param>
            <remarks>This can be used to smoothly moving a rolling selection, such as a character display
            if you have created a track with lots of positions</remarks>
        </member>
        <member name="M:Engine.Menu.TrackAdvanceAuto(System.Int32)">
            <summary>
            Advances all menu items along the track with the step given, for one item position
            </summary>
            <param name="stepAmount">The number of track positions to move in go</param>
        </member>
        <member name="M:Engine.Menu.TagNext">
            <summary>
            Moves the tag to the next menu item position along the track
            </summary>
        </member>
        <member name="M:Engine.Menu.TagPrevious">
            <summary>
            TODO:
            </summary>
        </member>
        <member name="M:Engine.Menu.UnifyStep(System.Int32,System.Int32)">
            <summary>
            Another version of JigSpacers
            </summary>
            <param name="distance">number of points in track</param>
            <param name="step">step distance for each menu item</param>
            <returns>the stepping distance</returns>
        </member>
        <member name="M:Engine.Menu.TrackRewindAuto(System.Int32,System.Int32)">
            <summary>
            Rewinds all menu items along a track for a specified number of track positions
            </summary>
            <param name="stepAmount">The number of track positions to move during each update</param>
            <param name="distanceToMove">The total number of track positions to move before stopping</param>
            <remarks>This can be used to smoothly moving a rolling selection, such as a character display
            if you have created a track with lots of positions</remarks>
        </member>
        <member name="M:Engine.Menu.TrackRewindAuto(System.Int32)">
            <summary>
            Rewinds all menu items along the track with the step given, for one item position
            </summary>
            <param name="stepAmount">The number of track positions to move in go</param>
        </member>
        <member name="M:Engine.Menu.TrackAdvance(System.Int32)">
            <summary>
            moves all menu items along the track the specified track positions
            </summary>
            <param name="stepAmount">number of track positions to move</param>
            <remarks>This is most useful for menus that use fixed point tracks</remarks>
        </member>
        <member name="M:Engine.Menu.TrackAdvance">
            <summary>
            moves all items along the track by the offset distance
            </summary>
        </member>
        <member name="M:Engine.Menu.TrackRewind(System.Int32)">
            <summary>
            moves all menu items backwards along the track the specified track positions
            </summary>
            <param name="stepAmount">number of track positions to move</param>
            <remarks>This is most useful for menus that use fixed point tracks</remarks>
        </member>
        <member name="M:Engine.Menu.TrackRewind">
            <summary>
            moves all menu items backwards along the track by the offset amount
            </summary>
        </member>
        <member name="M:Engine.Menu.AddItem(Engine.MenuItem)">
            <summary>
            Adds a menuItem to the menu
            </summary>
            <param name="newItem">the menuItem already defined</param>
        </member>
        <member name="M:Engine.Menu.AddListOfSprites(System.Collections.Generic.List{Engine.Sprite})">
            <summary>
            Adds a list of sprites to a menu such as an alphabet list
            </summary>
            <param name="sl">The list containing the prepared sprites to use.
            The StorageText property of each sprite must contain the name of the menu item</param>
        </member>
        <member name="F:Engine.Menu.adds">
            <summary>
            keeps track of the number of times the sprites managed have been added to the engine
            </summary>
        </member>
        <member name="M:Engine.Menu.Show">
            <summary>
            Makes the engine manager show the menu
            </summary>
        </member>
        <member name="M:Engine.Menu.Hide">
            <summary>
            Removes menu items from the game manager
            </summary>
        </member>
        <member name="M:Engine.Menu.RefreshTextDisplay">
            <summary>
            Sets up the display data for all the text elements of the menu
            </summary>
        </member>
        <member name="T:Engine.MenuItem">
            <summary>
            Represents an individual item in a menu
            </summary>
        </member>
        <member name="F:Engine.MenuItem.SelectedAnimationRange">
            <summary>
            holds the animation range for the item when selected
            </summary>
        </member>
        <member name="F:Engine.MenuItem.NormalAnimationRange">
            <summary>
            the de-selected animation range
            </summary>
        </member>
        <member name="F:Engine.MenuItem.boss">
            <summary>
            The sprite for this menu item (if a sprite one)
            </summary>
        </member>
        <member name="F:Engine.MenuItem.Selected">
            <summary>
            An indicator stating whether this menu item is currently selected
            </summary>
        </member>
        <member name="F:Engine.MenuItem.Name">
            <summary>
            the debug name used for this menu item
            </summary>
        </member>
        <member name="F:Engine.MenuItem.MenuText">
            <summary>
            the textstore object that defines the text and its properties
            for a text based menu item
            </summary>
        </member>
        <member name="F:Engine.MenuItem.id">
            <summary>
            holds the internal placement of this item in its associated menu
            allocated when added to the menu
            </summary>
        </member>
        <member name="M:Engine.MenuItem.#ctor(System.String,Engine.TextStore)">
            <summary>
            creates a text based menu item
            </summary>
            <param name="debugName">The name to assign the this menu item</param>
            <param name="menuTextToUse">The TextStore object that defines the text and how to display it</param>
            <remarks>Use the TextGetMenuText() method of the EngineManager to generate the TextStore object</remarks>
        </member>
        <member name="M:Engine.MenuItem.#ctor(System.String,Engine.Sprite)">
            <summary>
            Specifies a static menu item, with no animation consisting of a single frame
            </summary>
            <param name="debugName">The name to give the menu item</param>
            <param name="menuSprite">The Sprite to display for this menu item</param>
        </member>
        <member name="M:Engine.MenuItem.#ctor(System.String,Engine.Sprite,System.Int32,System.Int32)">
            <summary>
            Specifies a menu item with a selected and unselected frame
            </summary>
            <param name="debugName">The name to give the menu item</param>
            <param name="menuSprite">The Sprite to display for this menu item</param>
            <param name="frameNormal">The frame to display when not selected</param>
            <param name="frameSelected">The frame to display when selected</param>
        </member>
        <member name="M:Engine.MenuItem.#ctor(System.String,Engine.Sprite,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Specifies a menu item which animates when selected or not
            </summary>
            <param name="debugName">The name to be given to the menu</param>
            <param name="menuSprite">The Sprite to display for this menu item</param>
            <param name="firstFrameNormal">The first animation frame when the not selected</param>
            <param name="lastFrameNormal">The last animation frame when not selected</param>
            <param name="firstFrameSelected">The first animation frame when selected</param>
            <param name="lastFrameSelected">The last animation frame when selelcted</param>
        </member>
        <member name="M:Engine.MenuItem.Select">
            <summary>
            Selects the menu option
            </summary>
        </member>
        <member name="M:Engine.MenuItem.Deselect(System.Boolean)">
            <summary>
            un selects the menu option
            </summary>
            <param name="show">states whether item should be displayed when deselected</param>
        </member>
        <member name="T:Engine.MenuManager">
            <summary>
            Manages all the menus ensuring they are updated properly
            </summary>
        </member>
        <member name="F:Engine.MenuManager.Menus">
            <summary>
            holds all the menus defined in the system
            </summary>
        </member>
        <member name="F:Engine.MenuManager.engine">
            <summary>
            reference to the engine manager
            </summary>
        </member>
        <member name="F:Engine.MenuManager.text">
            <summary>
            reference to the text manager
            </summary>
        </member>
        <member name="M:Engine.MenuManager.#ctor(Microsoft.Xna.Framework.Game,Engine.TextManager)">
            <summary>
            Creates a menu manager giving it access the EngineManager
            </summary>
            <param name="tm">The games TextManager</param>
            <param name="game">The game object</param>
        </member>
        <member name="M:Engine.MenuManager.RemoveMenu(Engine.Menu)">
            <summary>
            Removes a menu from the menu managers list
            </summary>
            <param name="thisMenu">the menu to remove from the manager</param>
        </member>
        <member name="M:Engine.MenuManager.RemoveAllMenus">
            <summary>
            removes any menus the manager is handling
            </summary>
        </member>
        <member name="M:Engine.MenuManager.Exists(Engine.Menu)">
            <summary>
            determines if a menu is currently being managed
            </summary>
            <param name="thisMenu"></param>
            <returns></returns>
        </member>
        <member name="M:Engine.MenuManager.AddMenu(Engine.Menu)">
            <summary>
            Adds a menu to the menu manager
            </summary>
            <param name="newMenu">makes the menu manager aware of a new menu</param>
        </member>
        <member name="F:Engine.MenuManager.RemoveDuplicates">
            <summary>
            forces duplicate menu defintions to be handled automatically - default is true
            not public at the moment
            </summary>
        </member>
        <member name="M:Engine.MenuManager.Initialize">
            <summary>
            Allows the game component to perform any initialization it needs to before starting
            to run.  This is where it can query for any required services and load content.
            </summary>
        </member>
        <member name="M:Engine.MenuManager.Update(Microsoft.Xna.Framework.GameTime)">
            <summary>
            Allows the game component to update itself.
            </summary>
            <param name="gameTime">Provides a snapshot of timing values.</param>
        </member>
        <member name="M:Engine.MenuManager.HideAll">
            <summary>
            Hides all currently defined menus
            </summary>
        </member>
        <member name="T:Engine.MenuTag">
            <summary>
            represents a sprite used to indicate an option selected
            </summary>
        </member>
        <member name="F:Engine.MenuTag.TrackPositionStart">
            <summary>
            records the initial starting position for tag and all items along
            the track
            </summary>
        </member>
        <member name="F:Engine.MenuTag.boss">
            <summary>
            a reference to the sprite which defines the tag
            </summary>
        </member>
        <member name="F:Engine.MenuTag.Align">
            <summary>
            alignment in relation to current selection (if not using a track)
            </summary>
        </member>
        <member name="F:Engine.MenuTag.ZDifference">
            <summary>
            Specify an additional layer depth to place on tag sprite
            </summary>
        </member>
        <member name="F:Engine.MenuTag.DisplayMode">
            <summary>
            specifies how the tag should be displayed
            </summary>
        </member>
        <member name="M:Engine.MenuTag.#ctor(Engine.Sprite,Engine.Align)">
            <summary>
            Creates a menu tag using the given sprite and alignment
            </summary>
            <param name="thisMarker">the sprite to use as the tag</param>
            <param name="alignment">the alignment mode to use</param>
        </member>
        <member name="M:Engine.MenuTag.#ctor">
            <summary>
            builds an empty menutag ready for you to set the boss and alignment properties manually
            </summary>
        </member>
        <member name="T:Engine.MessageType">
            <summary>
            A class of basic message types, you can add to this by creating your own class and inheriting MessageType
            you can then add a new member with the following code
            <code>public static readonly MessageType MySuperDuperMessageType = new MessageType();</code>
            </summary>
        </member>
        <member name="F:Engine.MessageType.Name">
            <summary>
            name displayed during debugging
            </summary>
        </member>
        <member name="M:Engine.MessageType.#ctor(System.String)">
            <summary>
            creates a new message type and sets a debugging title
            </summary>
            <param name="name">The name to display when debugging is active for messages</param>
        </member>
        <member name="M:Engine.MessageType.#ctor">
            <summary>
            creates a new message without a debug title
            </summary>
        </member>
        <member name="F:Engine.MessageType.NONE">
            <summary>
            no message ??
            </summary>
        </member>
        <member name="F:Engine.MessageType.LevelStart">
            <summary>
            Level has started (you can use this to mean anything)
            </summary>
        </member>
        <member name="F:Engine.MessageType.LevelEnd">
            <summary>
            Level has ended
            </summary>
        </member>
        <member name="F:Engine.MessageType.PlayerPosition">
            <summary>
            player position is being broadcast
            </summary>
        </member>
        <member name="F:Engine.MessageType.Timer">
            <summary>
            Timer information is available
            </summary>
        </member>
        <member name="F:Engine.MessageType.Goal">
            <summary>
            reached a goal
            </summary>
        </member>
        <member name="T:Engine.Message">
            <summary>
            defines a message to be sent and consumed
            </summary>
        </member>
        <member name="F:Engine.Message.Type">
            <summary>
            the type of message being sent
            </summary>
        </member>
        <member name="F:Engine.Message.IntValue">
            <summary>
            an integer value
            </summary>
        </member>
        <member name="F:Engine.Message.FloatValue">
            <summary>
            a real number value
            </summary>
        </member>
        <member name="F:Engine.Message.Vector3Value">
            <summary>
            a vector 3 value
            </summary>
        </member>
        <member name="F:Engine.Message.Vector2Value">
            <summary>
            a vector 2 value
            </summary>
        </member>
        <member name="F:Engine.Message.ObjectValue">
            <summary>
            any object can be placed inside this the handler needs to be aware of what to cast the object to to access the message data
            </summary>
        </member>
        <member name="F:Engine.Message.StringValue">
            <summary>
            a string value
            </summary>
        </member>
        <member name="T:Engine.MessageHandler">
            <summary>
            defines a method that will accept a message that on object has subscribed to
            </summary>
            <param name="message">the message information that was subscribed to</param>
        </member>
        <member name="T:Engine.MessageSubscriber">
            <summary>
            holds message subscription information
            </summary>
        </member>
        <member name="F:Engine.MessageSubscriber.MessageTypes">
            <summary>
            a list of message types that this subscriber wishes to listen out for
            </summary>
        </member>
        <member name="F:Engine.MessageSubscriber.Handler">
            <summary>
            the method that will be invoked (called) when one of the messagetypes stated is broadcast
            </summary>
        </member>
        <member name="T:Engine.MessageBus">
            <summary>
            broadcasting system for message
            </summary>
        </member>
        <member name="F:Engine.MessageBus.instance">
            <summary>
            holds the singleton instance of the messagebus object
            </summary>
        </member>
        <member name="P:Engine.MessageBus.Instance">
            <summary>
            use MessageBus.Instance to access the methods of MessageBus
            </summary>
        </member>
        <member name="M:Engine.MessageBus.#ctor">
            <summary>
            private constructor as we have created a singleton
            </summary>
        </member>
        <member name="F:Engine.MessageBus.subscriberLists">
            <summary>
            holds the lists of subscribers
            </summary>
        </member>
        <member name="M:Engine.MessageBus.Unsubscribe">
            <summary>
            removes all message subscribers
            </summary>
        </member>
        <member name="M:Engine.MessageBus.Unsubscribe(Engine.MessageType)">
            <summary>
            remove any subscriptions for a particular messagetype
            </summary>
            <param name="messageType">type of message to remove subscribers of</param>
        </member>
        <member name="M:Engine.MessageBus.Unsubscribe(Engine.MessageType,Engine.MessageHandler)">
            <summary>
            Unsubscribe a handler from a message type
            </summary>
            <param name="messageType">messagetype to drop subscription from</param>
            <param name="handler">handler to remove from listening list</param>
        </member>
        <member name="M:Engine.MessageBus.Unsubscribe(Engine.MessageSubscriber)">
            <summary>
            unsubscribe a messagesubscriber from it's defined subscriptions
            </summary>
            <param name="subscriber">The message subscription information to remove</param>
        </member>
        <member name="M:Engine.MessageBus.Subscribe(Engine.MessageSubscriber)">
            <summary>
            Setup a subscription to multiple messages using a messageSubscriber object
            </summary>
            <param name="subscriber">the message subscription information</param>
        </member>
        <member name="M:Engine.MessageBus.Subscribe(Engine.MessageType,Engine.MessageHandler)">
            <summary>
            setup a subscription to a single messagetype
            </summary>
            <param name="messageType">the messagetype to subscribe to</param>
            <param name="handler">the method which will process the message</param>
        </member>
        <member name="M:Engine.MessageBus.BroadcastMessage(Engine.Message)">
            <summary>
            allow any object to send a message to anyone who's subscribed to this message type
            MessageBus.Instance.SendMessage(message)
            </summary>
            <param name="message">Message data to broadcast</param>
        </member>
        <member name="M:Engine.MessageBus.BroadcastMessage(Engine.MessageType,System.Object)">
            <summary>
            quick and easy broadcast a message of a particular type with an object value
            </summary>
            <param name="type">Type of message to broadcast</param>
            <param name="data">data to transmit - subscribers will need to cast this to the correct type in order to access it</param>
        </member>
        <member name="M:Engine.MessageBus.BroadcastMessage(Engine.MessageType)">
            <summary>
            Broadcasts a message with no content
            </summary>
            <param name="type">The type of message to broadcast</param>
        </member>
        <member name="M:Engine.MessageBus.Subscriptions(System.String)">
            <summary>
            provides a text formatted list of all subscriptions with your delimeter as a separator between each
            </summary>
            <param name="delimeter">string to place between each subscription (use ~ for new line in my engine)</param>
            <returns>formatted subscriptions</returns>
        </member>
        <member name="M:Engine.MessageBus.Subscriptions(Engine.MessageType)">
            <summary>
            provides a text formatted list of a specific message type, with your delimeter as a separator between each
            </summary>
            <param name="type">type of message to retrieve subscriptions for</param>
            <returns>formatted subscriptions</returns>
        </member>
        <member name="T:Engine.Neighbour">
            <summary>
            holds a node and its distance from its parent/neighbour
            </summary>
        </member>
        <member name="P:Engine.Neighbour.Node">
            <summary>
            the node representing this neighbour
            </summary>
        </member>
        <member name="P:Engine.Neighbour.Distance">
            <summary>
            distance of this node from it's neighbour
            </summary>
        </member>
        <member name="M:Engine.Neighbour.#ctor(Engine.NetworkNode,System.Int32)">
            <summary>
            adds a neighbour to the node
            </summary>
            <param name="node">Node which is a neighbour</param>
            <param name="distance">distance from its neighbour</param>
        </member>
        <member name="T:Engine.NetworkNode">
            <summary>
            a node that has a list of references to neighbour nodes and a parent node
            </summary>
        </member>
        <member name="P:Engine.NetworkNode.Parent">
            <summary>
            gets or sets the node travelled to get to this node
            </summary>
        </member>
        <member name="P:Engine.NetworkNode.Cost">
            <summary>
            cost to get to node from current parent, defaulted to largest value
            </summary>
        </member>
        <member name="P:Engine.NetworkNode.hCost">
            <summary>
            the Heuristic cost for this node if in an A* network
            </summary>
        </member>
        <member name="P:Engine.NetworkNode.fCost">
            <summary>
            the Full cost for this node if in an A* network
            </summary>
        </member>
        <member name="P:Engine.NetworkNode.Name">
            <summary>
            gets or sets the name of the node
            </summary>
        </member>
        <member name="F:Engine.NetworkNode.Neighbours">
            <summary>
            a list of the neighbours
            </summary>
        </member>
        <member name="M:Engine.NetworkNode.#ctor(System.String)">
            <summary>
            creates a node in the network
            </summary>
            <param name="name">The display name to gove to this node</param>
        </member>
        <member name="M:Engine.NetworkNode.#ctor">
            <summary>
            constructor
            </summary>
        </member>
        <member name="T:Engine.OwnerInfo">
            <summary>
            holds owner inforation to be associate with Lines
            This could be used for your own purposes for specific sprite associations.
            </summary>
        </member>
        <member name="P:Engine.OwnerInfo.KeyId">
            <summary>
            the id (sprite id or other unique reference)
            </summary>
        </member>
        <member name="P:Engine.OwnerInfo.IdReference">
            <summary>
            a numeric main reference to be used in reference to the Associated object
            </summary>
        </member>
        <member name="P:Engine.OwnerInfo.IdSubReference">
            <summary>
            a sub reference id to be used to associate with the associated object
            </summary>
        </member>
        <member name="M:Engine.OwnerInfo.#ctor">
            <summary>
            default constructor set null or -1 for attributes
            </summary>
        </member>
        <member name="M:Engine.OwnerInfo.#ctor(System.Int32)">
            <summary>
            specified
            </summary>
            <param name="key">The  key to associate as the owner</param>
        </member>
        <member name="M:Engine.OwnerInfo.#ctor(System.Int32,System.Int32)">
            <summary>
            specified
            </summary>
            <param name="key">The  key to associate as the owner</param>
            <param name="idReference">A number to be associated with the owner object</param>
        </member>
        <member name="M:Engine.OwnerInfo.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            specified
            </summary>
            <param name="key">The  key to associate as the owner</param>
            <param name="idReference">A number to be associated with the owner object</param>
            <param name="idSubReference">A secondary number to be associated with the owner object</param>
        </member>
        <member name="T:Engine.Particle">
            <summary>
            defines a particle for special effects rendering
            You must specifiy a texture at least
            </summary>
        </member>
        <member name="F:Engine.Particle.col">
            <summary>
            color tint to apply to particle when rendered - default is White
            </summary>
        </member>
        <member name="F:Engine.Particle.pos">
            <summary>
            position to render the particle
            </summary>
        </member>
        <member name="F:Engine.Particle.tex">
            <summary>
            the texture to draw for this particle - will crash if not set
            </summary>
        </member>
        <member name="F:Engine.Particle.portion">
            <summary>
            the portion of the texture tex to draw - default is Rectangle(0,0,1,1)
            </summary>
        </member>
        <member name="F:Engine.Particle.z">
            <summary>
            a z value for the particle this is used for ordering purposes when rendered -10000, +10000, default is 1
            </summary>
        </member>
        <member name="F:Engine.Particle.rot">
            <summary>
            rotation angle to draw texture at - default is 0
            </summary>
        </member>
        <member name="F:Engine.Particle.origin">
            <summary>
            rotation origin of the sprite - defaults to 0,0 - topleft corner of particle
            </summary>
        </member>
        <member name="F:Engine.Particle.effect">
            <summary>
            sprite effect to apply to the particle - default is NONE
            </summary>
        </member>
        <member name="F:Engine.Particle.scale">
            <summary>
            scale factor to apply to particle in x and y directions - default is 1,1
            </summary>
        </member>
        <member name="F:Engine.Particle.alive">
            <summary>
            if true then particle will be rendered if false skipped - default is false
            </summary>
        </member>
        <member name="F:Engine.Particle.lifetime">
            <summary>
            a place to store how many seconds a particle has been alive - you need to update this value yourself using EventManager.period
            </summary>
        </member>
        <member name="F:Engine.Particle.deathtime">
            <summary>
            place to store time period before particle is to be stopped or removed - you need to code this action yourself
            </summary>
        </member>
        <member name="T:Engine.ParticleSet">
            <summary>
            holds render information about a list of particles
            You need to provide code to manipulate the particles in the class that inherits this one
            </summary>
        </member>
        <member name="F:Engine.ParticleSet.particles">
            <summary>
            array of particles to render, you need to provide this in your constructor
            </summary>
        </member>
        <member name="P:Engine.ParticleSet.Particles">
            <summary>
            array of particles to render, you need to provide this in your constructor
            </summary>
        </member>
        <member name="F:Engine.ParticleSet.ProcessingLength">
            <summary>
            holds the number of particles to process in the list
            this by default is set to the entire length of the list if you don't specify its value during construction
            The renderer will look through as many items as you specify looking for Alive particles to draw,
            you can reduce the overheads of this if you shuffle your arrays removing dead particles
            </summary>
        </member>
        <member name="F:Engine.ParticleSet.layer">
            <summary>
            layer these particles are to be rendered on - default is spriteZero
            </summary>
        </member>
        <member name="F:Engine.ParticleSet.ID">
            <summary>
            the ID of this particle set
            </summary>
        </member>
        <member name="F:Engine.ParticleSet.worldCoordinates">
            <summary>
            specficies that all these particles used world cordinates or viewport ones - default is world (true)
            </summary>
        </member>
        <member name="F:Engine.ParticleSet.IDCount">
            <summary>
            holds an incrementing value for ID's to be automatically set
            </summary>
        </member>
        <member name="M:Engine.ParticleSet.#ctor">
            <summary>
            creates the most basic particle set with a unique ID
            </summary>
        </member>
        <member name="M:Engine.ParticleSet.FreeResources">
            <summary>
            place all your resource freeing code into this method, such as timers, events, and other helper objects
            You have to implement this method so the engine can ensure your resources are cleared when it removes the particle set
            </summary>
        </member>
        <member name="T:Engine.PlayerView">
            <summary>
            holds a player view of the world including their viewport rendering info
            </summary>
        </member>
        <member name="M:Engine.PlayerView.ToString">
            <summary>
            text formatted information about the viewport
            </summary>
            <returns></returns>
        </member>
        <member name="F:Engine.PlayerView.Name">
            <summary>
            a name to associate the the PlayerView
            </summary>
        </member>
        <member name="F:Engine.PlayerView.renderProperties">
            <summary>
            the viewports renderproperties if the matrix is set then this will override any tilemap
            or sprite layer matrix properties (allowing generic scaling of the stuff)
            only scaling applies
            </summary>
        </member>
        <member name="F:Engine.PlayerView.focalLength">
            <summary>
            the focal length for perspective projection
            </summary>
        </member>
        <member name="F:Engine.PlayerView.defaultScalePP">
            <summary>
            holds the scale adjustment factor when perspective projecting, default is 1
            </summary>
        </member>
        <member name="P:Engine.PlayerView.viewport">
            <summary>
            gets or sets the portion of the render viewport dimensions and properties for this player view
            </summary>
        </member>
        <member name="F:Engine.PlayerView.Clamp">
            <summary>
            if true forces viewport position to stay within the world dimensions set in the EngineManager
            if you change it false you will have to ensure you correct other effects yourself
            </summary>
        </member>
        <member name="F:Engine.PlayerView.position">
            <summary>
            gets or sets the viewposition in relation to the world
            </summary>
        </member>
        <member name="P:Engine.PlayerView.AtBottom">
            <summary>
            determines if the viewport is at the bottom of the world
            </summary>
        </member>
        <member name="P:Engine.PlayerView.AtTop">
            <summary>
            determines if the viewport is at the top of the world ma
            </summary>
        </member>
        <member name="P:Engine.PlayerView.AtRight">
            <summary>
            determines if the viewport is at the right of the world
            </summary>
        </member>
        <member name="P:Engine.PlayerView.AtLeft">
            <summary>
            determines if the viewport is at the left of the world ma
            </summary>
        </member>
        <member name="P:Engine.PlayerView.Position">
            <summary>
            gets or sets the viewposition in relation to the world. If Clamp is true the viewport will not be allowed to leave the dimensions of the world
            </summary>
        </member>
        <member name="P:Engine.PlayerView.Position2D">
            <summary>
            gets or sets the viewposition in relation to the world. If Clamp is true the viewport will not be allowed to leave the dimensions of the world
            </summary>
        </member>
        <member name="P:Engine.PlayerView.X">
            <summary>
            gets or sets the X position of the viewport
            </summary>
        </member>
        <member name="P:Engine.PlayerView.Width">
            <summary>
            gets the width of the viewport
            </summary>
        </member>
        <member name="P:Engine.PlayerView.Height">
            <summary>
            gets the height of the viewport
            </summary>
        </member>
        <member name="P:Engine.PlayerView.Y">
            <summary>
            gets or sets the Y position of the viewport
            </summary>
        </member>
        <member name="F:Engine.PlayerView._viewerPosition">
            <summary>
            the viewers position used for projection and 
            </summary>
        </member>
        <member name="P:Engine.PlayerView.ViewPortOutline">
            <summary>
            returns a rectangle representing the world view of the viewport
            </summary>
        </member>
        <member name="F:Engine.PlayerView._viewPortOutlinePreCalc">
            <summary>
            holds the calculated viewport outline so we only work it out when it moves
            </summary>
        </member>
        <member name="M:Engine.PlayerView.CalcVPOutline">
            <summary>
            pre-calculates viewport outline, so we don't keep doing it every test for the outline
            </summary>
        </member>
        <member name="F:Engine.PlayerView._mySides">
            <summary>
            storage for scratch side work for InView
            </summary>
        </member>
        <member name="M:Engine.PlayerView.InView(Engine.Sprite)">
            <summary>
            determines if the given sprite is partially inside the viewport
            </summary>
            <param name="s">The sprite to determine visibility</param>
            <returns>True is partially visible, false otherwise</returns>
        </member>
        <member name="M:Engine.PlayerView.InView(Microsoft.Xna.Framework.Vector4,System.Boolean)">
            <summary>
            determines if the given sides are partially inside the viewport
            </summary>
            <param name="sides">The Sides (Vector4) to determine visibility with</param>
            <param name="worldCoordinates">The coordinate mode to apply, world is true viewport is false</param>
            <returns>True is partially visible, false otherwise</returns>
        </member>
        <member name="M:Engine.PlayerView.InView(Microsoft.Xna.Framework.Rectangle,System.Boolean)">
            <summary>
            determines if the given rect is partially inside the viewport
            </summary>
            <param name="rect">The rectangle to determine visibility</param>
            <param name="worldCoordinates">The coordinate mode to apply, world is true viewport is false</param>
            <returns>True is partially visible, false otherwise</returns>
        </member>
        <member name="F:Engine.PlayerView._worldAnchor">
            <summary>
            holds the anchor statement
            </summary>
        </member>
        <member name="P:Engine.PlayerView.WorldAnchor">
            <summary>
            determines if the viewport is fixed to the world layout or is acting as on overlay 
            to the world
            </summary>
        </member>
        <member name="P:Engine.PlayerView.ViewerPosition">
            <summary>
            gets or sets the viewposition. If ViewPositionManual is false the centre of the viewport is used
            othewise the viewerPosition set is retrieved 
            </summary>
        </member>
        <member name="F:Engine.PlayerView.ViewerPositionManual">
            <summary>
            Specifies how the viewers position is calculated
            If true you need to manually set the position of the ViewPosition
            </summary>
        </member>
        <member name="M:Engine.PlayerView.#ctor(Microsoft.Xna.Framework.Graphics.Viewport,System.Single,System.Single,System.String)">
            <summary>
            Creates a new player viewport
            </summary>
            <param name="viewport">The viewport settings</param>
            <param name="xStart">The left hand position of the viewport in the world</param>
            <param name="yStart">The top hand position of the viewport in the world</param>
            <param name="name">Name to associate with viewport</param>
        </member>
        <member name="M:Engine.PlayerView.#ctor(Microsoft.Xna.Framework.Graphics.Viewport,System.Single,System.Single)">
            <summary>
            Creates a new player viewport
            </summary>
            <param name="viewport">The viewport settings</param>
            <param name="xStart">The left hand position of the viewport in the world</param>
            <param name="yStart">The top hand position of the viewport in the world</param>
        </member>
        <member name="M:Engine.PlayerView.#ctor(Microsoft.Xna.Framework.Graphics.Viewport)">
            <summary>
            Create a new player viewport, positioned at the top left hand corner of the world
            Use this constructor when you are going to be moving the viewport position automatically
            </summary>
            <param name="viewport">viewport settings</param>
        </member>
        <member name="M:Engine.PlayerView.#ctor(Microsoft.Xna.Framework.Graphics.Viewport,System.String)">
            <summary>
            Create a new player viewport, positioned at the top left hand corner of the world
            Use this constructor when you are going to be moving the viewport position automatically
            </summary>
            <param name="viewport">viewport settings</param>
            <param name="name">Name to associate with viewport</param>
        </member>
        <member name="P:Engine.PlayerView.Bounds">
            <summary>
            gets the rectangle of the viewport (simpler than saying viewport.Bounds)
            useful to get hold of centre, left, right, top and bottom positions of 
            </summary>
        </member>
        <member name="P:Engine.PlayerView.Centre2D">
            <summary>
            gets the centre of the viewport as a vector2 value
            </summary>
        </member>
        <member name="M:Engine.PlayerView.ViewportFull(Microsoft.Xna.Framework.Rectangle,System.String)">
            <summary>
            returns a PlayerView of the given region
            </summary>
            <param name="region">The area of the viewport</param>
            <returns>list containing one full region player view</returns>
            <param name="name">Name to associate with Viewport</param>
        </member>
        <member name="M:Engine.PlayerView.ViewportPairs(Microsoft.Xna.Framework.Rectangle,Engine.ViewSplit,System.Collections.Generic.List{System.String})">
            <summary>
            generates a pair of PlayerViews with the given split
            </summary>
            <param name="region">area to subdivid (pass Screensize for full window), the region needs to be a factor of 2 in either split direction</param>
            <param name="split">horizontal or vertical splits only here</param>
            <param name="name">A list of names to associate with the viewports, must be exactly 2 in length</param>
            <returns>array of 2 PlayerViews</returns>
        </member>
        <member name="M:Engine.PlayerView.ViewportQuads(Microsoft.Xna.Framework.Rectangle,Engine.ViewSplit,System.Collections.Generic.List{System.String})">
            <summary>
            generates 4 PlayerViews with the given split
            </summary>
            <param name="region">area to subdivid (pass Screensize for full window), region needs to be factor of 4 for horizontal/vertical splits and factor of 2 for equal</param>
            <param name="split">horizontal or vertical splits only here</param>
            <param name="name">A list of names to associate with the viewports, must be exactly 4 in length</param>
            <returns>array containing 4 PlayerViews</returns>
        </member>
        <member name="T:Engine.ExtensionMethods">
            <summary>
            extensions to classes, replacing the need for "Helper classes" for instance based methods
            </summary>
        </member>
        <member name="M:Engine.ExtensionMethods.Same(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>
            determines if this Point value is the same as Point B
            </summary>
            <param name="A">first Point</param>
            <param name="B">second Point</param>
            <returns>true if same location, false if not</returns>
        </member>
        <member name="M:Engine.ExtensionMethods.Different(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>
            determines if the this point is the same values as point B
            </summary>
            <param name="A">first Point</param>
            <param name="B">second Point</param>
            <returns>true if different location, false if the same</returns>
        </member>
        <member name="M:Engine.ExtensionMethods.Distance(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>
            Calculates the exact distance between this and Point B (in point co-ordinates)
            </summary>
            <param name="A">The first Point</param>
            <param name="B">The second Point</param>
            <returns>The distance between the two Points</returns>
        </member>
        <member name="M:Engine.ExtensionMethods.DistanceSquared(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>
            Calculates the squared distance between this and another Point (in point co-ordinates)
            This is quicker than distance because no square root operation
            </summary>
            <param name="A">The first Point</param>
            <param name="B">The second Point</param>
            <returns>The square of the distance between the this and Point B</returns>
        </member>
        <member name="M:Engine.ExtensionMethods.DistanceSqauredInt(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>
            Calculates the integer sqaured distance between this point and B (in Point co-ordinates)
            </summary>
            <param name="A">The first Point</param>
            <param name="B">The Point to get the distance from</param>
            <returns>The Integer sqaure of the distance between the two Points</returns>
        </member>
        <member name="M:Engine.ExtensionMethods.DistanceInt(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>
            Calculates the integer distance between this point and B (in tile co-ordinates)
            </summary>
            <param name="A">The first tile</param>
            <param name="B">The second tile</param>
            <returns>The Integer distance between the two tiles</returns>
        </member>
        <member name="M:Engine.ExtensionMethods.MultiplyScalar(Microsoft.Xna.Framework.Point,System.Single@)">
            <summary>
            Multiplies this Point value by a scalar value.
            </summary>
            <param name="A">The point to multitply</param>
            <param name="scaler">The multiplication factor</param>
        </member>
        <member name="M:Engine.ExtensionMethods.MultiplyScalarNew(Microsoft.Xna.Framework.Point,System.Single)">
            <summary>
            Multiples this point by a scalar value
            </summary>
            <param name="A">Point to multiply</param>
            <param name="scaler">Multiplication factor</param>
            <returns>New multiplied point</returns>
        </member>
        <member name="M:Engine.ExtensionMethods.Subtract(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point@)">
            <summary>
            Subtracts Point B from this point
            </summary>
            <param name="A">Point to subtract from</param>
            <param name="B">Point being subtracted</param>
        </member>
        <member name="M:Engine.ExtensionMethods.SubtractNew(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>
            Subtracts point B from this point
            </summary>
            <param name="A">The first operand of subtraction</param>
            <param name="B">The point to take away from the first one</param>
            <returns>The subtracted value</returns>
        </member>
        <member name="M:Engine.ExtensionMethods.AddNew(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>
            Adds this point B to this point value, generating a new Point
            </summary>
            <param name="A">The first operand of addition</param>
            <param name="B">The point to add to the first one</param>
            <returns>A new Point with the added values</returns>
        </member>
        <member name="M:Engine.ExtensionMethods.Add(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>
            Adds the point B to this point
            </summary>
            <param name="A">The first operand of addition</param>
            <param name="B">The point to add to the first one</param>
        </member>
        <member name="M:Engine.ExtensionMethods.AsVector2(Microsoft.Xna.Framework.Point)">
            <summary>
            returns a Vector2 equivalent value based on the this point
            </summary>
            <param name="p">The point to change</param>
            <returns>The Vector2 equivalent</returns>
        </member>
        <member name="M:Engine.ExtensionMethods.AsPoint(Microsoft.Xna.Framework.Vector2)">
            <summary>
            returns a Point equivalent value from this Vector2 value
            </summary>
            <param name="v">The vector2 to convert</param>
            <returns>The Point equivalent</returns>
        </member>
        <member name="M:Engine.ExtensionMethods.Subtract(Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            produces a Point offset for a rectangle portion, this can be mapped back to an
            original texture rectangle portion
            </summary>
            <param name="rectangle"></param>
            <param name="offsetPortion"></param>
            <returns>the difference between the two positions</returns>
        </member>
        <member name="M:Engine.ExtensionMethods.Split(Microsoft.Xna.Framework.Rectangle,System.Int32,Engine.ViewSplit)">
            <summary>
            splits the given region into a list of smaller equal regions
            </summary>
            <param name="region">the rectangle to split</param>
            <param name="number">the number of splits only supports 2 or 4 any other value returns the original rectangle, make sure you check the list length</param>
            <param name="split">The split style to apply to the divisions</param>
            <returns>A list of divided rectanges</returns>
        </member>
        <member name="T:Engine.PointHelper">
            <summary>
            A helper class for dealing with Point values
            </summary>
        </member>
        <member name="M:Engine.PointHelper.ShortenPath(System.Collections.Generic.List{Microsoft.Xna.Framework.Point},System.Int32)">
            <summary>
            attempts to reduce the length of a list of points to a required amount
            </summary>
            <param name="path">the list of points to reduce</param>
            <param name="lengthRequired">the number of points you want</param>
        </member>
        <member name="M:Engine.PointHelper.Same(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>
            determines if the two Point values are the same.
            Depreciated use Point.Same(Point B) instead
            </summary>
            <param name="A">first Point</param>
            <param name="B">second Point</param>
            <returns>true if same location, false if not</returns>
        </member>
        <member name="M:Engine.PointHelper.Different(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>
            determines if the two point values are different
            Depreciated use Point.Different(Point B) instead
            </summary>
            <param name="A">first Point</param>
            <param name="B">second Point</param>
            <returns>true if different location, false if the same</returns>
        </member>
        <member name="M:Engine.PointHelper.Distance(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>
            Calculates the exact distance between two Points (in point co-ordinates)
            Depreciated use Point.Distance(Point B) instead
            </summary>
            <param name="A">The first Point</param>
            <param name="B">The second Point</param>
            <returns>The distance between the two Points</returns>
        </member>
        <member name="M:Engine.PointHelper.DistanceSquared(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>
            Calculates the squared distance between two Points (in point co-ordinates)
            This is quicker than distance because no square root operation
            Depreciated use Point.DistanceSquared(Point B) instead
            </summary>
            <param name="A">The first Point</param>
            <param name="B">The second Point</param>
            <returns>The square of the distance between the two Points</returns>
        </member>
        <member name="M:Engine.PointHelper.DistanceSqauredInt(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>
            Calculates the integer  sqaured distance between two Points (in Point co-ordinates)
            Depreciated use Point.DistanceSquaredInt(Point B) instead
            </summary>
            <param name="A">The first Point</param>
            <param name="B">The second Point</param>
            <returns>The Integer sqaure of the distance between the two Points</returns>
        </member>
        <member name="M:Engine.PointHelper.DistanceInt(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>
            Calculates the integer distance between two tiles (in tile co-ordinates)
            Depreciated use Point.DistanceInt(Point B) instead
            </summary>
            <param name="A">The first tile</param>
            <param name="B">The second tile</param>
            <returns>The Integer distance between the two tiles</returns>
        </member>
        <member name="M:Engine.PointHelper.MultiplyScalar(Microsoft.Xna.Framework.Point@,System.Single)">
            <summary>
            Multiplies a Point value and a scalar value. A is passed by ref so value will change
            Depreciated use Point.MultiplyScalar(float scaler) instead
            </summary>
            <param name="A">The point to multitply</param>
            <param name="scaler">The multiplication factor</param>
        </member>
        <member name="M:Engine.PointHelper.MultiplyScalar(Microsoft.Xna.Framework.Point,System.Single)">
            <summary>
            Multiples the point by a scalar value
            Depreciated use Point.MultiplyScalarNew(float scaler) instead
            </summary>
            <param name="A">Point to multiply</param>
            <param name="scaler">Multiplication factor</param>
            <returns>New multiplied point</returns>
        </member>
        <member name="M:Engine.PointHelper.Subtract(Microsoft.Xna.Framework.Point@,Microsoft.Xna.Framework.Point@)">
            <summary>
            Subtracts Point B from Point A, uses ref so value of A will be changed
            Depreciated use Point.Subtract(Point B) instead
            </summary>
            <param name="A">Point to subtract from</param>
            <param name="B">Point being subtracted</param>
        </member>
        <member name="M:Engine.PointHelper.Subtract(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>
            Subtracts two point values
            Depreciated use Point.SubtractNew(Point B) instead
            </summary>
            <param name="A">The first operand of subtraction</param>
            <param name="B">The point to take away from the first one</param>
            <returns>The subtracted value</returns>
        </member>
        <member name="M:Engine.PointHelper.Add(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>
            Adds two point values
            Depreciated use Point.AddNew(Point B) instead
            </summary>
            <param name="A">The first operand of addition</param>
            <param name="B">The point to add to the first one</param>
            <returns>The added value</returns>
        </member>
        <member name="M:Engine.PointHelper.Add(Microsoft.Xna.Framework.Point@,Microsoft.Xna.Framework.Point@)">
            <summary>
            Adds two point values
            Depreciated use Point.Add(Point B) instead
            </summary>
            <param name="A">The first operand of addition</param>
            <param name="B">The point to add to the first one</param>
            <returns>The added value</returns>
        </member>
        <member name="M:Engine.PointHelper.Vector2FromPoint(Microsoft.Xna.Framework.Point)">
            <summary>
            returns a Vector2 based on the point value given
            Depreciated use Point.AsVector2() instead
            </summary>
            <param name="p">The point to change</param>
            <returns>The Vector2 equivalent</returns>
        </member>
        <member name="M:Engine.PointHelper.PointFromVector2(Microsoft.Xna.Framework.Vector2)">
            <summary>
            returns a Point value from a Vector2 value
            Depreciated use Vector2.AsPoint() instead
            </summary>
            <param name="v">The vector2 to convert</param>
            <returns>The Point equivalent</returns>
        </member>
        <member name="T:Engine.PointXYZ">
            <summary>
            defines a 3d integer based position with X Y and Z values
            </summary>
        </member>
        <member name="F:Engine.PointXYZ.X">
            <summary>
            the x value of the pointxyz
            </summary>
        </member>
        <member name="F:Engine.PointXYZ.Y">
            <summary>
            the y value of the pointxyz
            </summary>
        </member>
        <member name="F:Engine.PointXYZ.Z">
            <summary>
            the z value of the pointxyz
            </summary>
        </member>
        <member name="M:Engine.PointXYZ.#ctor">
            <summary>
            creates an unintialised pointXYZ
            </summary>
        </member>
        <member name="M:Engine.PointXYZ.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            constructs a new pointxyz with the given values
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="P:Engine.PointXYZ.Zero">
            <summary>
            defines a pointxyz with values 0,0,0
            </summary>
        </member>
        <member name="M:Engine.PointXYZ.FromPoint(Microsoft.Xna.Framework.Point)">
            <summary>
            returns a PointXYZ value from a given point value setting the Z value to 0
            </summary>
            <param name="point">the Point value with the X and Y values wanted</param>
            <returns>PointXYZ value based on Point with a Z of 0</returns>
        </member>
        <member name="M:Engine.PointXYZ.FromPoint(Microsoft.Xna.Framework.Point,System.Int32)">
            <summary>
            returns a PointXYZ value from a given point value setting the Z value to the parameter passed for z
            </summary>
            <param name="point">the Point value with the X and Y values wanted</param>
            <param name="z">the z value to assign to this PointXYZ value</param>
            <returns>PointXYZ value based on Point with a Z of 0</returns>
        </member>
        <member name="M:Engine.PointXYZ.ToPoint">
            <summary>
            Crops the Z value to generate a Point equivalent X,Y
            </summary>
            <returns>Point containing the X and Y positions</returns>
        </member>
        <member name="M:Engine.PointXYZ.ToString">
            <summary>
            returns a string representation of the pointxyz object
            </summary>
            <returns></returns>
        </member>
        <member name="M:Engine.PointXYZ.ToVector3">
            <summary>
            returns the pointxyz as a vector3 value
            </summary>
            <returns>Vector3 equivalent value</returns>
        </member>
        <member name="M:Engine.PointXYZ.FromVector3(Microsoft.Xna.Framework.Vector3)">
            <summary>
            creates an integer version of a Vector3 value
            </summary>
            <param name="vector3">the vector3 value to integer transform</param>
        </member>
        <member name="M:Engine.PointXYZ.ToVector3(Engine.PointXYZ)">
            <summary>
            takes a PointXYZ and generates the equivalent Vector3 value
            </summary>
            <param name="pointxyz">the PointXYZ value to convert</param>
            <returns>Vector3 equivalent value</returns>
        </member>
        <member name="T:Engine.PostProcessFramework">
            <summary>
            a class (inheritable to wrap general post processing code to
            </summary>
        </member>
        <member name="F:Engine.PostProcessFramework.graphicsDevice">
            <summary>
            a reference to the graphics device
            </summary>
        </member>
        <member name="F:Engine.PostProcessFramework.pp">
            <summary>
            a quick reference to the presentation parameters of the graphics device
            </summary>
        </member>
        <member name="F:Engine.PostProcessFramework.myBatch">
            <summary>
            a reference to the spritebatch being used for this effect (supplied by the engine)
            </summary>
        </member>
        <member name="P:Engine.PostProcessFramework.GetTexture">
            <summary>
            gets or sets the input texture for this effect
            </summary>
        </member>
        <member name="F:Engine.PostProcessFramework.input">
            <summary>
            input texture to blur/glow with
            </summary>
        </member>
        <member name="F:Engine.PostProcessFramework.effect">
            <summary>
            holds the effect shaders
            </summary>
        </member>
        <member name="M:Engine.PostProcessFramework.#ctor(Microsoft.Xna.Framework.Graphics.GraphicsDevice)">
            <summary>
            constructor for the PostProcessor
            </summary>
            <param name="g"></param>
        </member>
        <member name="M:Engine.PostProcessFramework.Process(System.Int32)">
            <summary>
            Performs the postprocess operation with the given inputTexture
            </summary>
        </member>
        <member name="M:Engine.PostProcessFramework.Final(System.Int32)">
            <summary>
            carries out final tasks when post processing is no longer needed
            </summary>
        </member>
        <member name="T:Engine.PostProcessor">
            <summary>
            a class for implementing PostProcess effects on sprite layers
            currently not working in MonoGame
            </summary>
        </member>
        <member name="P:Engine.PostProcessor.Effect">
            <summary>
            pixel shader
            </summary>
        </member>
        <member name="F:Engine.PostProcessor.graphicsDevice">
            <summary>
            The graphics device being used
            </summary>
        </member>
        <member name="F:Engine.PostProcessor.spriteBatch">
            <summary>
            reference to the spritebatch used for rendering
            </summary>
        </member>
        <member name="M:Engine.PostProcessor.#ctor(Microsoft.Xna.Framework.Graphics.Effect,Microsoft.Xna.Framework.Graphics.GraphicsDevice)">
            <summary>
            Constructs the PostProcessor
            </summary>
            <param name="effect">Effect being used</param>
            <param name="graphicsDevice">Graphics device</param>
        </member>
        <member name="M:Engine.PostProcessor.Draw">
            <summary>
            Draws the sprite layer with the effect active
            </summary>
        </member>
        <member name="T:Engine.RenderCapture">
            <summary>
            picks up the render target which the sprite layer rendered to
            </summary>
        </member>
        <member name="M:Engine.RenderCapture.#ctor(Microsoft.Xna.Framework.Graphics.GraphicsDevice)">
            <summary>
            sets up a render target
            </summary>
            <param name="graphicsDevice">Graphics device</param>
        </member>
        <member name="M:Engine.RenderCapture.Begin">
            <summary>
            sets the render target for the sprite layer
            </summary>
        </member>
        <member name="M:Engine.RenderCapture.End">
            <summary>
            completes the rendering or the target
            </summary>
        </member>
        <member name="M:Engine.RenderCapture.GetTexture">
            <summary>
            gets the filled (hopefully) render target ready for processing
            </summary>
            <returns></returns>
        </member>
        <member name="T:Engine.RandomHelper">
            <summary>
            an extension to the random number generator class
            </summary>
        </member>
        <member name="M:Engine.RandomHelper.#ctor(System.Int32)">
            <summary>
            creates a new RandomHelper with an intial seed value
            </summary>
            <param name="seed"></param>
        </member>
        <member name="M:Engine.RandomHelper.#ctor">
            <summary>
            Produces a random helper with default seed value
            </summary>
        </member>
        <member name="M:Engine.RandomHelper.NextFloat">
            <summary>
            returns a random floating point value between 0.0f and 1.0f
            </summary>
            <returns>value between 0.0f and 1.0f</returns>
        </member>
        <member name="M:Engine.RandomHelper.FloatBetween(System.Single,System.Single)">
            <summary>
            returns a random float between the smallest and largest values
            </summary>
            <param name="smallest">lower of the two numbers</param>
            <param name="largest">largest of the two numbers</param>
            <returns>random value between given number</returns>
        </member>
        <member name="T:Engine.RectangleF">
            <summary>
            Provides equivalent functions as standard rectangle but using floats
            </summary>
        </member>
        <member name="F:Engine.RectangleF.rect">
            <summary>
            x = x, y = y, w = width, z = height
            </summary>
        </member>
        <member name="M:Engine.RectangleF.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            constructs a new rectangle with given values
            </summary>
            <param name="x">left</param>
            <param name="y">top</param>
            <param name="w">width</param>
            <param name="h">height</param>
        </member>
        <member name="M:Engine.RectangleF.#ctor">
            <summary>
            creates an empty Rectangle with all values zero
            </summary>
        </member>
        <member name="P:Engine.RectangleF.Rectangle">
            <summary>
            returns the equivalent rectangle object
            </summary>
        </member>
        <member name="P:Engine.RectangleF.X">
            <summary>
            left hand position of recctangle
            </summary>
        </member>
        <member name="P:Engine.RectangleF.Y">
            <summary>
            top of rectangle
            </summary>
        </member>
        <member name="P:Engine.RectangleF.Width">
            <summary>
            width of rectangle
            </summary>
        </member>
        <member name="P:Engine.RectangleF.Height">
            <summary>
            Height of rectangle
            </summary>
        </member>
        <member name="M:Engine.RectangleF.#ctor(Microsoft.Xna.Framework.Rectangle)">
            <summary>
            creates a floating point copy of the rectangle given
            </summary>
            <param name="r"></param>
        </member>
        <member name="P:Engine.RectangleF.Left">
            <summary>
            left side of rectangle
            </summary>
        </member>
        <member name="P:Engine.RectangleF.Right">
            <summary>
            right side of rectangle
            </summary>
        </member>
        <member name="P:Engine.RectangleF.Top">
            <summary>
            top of rectangle
            </summary>
        </member>
        <member name="P:Engine.RectangleF.Bottom">
            <summary>
            bottom of rectangle
            </summary>
        </member>
        <member name="P:Engine.RectangleF.Centre">
            <summary>
            centre of rectangle as a vector2
            </summary>
        </member>
        <member name="T:Engine.RectangleHelper">
            <summary>
            collection of helper functions for rectangles
            </summary>
        </member>
        <member name="M:Engine.RectangleHelper.PositionBetween(Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Vector2)">
            <summary>
            determines if a position is in between the inner and outer edges aof a rectangle
            </summary>
            <code>
            ******************************
            *                            *
            *                            *
            *     ++++++++++++++         *
            *     +            +         *
            *     +            +         *
            *     +            +         *
            *     ++++++++++++++         *
            *                            *
            *                   X        *
            *                            *
            ******************************
            </code>
            <param name="outside">the outside rectangle</param>
            <param name="inside">the inside rectangle</param>
            <param name="position">position to check</param>
            <returns>if in between rectangles then true, false if not</returns>
        </member>
        <member name="M:Engine.RectangleHelper.Split(Microsoft.Xna.Framework.Rectangle,System.Int32,Engine.ViewSplit)">
            <summary>
            splits the given region into a list of smaller equal regions
            </summary>
            <param name="region">the rectangle to split</param>
            <param name="number">the number of splits only supports 2 or 4 any other value returns the original rectangle, make sure you check the list length</param>
            <param name="split">The split style to apply to the divisions</param>
            <returns>A list of divided rectanges</returns>
        </member>
        <member name="M:Engine.RectangleHelper.BoundingRectangle(System.Collections.Generic.List{Microsoft.Xna.Framework.Vector2})">
            <summary>
            creates the smallest rectangle that encloses all points given
            </summary>
            <param name="positions">A list of Vector2 values containg the points to enclose</param>
            <returns>A rectangle enclosing all points</returns>
        </member>
        <member name="M:Engine.RectangleHelper.BoundingRectangle(System.Collections.Generic.List{Microsoft.Xna.Framework.Vector3})">
            <summary>
            creates the smallest rectangle that encloses all points given
            </summary>
            <param name="positions">A list of Vector3 values containg the points to enclose</param>
            <returns>A rectangle enclosing all points</returns>
        </member>
        <member name="M:Engine.RectangleHelper.BoundingBox(System.Collections.Generic.List{Microsoft.Xna.Framework.Vector3})">
            <summary>
            creates the smallest 3d box that encloses all points given
            </summary>
            <param name="positions">A list of Vector3 values containg the points to enclose</param>
            <returns>A box enclosing all points</returns>
        </member>
        <member name="M:Engine.RectangleHelper.BoundingRectangle(System.Collections.Generic.List{Microsoft.Xna.Framework.Point})">
            <summary>
            creates the smallest rectangle that encloses all points given
            </summary>
            <param name="positions">A list of Point values containg the points to enclose</param>
            <returns>A rectangle enclosing all points</returns>
        </member>
        <member name="M:Engine.RectangleHelper.Subtract(Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            produces a Point offset for a rectangle portion, this can be mapped back to an
            original texture rectangle portion - DEPRECIATED use Rectangle.Subtract(Rectangle offsetPortion)
            </summary>
            <param name="rectangle"></param>
            <param name="offsetPortion"></param>
            <returns></returns>
        </member>
        <member name="T:Engine.RenderProperties">
            <summary>
            holds rendering settings for sprite and text layers and tilesheets
            </summary>
        </member>
        <member name="F:Engine.RenderProperties.Active">
            <summary>
            determines whether we are rendering this layer
            </summary>
        </member>
        <member name="F:Engine.RenderProperties.PostProcessEffect">
            <summary>
            if set specifies the complex effect renderer to use
            </summary>
        </member>
        <member name="P:Engine.RenderProperties.ActiveEffect">
            <summary>
            for back compatability gets or sets post process framework operation
            currently only blur/glow availble
            </summary>
        </member>
        <member name="F:Engine.RenderProperties.SimpleEffect">
            <summary>
            sets a simple spritebatch available pass through effect (such as grayscale, sepia)
            you can add your own to this
            </summary>
        </member>
        <member name="F:Engine.RenderProperties.renderedWithEffects">
            <summary>
            if true tells renderer that it needs to draw a rendertarget to backbuffer
            </summary>
        </member>
        <member name="F:Engine.RenderProperties.samplerState">
            <summary>
            the rendering sample state the default is linear clamp (smooth blending)
            </summary>
        </member>
        <member name="F:Engine.RenderProperties.blendState">
            <summary>
            the blending state the default is AlphaBlend
            </summary>
        </member>
        <member name="M:Engine.RenderProperties.#ctor">
            <summary>
            Creates the renderProperties for this layer or tilesheet with a default view association
            with the default PlayerView
            </summary>
        </member>
        <member name="P:Engine.RenderProperties.ViewAssociation">
            <summary>
            gets or set the PlayerViews to render this layer with
            </summary>
        </member>
        <member name="F:Engine.RenderProperties.viewAssociations">
            <summary>
            holds a list of the PlayerViews this should be rendered with
            </summary>
        </member>
        <member name="F:Engine.RenderProperties.itemsRendered">
            <summary>
            holds number of items (sprites/tiles) rendered this loop for this layer
            </summary>
        </member>
        <member name="F:Engine.RenderProperties._scaleFactor">
            <summary>
            Specifies the scaling effect for the tilemap
            </summary>
        </member>
        <member name="P:Engine.RenderProperties.ScaleFactor">
            <summary>
            Specifies the scaling effect for the tilemap
            </summary>
        </member>
        <member name="F:Engine.RenderProperties.rotationAngle">
            <summary>
            specifies the rotation angle for the tilemap
            </summary>
        </member>
        <member name="P:Engine.RenderProperties.RotationAngle">
            <summary>
            gets or sets the rotation angle in degrees for the tilemap
            CreateMatrix must be set to true for this to have an effect
            </summary>
        </member>
        <member name="F:Engine.RenderProperties.RotationCentre">
            <summary>
            Specifies the centre of rotation for the tilemap
            </summary>
        </member>
        <member name="F:Engine.RenderProperties.Displacement">
            <summary>
            The displacement factor for the layer
            </summary>
        </member>
        <member name="F:Engine.RenderProperties.DrawMatrix">
            <summary>
            default matrix which does nothing
            </summary>
        </member>
        <member name="F:Engine.RenderProperties.CreateMatrix">
            <summary>
            if true creates a transformation matrix for the Sprite/text layer
            based on the scaleFactor, rotationAngle, rotationCentre values,
            otherwise the DrawMatrix is used (which defaults to Identity - which does nothing)
            </summary>
        </member>
        <member name="F:Engine.RenderProperties.scaledRenderArea">
            <summary>
            holds the scaled engine viewport for the sprite layer
            </summary>
        </member>
        <member name="P:Engine.RenderProperties.IsDirty">
            <summary>
            set to true if any of settings have been changed
            </summary>
        </member>
        <member name="F:Engine.RenderProperties.dirty">
            <summary>
            if a settings has been changed set to true
            </summary>
        </member>
        <member name="M:Engine.RenderProperties.Cleaned">
            <summary>
            marks renderproperties as cleaned (dealt with any changes)
            </summary>
        </member>
        <member name="T:Engine.RotationHelper">
            <summary>
            provides methods to help with rotation and direction work
            </summary>
        </member>
        <member name="M:Engine.RotationHelper.GetNormalVelocityTo(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single,Engine.DirectionAccuracy,System.Boolean)">
            <summary>
            Returns a velocity which is at a normal to the given sprite
            </summary>
            <param name="from">the sprite we wish to move normal to</param>
            <param name="to">The sprite to get the normal to</param>
            <param name="speed">how fast in pixels per second we want to move</param>
            <param name="accuracy">Do we want to use 4 ordinals, 8 ordinals or exact direction</param>
            <param name="includeZ">If True we Ignore the Z values when working out distances (work in 2d)</param>
            <returns></returns>
        </member>
        <member name="M:Engine.RotationHelper.Direction2DFromAngle(System.Single,System.Single)">
            <summary>
            creates a 2d direction vector from a given angle
            </summary>
            <param name="angle">angle in degrees</param>
            <param name="additionalAngle">angle to add on to given angle</param>
            <returns>Vector2 unit vector in given direction</returns>
        </member>
        <member name="M:Engine.RotationHelper.Direction3DFromAngle(System.Single,System.Single)">
            <summary>
            creates a 3d direction vector from a given angle
            </summary>
            <param name="angle">angle in degrees</param>
            <param name="additionalAngle">angle to add on to given angle</param>
            <returns>Vector3 unit vector in given direction with zero value for Z</returns>
        </member>
        <member name="M:Engine.RotationHelper.AngleFromDirection(Microsoft.Xna.Framework.Vector2)">
            <summary>
            returns an angle in degrees from a given 2d direction vector
            </summary>
            <param name="direction">2d direction vector</param>
            <returns>angle in degrees</returns>
        </member>
        <member name="M:Engine.RotationHelper.AngleFromDirection(Microsoft.Xna.Framework.Vector3)">
            <summary>
            returns an angle in degrees from the xy components of a given 3d direction vector
            </summary>
            <param name="direction">3d direction vector</param>
            <returns>angle in degrees</returns>
        </member>
        <member name="M:Engine.RotationHelper.Ordinalise(Microsoft.Xna.Framework.Vector3)">
            <summary>
            returns an ordinalised unit direction vector, this was massively wrong as up and down were transposed
            </summary>
            <param name="rf">vector3 value to examine</param>
            <returns>Unit direction vector in ordinal direction</returns>
        </member>
        <member name="M:Engine.RotationHelper.Ordinalise(Microsoft.Xna.Framework.Vector2)">
            <summary>
            returns an ordinalised unit direction vector
            </summary>
            <param name="rf">vector2 value to examine</param>
            <returns>Unit direction vector in ordinal direction</returns>
        </member>
        <member name="M:Engine.RotationHelper.LookAt(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Engine.DirectionAccuracy,System.Boolean)">
            <summary>
            Returns a normalised direction vector looking from the starting sprite to the other sprite
            </summary>
            <param name="from">start position</param>
            <param name="to">the direction to look towards</param>
            <param name="accuracy">Not yet used specify free</param>
            <param name="includeZ">Specify true if you want to take the Z value into account</param>
            <returns>A normalised Vector3 direction vector</returns>
        </member>
        <member name="M:Engine.RotationHelper.LookAt(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Engine.DirectionAccuracy)">
            <summary>
            Returns a normalised direction vector looking from the starting sprite to the other sprite
            </summary>
            <param name="from">start position</param>
            <param name="to">the direction to look towards</param>
            <param name="accuracy">Not yet used specify free</param>
            <returns>A normalised Vector2 direction vector</returns>
        </member>
        <member name="M:Engine.RotationHelper.BearingTo(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Engine.DirectionAccuracy,System.Single)">
            <summary>
            returns an angle (in degrees) that can be used to point from one direction to another
            </summary>
            <param name="from">start position</param>
            <param name="to">position to aim at</param>
            <param name="accuracy">free rotation or locked to ordinals</param>
            <param name="additionalAngle">additional rotation on top</param>
            <returns>number of degrees to turn</returns>
        </member>
        <member name="M:Engine.RotationHelper.BearingTo(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Engine.DirectionAccuracy,System.Single)">
            <summary>
            returns an angle  (in degrees) that can be used to point from one direction to another
            </summary>
            <param name="from">start position</param>
            <param name="to">position to aim at</param>
            <param name="accuracy">free rotation or locked to ordinals</param>
            <param name="additionalAngle">additional rotation on top</param>
            <returns>number of degrees to turn</returns>
        </member>
        <member name="M:Engine.RotationHelper.VelocityInCurrentDirection(Engine.Sprite,System.Single,System.Single)">
            <summary>
            Gives a sprite a velocity at a certain speed in the direction
            it is currently facing.
            </summary>
            <param name="speed">The number of pixels per second you want to move the sprite in the given direction</param>
            <param name="additionalAngle">An extra angle of rotation to take into account</param>
            <example>
            A Sprite s is set to move at 100 pixels per second
            <code>
            RotationHelper.VelocityInCurrentDirection(s, 100, 0);
            </code>
            </example>
            <param name="me">Sprite to set the velocity of</param>
            <remarks>Use this from within an UpdateHandler</remarks>
        </member>
        <member name="M:Engine.RotationHelper.VelocityInThisDirection(Engine.Sprite,Microsoft.Xna.Framework.Vector3,System.Single)">
            <summary>
            Sets velocity of a sprite in the direction vector given at the speed specified
            </summary>
            <param name="me">The sprite which wishes to move</param>
            <param name="directionVector">A unit vector which is obtained using DirectionTo() which represents
            the direction you wish to travel (normalise it if you are creating it yourself using .Normalize()</param>
            <param name="speed">The number of pixels per second you wish to move</param>
        </member>
        <member name="M:Engine.RotationHelper.MyDirection(Engine.Sprite,System.Single)">
            <summary>
            returns a vector holding the normalised (unit length) direction the sprite is currently facing
            </summary>
            <param name="me">the sprite to examine</param>
            <param name="additionalAngle">any additional rotation to take into account</param>
            <returns>the direction vector</returns>
        </member>
        <member name="M:Engine.RotationHelper.FaceVelocity(Engine.Sprite,Engine.DirectionAccuracy,System.Boolean,System.Single)">
            <summary>
            rotates a sprite to point in the direction it is moving (based on the velocity)
            </summary>
            <param name="me">sprite to rotate</param>
            <param name="accuracy">rotation step</param>
            <param name="includeZ">true if you want to look at 3d, false for plain 2d</param>
            <param name="additionalAngle">any addtional angle in degrees to add to result</param>
        </member>
        <member name="M:Engine.RotationHelper.FacePosition(Engine.Sprite,Microsoft.Xna.Framework.Vector3,Engine.DirectionAccuracy,System.Single,System.Boolean)">
            <summary>
            rotates the sprite to face (from its current position) the position given
            </summary>
            <param name="s">the sprite to rotate</param>
            <param name="to">the position to rotate in the direction of</param>
            <param name="acc">the ordinal accuracy of the rotation</param>
            <param name="additionalAngle">any additional angle to take into account</param>
            <param name="includeZ">if true the position is done in 3 dimensions</param>
        </member>
        <member name="M:Engine.RotationHelper.FaceMovement(Engine.Sprite,Engine.DirectionAccuracy,System.Boolean,System.Single)">
            <summary>
            rotates the sprite to face along the direction it is currently moving
            This will work with sprites that are being manually moved or moved along a track.
            It does not make use of the velocity of the sprite
            </summary>
            <param name="me">the sprite to rotate</param>
            <param name="accuracy">the ordinal accuracy of the rotation</param>
            <param name="additionalAngle">any additional angle to take into account</param>
            <param name="includeZ">if true the position is done in 3 dimensions</param>
        </member>
        <member name="M:Engine.RotationHelper.FaceDirection(Engine.Sprite,Microsoft.Xna.Framework.Vector2,Engine.DirectionAccuracy,System.Single)">
            <summary>
            Rotates a sprite to point along a given vector
            </summary>
            <param name="me">The sprite to rotate</param>
            <param name="directionVector">The vector to rotate in line with</param>
            <param name="accuracy">ordinal accruacy to use</param>
            <param name="additionalAngle">any additional rotation to take into account</param>
        </member>
        <member name="M:Engine.RotationHelper.FaceDirection(Engine.Sprite,Microsoft.Xna.Framework.Vector3,Engine.DirectionAccuracy,System.Single)">
            <summary>
            Rotates a sprite to point along a given vector
            </summary>
            <param name="me">The sprite to rotate</param>
            <param name="directionVector">The vector to rotate in line with</param>
            <param name="accuracy">ordinal accruacy to use</param>
            <param name="additionalAngle">any additional rotation to take into account</param>
        </member>
        <member name="M:Engine.RotationHelper.AngularDirectionTo(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single,System.Boolean)">
            <summary>
            Determines whether rotating clockwise or anticlockwise is closest for a given position and direction
            Useful for create homing and tracking effects, returns -1 if turned anti-clocwise, 1 if clockwise or 0 if didn't turn
            </summary>
            <param name="from">Position to look from</param>
            <param name="directionVector">Direction looking</param>
            <param name="to">position aiming for</param>
            <param name="minimumAngle">the step size to turn by, if rotation required is less than this then 0 will be returned</param>
            <param name="includeZ">if true 3d positioning is taken into account</param>
            <returns>-1 if turned anti-clocwise, 1 if clockwise or 0 if didn't turn</returns>
        </member>
        <member name="M:Engine.RotationHelper.AngularDirectionTo(Engine.Sprite,Microsoft.Xna.Framework.Vector3,System.Single,System.Boolean)">
            <summary>
            Determines if a sprite should rotate clockwise or anticlockwise, so that it would rotating towards a given position.
            Useful for create homing and tracking effects, returns -1 if turned anti-clocwise, 1 if clockwise or 0 if didn't turn
            </summary>
            <param name="me">the sprite to determine rotation direction</param>
            <param name="position">the position to turn towards</param>
            <param name="minimumAngle">the step size to turn by, if rotation required is less than this then sprite will not be needed to be rotated and 0 will be returned</param>
            <param name="includeZ">if true 3d positioning is taken into account</param>
            <returns>-1 if turned anti-clocwise, 1 if clockwise or 0 if didn't turn</returns>
        </member>
        <member name="M:Engine.RotationHelper.RotateSpriteAround(Engine.Sprite,Microsoft.Xna.Framework.Vector3,System.Single,System.Single,System.Single)">
            <summary>
            rotates a sprites position about an arbitray axis
            </summary>
            <param name="s">the sprite to rotate around this position</param>
            <param name="origin">the centre position for the rotation to take place</param>
            <param name="angleX">The rotation amount in degrees about the X axis</param>
            <param name="angleY">The rotation amount in degrees about the Y axis</param>
            <param name="angleZ">The rotation amount in degrees about the Z axis</param>
        </member>
        <member name="M:Engine.RotationHelper.RotateAround(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single,System.Single,System.Single)">
            <summary>
            rotates a sprites position about an arbitray axis
            </summary>
            <param name="point">the point to rotate around the given position</param>
            <param name="origin">the centre position for the rotation to take place</param>
            <param name="angleX">The rotation amount in degrees about the X axis</param>
            <param name="angleY">The rotation amount in degrees about the Y axis</param>
            <param name="angleZ">The rotation amount in degrees about the Z axis</param>
        </member>
        <member name="M:Engine.RotationHelper.RotateAround(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single)">
            <summary>
            Rotates a point around the position given, but only in the Z plane.
            This is useful for working out where the top (or other easy to pick point) of a sprite 
            is once a sprite has been rotated
            </summary>
            <param name="point">Point to transform</param>
            <param name="origin">rotation centre</param>
            <param name="angleZ">angle in degrees to rotate</param>
        </member>
        <member name="M:Engine.RotationHelper.RotateAround(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            Rotates a point around the position given, but only in the Z plane.
            This is useful for working out where the top (or other easy to pick point) of a sprite 
            is once a sprite has been rotated
            </summary>
            <param name="point">Point to transform Position2D, Centre2D for quick sprite values must be reference argument</param>
            <param name="origin">rotation centre - can use Position2D, Centre2D for quick 2d values</param>
            <param name="angleZ">angle in degrees to rotate</param>
        </member>
        <member name="T:Engine.SoundEnvelope">
            <summary>
            defines an volume shape for a sound effect
            these are lerp'd for the duration of a sound effect
            </summary>
        </member>
        <member name="P:Engine.SoundEnvelope.SawTooth">
            <summary>
            a standard triangle shaped rise then fall of volume
            </summary>
        </member>
        <member name="T:Engine.SpriteBase">
            <summary>
            basic static sprite (no update or collision detection available)
            </summary>
        </member>
        <member name="F:Engine.SpriteBase.lastZ">
            <summary>
            holds a ref to last sprite id issued prior to reset
            this can be used to ensure sprite flicker is eliminated
            </summary>
        </member>
        <member name="F:Engine.SpriteBase.id">
            <summary>
            holds the value of the next sprite id to generate
            </summary>
        </member>
        <member name="F:Engine.SpriteBase.myId">
            <summary>
            holds the sprites unique id
            </summary>
        </member>
        <member name="P:Engine.SpriteBase.ID">
            <summary>
            gets the internal id for the sprite - always unique
            </summary>
        </member>
        <member name="F:Engine.SpriteBase.AutoAllocateZ">
            <summary>
            determines if Z values are allocated in ascending order or not
            </summary>
        </member>
        <member name="F:Engine.SpriteBase.Frame">
            <summary>
            holds the Animated texture element of the sprite
            </summary>
        </member>
        <member name="F:Engine.SpriteBase.Position">
            <summary>
            holds the sprites position, defaults to 0,0,0
            </summary>
        </member>
        <member name="P:Engine.SpriteBase.Position2D">
            <summary>
            gets or sets the 2D position of the sprite
            </summary>
        </member>
        <member name="F:Engine.SpriteBase.Mass">
            <summary>
            The mass for collision and forces, defaults to area of sprite
            
            </summary>
        </member>
        <member name="M:Engine.SpriteBase.#ctor">
            <summary>
            basic constructor for sprite assigns a unique id
            </summary>
        </member>
        <member name="F:Engine.SpriteBase.lastZLoopLimit">
            <summary>
            loop for auto z value settings
            </summary>
        </member>
        <member name="F:Engine.SpriteBase.scale">
            <summary>
            the scale for each dimension
            </summary>
        </member>
        <member name="M:Engine.SpriteBase.SetVisibleSize">
            <summary>
            pre-calculates the visible size of the sprite
            </summary>
        </member>
        <member name="F:Engine.SpriteBase.VisibleWidthDiv2">
            <summary>
            pre-calculated visible width div 2
            </summary>
        </member>
        <member name="F:Engine.SpriteBase.VisibleHeightDiv2">
            <summary>
            pre-calculated visible height div 2
            </summary>
        </member>
        <member name="F:Engine.SpriteBase.VisibleWidth">
            <summary>
            pre-calculated displaywidth
            </summary>
        </member>
        <member name="F:Engine.SpriteBase.VisibleHeight">
            <summary>
            pre-calculated displayHeighth
            </summary>
        </member>
        <member name="P:Engine.SpriteBase.ClampSpeed">
            <summary>
            If true the value held in MaxSpeed will be used to limit the speed of the sprite
            </summary>
        </member>
        <member name="P:Engine.SpriteBase.MaxSpeed">
            <summary>
            if ClampSpeed is true then this value will be used to limit the maximum speed of a sprite
            </summary>
        </member>
        <member name="M:Engine.SpriteBase.SetSpeedClamp(System.Single)">
            <summary>
            sets and activates maximum speed clamping
            </summary>
            <param name="maximumSpeed"></param>
        </member>
        <member name="M:Engine.SpriteBase.Show">
            <summary>
            shows a sprite
            </summary>
        </member>
        <member name="M:Engine.SpriteBase.Hide">
            <summary>
            hides a sprite
            </summary>
        </member>
        <member name="M:Engine.SpriteBase.Kill">
            <summary>
            kills a sprite
            </summary>
        </member>
        <member name="T:Engine.Sprite">
            <summary>
            Holds the definition for a moving and updating sprite
            </summary>
        </member>
        <member name="M:Engine.Sprite.GetClone">
            <summary>
            produces a clone of this sprite these include: Frames, Limit, OnUpdate, OnFuneral, OnHide, OnShow, OnPoint,
            Layer, Velocity, Type, RotationVelocity, UpdatePeriod, Debug, CollisionActive, PerspectiveProject, Alpha, Shape, Scale
            </summary>
            <returns>A sprite which takes its attributes from this sprite</returns>
        </member>
        <member name="M:Engine.Sprite.GetClone(System.Boolean)">
            <summary>
            produces a clone of this sprite these include: Limit, OnUpdate, OnFuneral, OnHide, OnShow, OnPoint,
            Layer, Velocity, Type, RotationVelocity, UpdatePeriod, Debug, CollisionActive, PerspectiveProject, Alpha, Shape, Scale
            </summary>
            <param name="takeFrames">if true then the frame information for the sprite will also be copied</param>
            <returns>A sprite which takes its attributes from this sprite</returns>
        </member>
        <member name="P:Engine.Sprite.Alpha">
            <summary>
            the transparency of the sprite 1 is opaque 0 is completely transparent, default is 1 (opaque)
            </summary>
        </member>
        <member name="F:Engine.Sprite._originalWash">
            <summary>
            holds a copy of colour settings when diming
            </summary>
        </member>
        <member name="F:Engine.Sprite._originalAlpha">
            <summary>
            holds a copy of the alpha setting when diming
            </summary>
        </member>
        <member name="F:Engine.Sprite.Limit">
            <summary>
            the limit box control for the sprite, must be enabled using LimitInitialise first
            </summary>
        </member>
        <member name="F:Engine.Sprite.Type">
            <summary>
            holds the type for this sprite, this is just an integer value but can use the SpriteType class of constants
            </summary>
            <remarks>You should organise types by creating integer constants for easy reference</remarks>
        </member>
        <member name="F:Engine.Sprite.Shape">
            <summary>
            the general shape to treat the sprite as during collisions, default is circle
            </summary>
        </member>
        <member name="F:Engine.Sprite.DebugAttributeNameDisplay">
            <summary>
            specifies if the name of a debug attribute should be shown
            default is (true), if false just the data is displayed - useful to show the text property directly to show associated text
            </summary>
        </member>
        <member name="F:Engine.Sprite.Debug">
            <summary>
            specifies the debug output we require for this sprite, defaults to none
            </summary>
        </member>
        <member name="F:Engine.Sprite.status">
            <summary>
            holds flags for sprites status using bitwise enums for compactness and 
            hopefully some speed up (although using properties to access!)
            those specified become defaulted to true
            </summary>
        </member>
        <member name="M:Engine.Sprite.AutoColorFadeOn(Engine.Fade,System.Single,System.Single)">
            <summary>
            Forces colour fading on
            </summary>
            <param name="fadeMethod">The fade method to employ colour, alpha or both</param>
            <param name="biggestZ">The largest Z value this sprite will have</param>
            <param name="smallestZ">The smallest Z value this sprite will have</param>
        </member>
        <member name="F:Engine.Sprite._frontLimit">
            <summary>
            holds the biggest z for fade work
            </summary>
        </member>
        <member name="F:Engine.Sprite._backLimit">
            <summary>
            holds the farthest z for fade work
            </summary>
        </member>
        <member name="F:Engine.Sprite._frontBackRecipricol">
            <summary>
            pre-calculated recipricol so we can multiply instead of dividing
            </summary>
        </member>
        <member name="F:Engine.Sprite._fadeMethod">
            <summary>
            holds the fade method to employ
            </summary>
        </member>
        <member name="P:Engine.Sprite.AutoFadeFront">
            <summary>
            gets or sets the front z value for fading work, default is the maximum positive Z position
            </summary>
        </member>
        <member name="M:Engine.Sprite.FrontBackRecipricol">
            <summary>
            calculates pre-calc for fade calculations
            </summary>
        </member>
        <member name="P:Engine.Sprite.AutoFadeBack">
            <summary>
            gets or sets the back z value for fading work, default is the maximum negative z value
            </summary>
        </member>
        <member name="M:Engine.Sprite.AutoColourFadeOff">
            <summary>
            restores actual sprite colour wash
            </summary>
        </member>
        <member name="P:Engine.Sprite.CollisionBoxVisible">
            <summary>
            Determines whether the collision box (if it exists) is visible for this sprite, default is false (not visible)
            </summary>
        </member>
        <member name="P:Engine.Sprite.CollisionActive">
            <summary>
            determines whether this sprite is to be involved in collision checking, default is false, make sure you have set this to true for sprites you need collision for
            </summary>
        </member>
        <member name="P:Engine.Sprite.CollisionPrimary">
            <summary>
            determines whether collision checks should be made for this sprite hitting others, default is false
            </summary>
        </member>
        <member name="P:Engine.Sprite.CollisionLive">
            <summary>
            determines whether collision checks continue to be active. 
            Set to true at start of collision processing and can be set to false during prologues, epilogues etc... 
            so we can aboandon checking after a specific collision has occured
            </summary>
        </member>
        <member name="P:Engine.Sprite.CollisionAbandonResponse">
            <summary>
            determines if collision response should be abandoned.
            This should be set to true during an OnPrologue handler to stop collision response for the individual collision
            </summary>
        </member>
        <member name="P:Engine.Sprite.CollisionAvoid">
            <summary>
            determines if collision targets are sprites to avoid (look at everything other than this list) or ones
            to actually target. The default is false which means the list are those sprites to target
            </summary>
        </member>
        <member name="P:Engine.Sprite.WorldCoordinates">
            <summary>
            does this sprites x,y,z position represent world positions or does it refer to its position in the viewport, default is true (world coordinates).
            Set this to false to have the position interpreted as screen coordinates (no matter what the world viewport position is)
            </summary>
        </member>
        <member name="P:Engine.Sprite.HistoryKeepWash">
            <summary>
            determines if history should use the wash colour of the sprite or use HistoryWash value instead. The default is true so 
            use the Wash value of the sprite set this to false to use the color value held in HistoryWash instead.
            </summary>
        </member>
        <member name="P:Engine.Sprite.Dead">
            <summary>
            has this sprite been killed, sprites can be resurrected using OnFuneral if required, default is false
            </summary>
        </member>
        <member name="P:Engine.Sprite.CalculateRadius">
            <summary>
            if true then radius is approximated from current frame size and sprite scale
            default is false which uses X scale and value set for Radius. default for this is true
            </summary>
        </member>
        <member name="P:Engine.Sprite.SnapHistory">
            <summary>
            determines whether history snapshot should be taken after sprite rendered
            (and we have all the data calculated) default is false (off)
            </summary>
        </member>
        <member name="P:Engine.Sprite.DimOnZ">
            <summary>
            is the sprites colour going to fade with its Z position, default is false
            </summary>
        </member>
        <member name="P:Engine.Sprite.DrawHistory">
            <summary>
            is this sprites history being shown, default is false
            </summary>
        </member>
        <member name="P:Engine.Sprite.RoughGravity">
            <summary>
            are we using rough gravity or a more accurate (slower) calculation, default is true so use rough calc
            </summary>
        </member>
        <member name="P:Engine.Sprite.HistoryFadeAlpha">
            <summary>
            are we fading history drawing (if we are drawing history), default is true so history fades out along its distance
            </summary>
        </member>
        <member name="P:Engine.Sprite.HistorySampling">
            <summary>
            are we sampling history positions for this sprite
            </summary>
        </member>
        <member name="P:Engine.Sprite.Paused">
            <summary>
            is the sprite active or paused, if paused it will remain in position, default is false (not paused)
            </summary>
        </member>
        <member name="P:Engine.Sprite.PerspectiveProjection">
            <summary>
            is perspective projection  active for this sprite, default is false (no perspective projection)
            </summary>
        </member>
        <member name="P:Engine.Sprite.SmoothPosition">
            <summary>
            are we using half pixel or integer positioning, default is true so half pixel positioning is enabled, you may need 
            to turn this off for certain elements like banner animation, to stop them bouncing
            </summary>
        </member>
        <member name="P:Engine.Sprite.ShowHideIgnoreFirst">
            <summary>
            if true don't fire show hide handlers the first time a sprite is displayed, default is true so handlers fired after sprite shows next time (after being hidden)
            </summary>
        </member>
        <member name="P:Engine.Sprite.Touching">
            <summary>
            is this sprite touching another sprite - not currently used for anything, default is false
            </summary>
        </member>
        <member name="P:Engine.Sprite.UpdateBeforeLimit">
            <summary>
            should we perform a user defined sprite handler before limit box testing or after (true means before), default is false so limit box applied first.
            This will change when the sprite update and physics elements are completely revamped, to allow for threading
            </summary>
        </member>
        <member name="P:Engine.Sprite.UserDebugPosition">
            <summary>
            debug position is overrided with a user provided value if true. Default is false, place below sprite
            </summary>
        </member>
        <member name="P:Engine.Sprite.Visible">
            <summary>
            is the sprite visible, thie is set to true automatically when a sprite is created with at least one frame defined (false if no frames defined)
            </summary>
        </member>
        <member name="P:Engine.Sprite.AlwaysVisible">
            <summary>
            determines if we should show a sprite even if its visiblility state says its hidden.
            Can be used for flashing history effects. Default is false 
            </summary>
        </member>
        <member name="P:Engine.Sprite.WorkIn3d">
            <summary>
            specifies if the game engine should use 3d coords during distance and rotation calculations, default is false
            </summary>
        </member>
        <member name="P:Engine.Sprite.Moving">
            <summary>
            is the sprite moveable, during collision response, default is false, if you want collision response to be calculated for you then set this to true
            </summary>
        </member>
        <member name="P:Engine.Sprite.Static">
            <summary>
            is the sprite non moving, if not moving cannot respond to collisions they are involved in, the default for this is true.
            </summary>
        </member>
        <member name="P:Engine.Sprite.UpdateCallBack">
            <summary>
            Holds a Sprite call back to used
            </summary>
        </member>
        <member name="P:Engine.Sprite.FuneralCallBack">
            <summary>
            holds delagates to be called when the sprite dies, useful for firing animation sprites etc...
            </summary>
        </member>
        <member name="P:Engine.Sprite.ShowCallBack">
            <summary>
            holds delgates to be called whenever the sprite is shown (Show() is called - like in flashing)
            </summary>
        </member>
        <member name="P:Engine.Sprite.HideCallBack">
            <summary>
            holds delgates to be called whenever the sprite is hidden (Hide() is called - like in flashing)
            </summary>
        </member>
        <member name="P:Engine.Sprite.DrawCallBack">
            <summary>
            holds delgates to be called whenever the sprite is drawn
            </summary>
        </member>
        <member name="P:Engine.Sprite.PointInCallBack">
            <summary>
            holds delgates to call if a point is found inside this sprite by the engine
            </summary>
        </member>
        <member name="P:Engine.Sprite.CollisionCallBack">
            <summary>
            holds delegates to call if this sprite is detected hitting another sprite.
            Use this to stop any collision response and decide what you are going to do about this collision.
            Useful for when you just want to know when two things hit
            </summary>
        </member>
        <member name="P:Engine.Sprite.CollisionPixelCallBack">
            <summary>
            holds delegates to call if a sprite is detected hitting another sprite and pixel accurate detection is requested
            </summary>
        </member>
        <member name="P:Engine.Sprite.ResponseCallBack">
            <summary>
            holds delegates to call to respond to the collision, the engine works out the collsion normal
            and the impact velocity and passes these to your own handler
            </summary>
        </member>
        <member name="P:Engine.Sprite.PrologueCallBack">
            <summary>
            holds delegates to call if this sprite is detected hitting another sprite.
            Use this to stop perform tasks before any collision response
            Useful if you need to check the sprite hit and do something like make it animate (although this would be better in the Epilogue)
            </summary>
        </member>
        <member name="P:Engine.Sprite.EpilogueCallBack">
            <summary>
            holds delegates to call if this sprite hits another sprite, 
            use this to allow default handling and response and do some extra work with the sprites after all this is completed
            </summary>
        </member>
        <member name="F:Engine.Sprite.e">
            <summary>
            collision co-efficient for energy loss
            1f maintains 100% energy after collision,
            less than 1 reduces energy, 0.75f would be 75%, 
            more than 1 increases energy, 1.25f would be 125% energy
            </summary>
        </member>
        <member name="F:Engine.Sprite.Friction">
            <summary>
            friction co-efficient, 0 is no friction 1 is perfect friction
            numbers bigger than 1 will obviously increase the rate of movement
            </summary>
        </member>
        <member name="F:Engine.Sprite.Gravity">
            <summary>
            gravity vector in 3d, to apply to the sprite
            </summary>
        </member>
        <member name="F:Engine.Sprite.GravityWell">
            <summary>
            gravity well objects, for this sprite there can be more than one
            </summary>
        </member>
        <member name="F:Engine.Sprite.Velocity">
            <summary>
            holds sprites velocity in 3 dimensions
            </summary>
        </member>
        <member name="P:Engine.Sprite.Velocity2D">
            <summary>
            allows 2d access to the velocity of the sprite
            </summary>
        </member>
        <member name="P:Engine.Sprite.SX">
            <summary>
            gets or sets the X scale of the sprite, 1 is normal
            </summary>
        </member>
        <member name="P:Engine.Sprite.SY">
            <summary>
            gets or sets the Y scale of the sprite, 1 is normal
            </summary>
        </member>
        <member name="F:Engine.Sprite.scaleVelocity">
            <summary>
            holds the scale percentage increase per second to apply to the sprite Vector2(0,0) is the default, no scaling
            </summary>
        </member>
        <member name="P:Engine.Sprite.Scale">
            <summary>
            gets or sets the scale of the sprite (1,1) is normal size
            </summary>
        </member>
        <member name="P:Engine.Sprite.ScaleBoth">
            <summary>
            gets or sets the proportionate scale factor for a sprite,
            the same factor is applied to both the x and y value.
            Only the x factor is read when getting the ScaleBoth as it assumes
            you are setting both values the same anyway
            </summary>
        </member>
        <member name="F:Engine.Sprite.myBins">
            <summary>
            holds the sprites bin locations (if collisions are active)
            </summary>
        </member>
        <member name="F:Engine.Sprite.rotationAngle">
            <summary>
            rotation angle in radians
            </summary>
        </member>
        <member name="F:Engine.Sprite.rotationVelocity">
            <summary>
            amount to change rotation by in radians (radians per second)
            </summary>
        </member>
        <member name="P:Engine.Sprite.RotationVelocity">
            <summary>
            gets or sets the rotation velocity in degrees per second
            </summary>
        </member>
        <member name="P:Engine.Sprite.RotationAngle">
            <summary>
            gets or sets the rotation angle in degrees 
            </summary>
        </member>
        <member name="F:Engine.Sprite.elapsedTime">
            <summary>
            elapsed time for this sprite since last update
            </summary>
        </member>
        <member name="F:Engine.Sprite.UpdatePeriod">
            <summary>
            the update period for the sprite to force the update to only occur now and then, just like space invaders movement
            </summary>
        </member>
        <member name="F:Engine.Sprite.lastPosition">
            <summary>
            the last position of the sprite for various operations such as directional stuff
            </summary>
        </member>
        <member name="P:Engine.Sprite.LastPosition">
            <summary>
            gets the last position of a sprite
            </summary>
        </member>
        <member name="P:Engine.Sprite.LastPosition2D">
            <summary>
            gets the last position of a sprite
            </summary>
        </member>
        <member name="F:Engine.Sprite.Align">
            <summary>
            Alignment mode for interpreting the position of the sprite, 
            default is centred - that is the position (x and y) refers to the centre of the sprite
            </summary>
        </member>
        <member name="F:Engine.Sprite.Wash">
            <summary>
            Colour overlay to apply to the sprite, defaults to white no colour change
            </summary>
        </member>
        <member name="F:Engine.Sprite.HistoryWash">
            <summary>
            holds a colour wash to apply to the history of the sprite if being sampled
            the default is to use this colour wash of the sprite, set historyKeepWash to false to use this colour instead, which defaults to white
            </summary>
        </member>
        <member name="F:Engine.Sprite.WashCollision">
            <summary>
            defines the color of the collision box when drawn, default is transparent red
            </summary>
        </member>
        <member name="F:Engine.Sprite.Amount">
            <summary>
            a real value associated with the sprite
            </summary>
        </member>
        <member name="F:Engine.Sprite.Information">
            <summary>
            another text string associated with the sprite
            </summary>
        </member>
        <member name="F:Engine.Sprite.Point">
            <summary>
            a point associated with the sprite
            </summary>
        </member>
        <member name="F:Engine.Sprite.hits">
            <summary>
            holds number of times sprite has collided, reset when required
            </summary>
        </member>
        <member name="F:Engine.Sprite.Text">
            <summary>
            some text to be stored about the sprite
            </summary>
        </member>
        <member name="P:Engine.Sprite.RotationCentre">
            <summary>
            gets the rotation centre of the sprite.
            based on its rotation alignment
            </summary>
        </member>
        <member name="P:Engine.Sprite.RotationCentreInt">
            <summary>
            gets the rotation centre of the sprite truncated to integers.
            Based on rotation alignment
            </summary>
        </member>
        <member name="P:Engine.Sprite.Centre">
            <summary>
            gets the current centre of the sprite taking the alignment into account
            </summary>
        </member>
        <member name="P:Engine.Sprite.Centre2D">
            <summary>
            gets the 2d centre of the sprite taking the alignment into account
            </summary>
        </member>
        <member name="F:Engine.Sprite.CollisionTargets">
            <summary>
            contains a list of object types that we either want to specifically collide with or avoid
            add items to list use typeof(Object)
            </summary>
            <example>
            CollisionTargets.Add(typeof(PlayerShip));
            </example>
        </member>
        <member name="F:Engine.Sprite.Associate">
            <summary>
            holds any type of object so a sprite can store anything you want. When creating your inherited sprites you should not need to use this at all
            This is needed for speciality sprites such as dummy text sprites, so you don't have to create a sprite class just to create a dummy value 
            </summary>
        </member>
        <member name="F:Engine.Sprite.Timer">
            <summary>
            provides timing control for flashing, killing etc..., must be enabled using TimerInitialise first
            </summary>
        </member>
        <member name="F:Engine.Sprite.Track">
            <summary>
            The track manager that works with this sprites tracks, must be enabled using TrackInitialise first
            </summary>
        </member>
        <member name="M:Engine.Sprite.#ctor">
            <summary>
            constructs a new sprite and allocates a default Z value starting from 0 and looping to 1000
            if you need to overide this set a Z value for the sprite.
            </summary>
        </member>
        <member name="M:Engine.Sprite.LimitInitialise">
            <summary>
            activates the limit system for the sprite, must call this before attempting to restrict the sprites movement.
            </summary>
        </member>
        <member name="M:Engine.Sprite.TimerInitialise">
            <summary>
            activates the timing manager for this sprite, must call this before attempting to work with sprite flashing etc...
            </summary>
        </member>
        <member name="M:Engine.Sprite.TrackInitialise">
            <summary>
            activates the track manager for this sprite, must call this before attempting to work with sprite tracks
            </summary>
        </member>
        <member name="M:Engine.Sprite.Kill">
            <summary>
            kills the sprite
            </summary>
        </member>
        <member name="M:Engine.Sprite.Clear">
            <summary>
            forces a sprite to be removed from processing without any calling the funeral
            CleanUp() will still be called to remove any resources for the sprite
            </summary>
        </member>
        <member name="M:Engine.Sprite.CleanUp">
            <summary>
            overridable called when a sprite is removed or killed
            add code to remove any other resources managed by the sprite (helper/friend sprites, events etc...)
            if you don't they could still be active
            </summary>
        </member>
        <member name="F:Engine.Sprite._positionHistoryDepth">
            <summary>
            holds the number of old positions held in the list
            defaults to 2
            </summary>
        </member>
        <member name="F:Engine.Sprite._historySampleRate">
            <summary>
            How often to sample record history defaults to 1/10 of a second
            </summary>
        </member>
        <member name="P:Engine.Sprite.HistorySampleRate">
            <summary>
            gets or sets the sampling rate for history items in number of samples per second
            60 would be 60 times a second or every frame drawn (assuming we are running at standard frame rates)
            </summary>
        </member>
        <member name="F:Engine.Sprite.HistorySample">
            <summary>
            An event to trigger the history sampling
            </summary>
        </member>
        <member name="F:Engine.Sprite.HistoryFade">
            <summary>
            how fast to fade the colour values of old history sprites
            defaulted to zero (no fade)
            </summary>
        </member>
        <member name="F:Engine.Sprite._maxHistoryAlpha">
            <summary>
            starting alpha
            </summary>
        </member>
        <member name="M:Engine.Sprite.HistoryShow(System.Single)">
            <summary>
            Show position history
            </summary>
            <param name="samplingRate">the sampling rate for history items in number of samples per second</param>
        </member>
        <member name="M:Engine.Sprite.HistoryClear">
            <summary>
            clears all history for the sprite
            </summary>
        </member>
        <member name="F:Engine.Sprite.HistoryScale">
            <summary>
            scale factor to apply to history rendering
            this value is the factor by which to increase/decrease the scale of history trails.
            A value of 1 would increase the size by 100%
            a value of -0.5f would decrease the size by 50%, it defaults to 0 which is no scale change
            </summary>
        </member>
        <member name="P:Engine.Sprite.HistoryCount">
            <summary>
            gets the number of history items recorded
            </summary>
        </member>
        <member name="M:Engine.Sprite.HistoryManualSnap">
            <summary>
            make the history system take a snap shot now, this can be used to make specific history
            grabs instead of using the sampling timer
            </summary>
        </member>
        <member name="M:Engine.Sprite.HistoryShow">
            <summary>
            Shows position history
            </summary>
        </member>
        <member name="M:Engine.Sprite.HistoryHide">
            <summary>
            hide position history
            </summary>
        </member>
        <member name="M:Engine.Sprite.HistoryStopSampling">
            <summary>
            Turns history sampling off
            </summary>
        </member>
        <member name="F:Engine.Sprite.HistoryLayer">
            <summary>
            the sprite RenderLayer to draw the history on (this can allow you to perform effects separatley 
            for the history items if you want), defaults to same as spriteZero
            </summary>
        </member>
        <member name="P:Engine.Sprite.HistoryClampAlpha">
            <summary>
            Sets the maximum alpha for the history trail, if HistoryFadeAlpha is false then this is the alpha for the entire trail
            </summary>
            <value>The maximum alpha for history, 1 is maximum, 0 is minimum</value>
        </member>
        <member name="P:Engine.Sprite.HistoryDepth">
            <summary>
            Gets or Sets a value that states how many previous
            positions of the sprite we should keep track of
            </summary>
            <value>Don't use exceedingly high numbers (>300) it will slow the game down and can have
            strange side effects</value>
        </member>
        <member name="F:Engine.Sprite.renderLayer">
            <summary>
            layer to associate sprite with for rendering
            </summary>
        </member>
        <member name="P:Engine.Sprite.Layer">
            <summary>
            gets or sets the RenderLayer for the sprite, do not use dynamicText for sprites as these will not be drawn
            do not use dynamicText as this will cause the engine to crash - I need to fix this but not at the moment
            </summary>
        </member>
        <member name="M:Engine.Sprite.Show">
            <summary>
            shows the sprite firing any requested events
            </summary>
        </member>
        <member name="M:Engine.Sprite.Show(System.Boolean)">
            <summary>
            shows the sprite firing any requested events
            </summary>
            <param name="collisionState">Set the collisionActive state of the sprite true - means collidable</param>
        </member>
        <member name="M:Engine.Sprite.Hide">
            <summary>
            hides the sprite firing any requested events
            </summary>
        </member>
        <member name="M:Engine.Sprite.Hide(System.Boolean)">
            <summary>
            hides the sprite firing any requested events
            </summary>
            <param name="collisionState">Set the collisionActive state of the sprite true - means collidable</param>
        </member>
        <member name="M:Engine.Sprite.FireOnShow">
            <summary>
            checks for visiblity change and fires handlers if exist
            </summary>
        </member>
        <member name="M:Engine.Sprite.FireOnHide">
            <summary>
            Checks for visibility change and fires OnHide
            </summary>
        </member>
        <member name="F:Engine.Sprite.Effects">
            <summary>
            the flipping effects to apply to the sprite (if any)
            </summary>
        </member>
        <member name="P:Engine.Sprite.Delta">
            <summary>
            c
            </summary>
        </member>
        <member name="P:Engine.Sprite.Delta2D">
            <summary>
            Position2D - LastPosition2D
            </summary>
        </member>
        <member name="P:Engine.Sprite.DeltaManual">
            <summary>
            returns the distance moved since last movement of sprite
            </summary>
        </member>
        <member name="P:Engine.Sprite.DeltaManual2D">
            <summary>
            returns the 2d distance moved since last movement of sprite
            </summary>
        </member>
        <member name="P:Engine.Sprite.MovedDown">
            <summary>
            true if the sprite moved down since last position change
            </summary>
        </member>
        <member name="P:Engine.Sprite.MovedUp">
            <summary>
            true if the sprite moved up since last position change
            </summary>
        </member>
        <member name="P:Engine.Sprite.MoveLeft">
            <summary>
            true if the sprite moved left since last position change
            </summary>
        </member>
        <member name="P:Engine.Sprite.MoveRight">
            <summary>
            true if the sprite moved right since last position change
            </summary>
        </member>
        <member name="F:Engine.Sprite.engM">
            <summary>
            own ref to engine manager
            </summary>
        </member>
        <member name="F:Engine.Sprite.RotationAlignment">
            <summary>
            specifies general rotation positioning of the sprite
            </summary>
        </member>
        <member name="P:Engine.Sprite.Sides">
            <summary>
            gets the sides of a sprite and stores in a single vector4 object
            Left - X, Right - Y, Top - Z, Bottom - W
            more efficient than getting left, right, top and bottom separately
            not pretty to look at
            </summary>
        </member>
        <member name="P:Engine.Sprite.Left">
            <summary>
            the left hand collision position of the sprite
            </summary>
        </member>
        <member name="P:Engine.Sprite.Right">
            <summary>
            the right hand collision position of the sprite
            </summary>
        </member>
        <member name="P:Engine.Sprite.Top">
            <summary>
            gets the collision top of the sprite
            </summary>
        </member>
        <member name="P:Engine.Sprite.Bottom">
            <summary>
            gets the collision bottom of the sprite
            </summary>
        </member>
        <member name="P:Engine.Sprite.X">
            <summary>
            gets the X value of the sprite
            </summary>
        </member>
        <member name="P:Engine.Sprite.Y">
            <summary>
            gets the Y value of the sprite
            </summary>
        </member>
        <member name="P:Engine.Sprite.Z">
            <summary>
            gets the Z value of the sprite
            </summary>
        </member>
        <member name="F:Engine.Sprite.baseRadius">
            <summary>
            holds the fixed radius for the sprite
            </summary>
        </member>
        <member name="P:Engine.Sprite.Radius">
            <summary>
            the radius of the sprite when using the sprite with a spherical style
            The X factor of the Scale property is used to scale the sprite properly
            if CalculateRadius is set then the curremt frame data will be used to approximate a radius
            </summary>
        </member>
        <member name="P:Engine.Sprite.Width">
            <summary>
            width of sprite taking scale into account
            </summary>
        </member>
        <member name="P:Engine.Sprite.Height">
            <summary>
            height of sprite taking scale into account
            </summary>
        </member>
        <member name="M:Engine.Sprite.AlignedRenderPosition(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            gets the internal vector2 of the sprite as it would appear in screen space
            </summary>
            <param name="pos">the position to set</param>
        </member>
        <member name="M:Engine.Sprite.AlignedRenderPosition(Microsoft.Xna.Framework.Point@)">
            <summary>
            gets the internal vector2 of the sprite as it would appear in screen space
            </summary>
            <param name="pos">the point position to set</param>
        </member>
        <member name="M:Engine.Sprite.StoppedMarkAs">
            <summary>
            marks a sprite as not moving for this frame. Will be gone
            </summary>
        </member>
        <member name="F:Engine.Sprite.UpdateAs">
            <summary>
            how sprite updates are conducted, defaults to automatic
            </summary>
        </member>
        <member name="F:Engine.Sprite.LastTrackPosition">
            <summary>
            holds last recorded position for a tracking sprite as history can't help with direction
            methods, not used for any other reason.
            </summary>
        </member>
        <member name="F:Engine.Sprite.DebugAttribtute">
            <summary>
            specifies the attributes to use when display the sprites debug information
            </summary>
        </member>
        <member name="F:Engine.Sprite.DebugOutputPosition">
            <summary>
            if value is other than -1,-1 then this position is used to draw the debug output for the sprite
            </summary>
        </member>
        <member name="P:Engine.Sprite.Clone">
            <summary>
            makes a new sprite which is the copy of this sprite
            </summary>
            <returns>A sprite copy which needs adding to the engine manager if you want it to be processed</returns>
        </member>
        <member name="T:Engine.SpriteHelper">
            <summary>
            methods to help do some of the tasks when manipulating sprites
            </summary>
        </member>
        <member name="M:Engine.SpriteHelper.ScaleToThisSize(Engine.Sprite,System.Single,System.Single)">
            <summary>
            Sets x and y scales needed to stretch a sprite to the dimensions given
            </summary>
            <param name="s">The sprite to scale</param>
            <param name="width">the width to make the sprite</param>
            <param name="height">the height to make the sprite</param>
            <remarks>Bear in mind this only scales in relation to the current frame size.
            if the frame size changes (e.g. you animate) you will need to re-calculate this
            by using the OnUpdate handler of the sprite</remarks>
        </member>
        <member name="M:Engine.SpriteHelper.ScaleToThisSize(Engine.Sprite,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            Sets x and y scales needed to stretch a sprite to the dimensions given
            </summary>
            <param name="s">The sprite to scale</param>
            <param name="rect">The rectangle that contains the width and height
            desired for the sprite</param>
            <remarks>Bear in mind this only scales in relation to the current frame size.
            if the frame size changes (e.g. you animate) you will need to re-calculate this
            by using the OnUpdate handler of the sprite</remarks>
        </member>
        <member name="M:Engine.SpriteHelper.ScaleToThisWidth(Engine.Sprite,System.Single)">
            <summary>
            Scales width of sprite to match requested width keeping aspect ratio correct
            </summary>
            <param name="s">The sprite to scale</param>
            <param name="width">the width to make the sprite</param>
        </member>
        <member name="M:Engine.SpriteHelper.ScaleToThisHeight(Engine.Sprite,System.Single)">
            <summary>
            Scales height of sprite to match requested height keeping aspect ratio correct
            </summary>
            <param name="s">The sprite to scale</param>
            <param name="height">the height to make the sprite</param>
        </member>
        <member name="M:Engine.SpriteHelper.AlignTopAt(Engine.Sprite,System.Single)">
            <summary>
            Aligns the top of the sprite at the given y position
            </summary>
            <param name="s">Sprite to align</param>
            <param name="y">the y value to use for positioning</param>
        </member>
        <member name="M:Engine.SpriteHelper.AlignTopAt(Engine.Sprite,System.Single,System.Single)">
            <summary>
            Aligns the top of the sprite at the y position specified, but adjusted by an offset
            </summary>
            <param name="s">Sprite to align</param>
            <param name="y">The y position to align at</param>
            <param name="offset">the offset to adjust the vertical position by</param>
        </member>
        <member name="M:Engine.SpriteHelper.AlignBottomAt(Engine.Sprite,System.Single)">
            <summary>
            Aligns the bottom of the sprite at the y position specified, but adjusted by an offset
            </summary>
            <param name="s">The sprite to align</param>
            <param name="y">The y position to align at</param>
        </member>
        <member name="M:Engine.SpriteHelper.AlignBottomAt(Engine.Sprite,System.Single,System.Single)">
            <summary>
            Aligns the bottom of the sprite at the y position specified, but adjusted by an offset
            </summary>
            <param name="s">The sprite to align</param>
            <param name="y">The y position to align at</param>
            <param name="offset">the offset to adjust the vertical position by</param>
        </member>
        <member name="M:Engine.SpriteHelper.AlignLeftAt(Engine.Sprite,System.Single)">
            <summary>
            Aligns the left of the sprite at the y position specified, but adjusted by an offset
            </summary>
            <param name="s">Sprite to align</param>
            <param name="x">The x position to align at</param>
        </member>
        <member name="M:Engine.SpriteHelper.AlignLeftAt(Engine.Sprite,System.Single,System.Single)">
            <summary>
            Aligns the left of the sprite at the y position specified, but adjusted by an offset
            </summary>
            <param name="s">Sprite to align</param>
            <param name="x">The x position to align at</param>
            <param name="offset">the offset to adjust the horizontal position by</param>
        </member>
        <member name="M:Engine.SpriteHelper.AlignRightAt(Engine.Sprite,System.Single)">
            <summary>
            Aligns the right of the sprite at the y position specified, but adjusted by an offset
            </summary>
            <param name="s">Sprite to align</param>
            <param name="x">The x position to align at</param>
        </member>
        <member name="M:Engine.SpriteHelper.AlignRightAt(Engine.Sprite,System.Single,System.Single)">
            <summary>
            Aligns the right of the sprite at the y position specified, but adjusted by an offset
            </summary>
            <param name="s">Sprite to align</param>
            <param name="x">The x position to align at</param>
            <param name="offset">the offset to adjust the horizontal position by</param>
        </member>
        <member name="T:Engine.SpriteHistory">
            <summary>
            holds the definitions for a snapshot of a sprite
            This can be added to over time
            </summary>
        </member>
        <member name="F:Engine.SpriteHistory.tex">
            <summary>
            texture of sprite
            </summary>
        </member>
        <member name="F:Engine.SpriteHistory.rect">
            <summary>
            rectangle portion to use of tex
            </summary>
        </member>
        <member name="F:Engine.SpriteHistory.DrawPos">
            <summary>
            Holds the draw position for this history state
            </summary>
        </member>
        <member name="F:Engine.SpriteHistory.Position">
            <summary>
            the physical position of the sprite not needed for rendering
            </summary>
        </member>
        <member name="F:Engine.SpriteHistory.Sides">
            <summary>
            Scaled world positions of sprite
            </summary>
        </member>
        <member name="F:Engine.SpriteHistory.WorldCoordinates">
            <summary>
            what co-ordinate system did the parent have
            </summary>
        </member>
        <member name="F:Engine.SpriteHistory.depth">
            <summary>
            z position (0-1)
            </summary>
        </member>
        <member name="F:Engine.SpriteHistory.Scale">
            <summary>
            holds the scale for this history state
            </summary>
        </member>
        <member name="F:Engine.SpriteHistory.renderScale">
            <summary>
            holds the actual scale to render this history item at
            </summary>
        </member>
        <member name="F:Engine.SpriteHistory.Angle">
            <summary>
            holds the rotation angle for this history state
            </summary>
        </member>
        <member name="F:Engine.SpriteHistory.Visible">
            <summary>
            records the visible state for the history state
            </summary>
        </member>
        <member name="F:Engine.SpriteHistory.Wash">
            <summary>
            holds the colour of the sprite at the timer
            </summary>
        </member>
        <member name="F:Engine.SpriteHistory._alpha">
            <summary>
            the alpha setting for colour of sprite
            </summary>
        </member>
        <member name="P:Engine.SpriteHistory.Alpha">
            <summary>
            the separate alpha component required during calculations not used for rendering
            </summary>
        </member>
        <member name="F:Engine.SpriteHistory.FinalWash">
            <summary>
            premulitplied colour of history
            </summary>
        </member>
        <member name="F:Engine.SpriteHistory.offset">
            <summary>
            holds layer displacement and viewport offset at time of snap
            </summary>
        </member>
        <member name="F:Engine.SpriteHistory.Layer">
            <summary>
            holds the layer that the history is one
            </summary>
        </member>
        <member name="F:Engine.SpriteHistory.Origin">
            <summary>
            origin of sprite
            </summary>
        </member>
        <member name="F:Engine.SpriteHistory.effect">
            <summary>
            current stock effect for the sprite
            </summary>
        </member>
        <member name="F:Engine.SpriteHistory.viewportIndex">
            <summary>
            holds the viewport index this history item is for
            </summary>
        </member>
        <member name="T:Engine.RenderLayer">
            <summary>
            Specifies the layer to attach a sprite to
            </summary>
        </member>
        <member name="F:Engine.RenderLayer.spriteZero">
            <summary>
            the first layer of drawn sprites
            this is the default sprite layer
            </summary>
        </member>
        <member name="F:Engine.RenderLayer.spriteOne">
            <summary>
            The second layers of sprites than can be drawn
            </summary>
        </member>
        <member name="F:Engine.RenderLayer.spriteTwo">
            <summary>
            The third layer of sprites that can be drawn
            </summary>
        </member>
        <member name="F:Engine.RenderLayer.spriteThree">
            <summary>
            the fourth layer of sprites that can be drawn
            </summary>
        </member>
        <member name="F:Engine.RenderLayer.hud">
            <summary>
            rendered after any scene effects have been applied
            so isn't effected by scaling rotation etc...
            just like text is treated
            </summary>
        </member>
        <member name="F:Engine.RenderLayer.textSprites">
            <summary>
            A special layer where sprites created from fonts are placed, unless there layer is
            overriden with a dummy sprite
            </summary>
        </member>
        <member name="F:Engine.RenderLayer.dynamicText">
            <summary>
            Used by the textStores to draw themselves, do not use this for sprites
            as no sprites can be drawn on this layer
            </summary>
            <remarks>This may be changed so text can be drawn on any layer</remarks>
        </member>
        <member name="F:Engine.RenderLayer.SpriteLayerTotal">
            <summary>
            total number of renderable layers
            </summary>
        </member>
        <member name="F:Engine.RenderLayer.SpriteLayers">
            <summary>
            total number of general sprite based layers
            </summary>
        </member>
        <member name="F:Engine.RenderLayer.SpriteLayerSecondHalf">
            <summary>
            defines where the split
            </summary>
        </member>
        <member name="M:Engine.RenderLayer.ToString(System.Int32)">
            <summary>
            produces layer text enumeration conversion
            </summary>
            <param name="layer">layer value</param>
            <returns>text returned</returns>
        </member>
        <member name="T:Engine.StringHelper">
            <summary>
            A simple class to help with the manipulation of text
            </summary>
        </member>
        <member name="M:Engine.StringHelper.Reverse(System.String)">
            <summary>
            Creates the reverse of the given text
            </summary>
            <param name="text">text to reverse</param>
            <returns>reversed text</returns>
        </member>
        <member name="M:Engine.StringHelper.Count(System.String,System.String)">
            <summary>
            Counts and returns the number of times a given string occurs inside another string
            </summary>
            <param name="inThis">The string to search in</param>
            <param name="lookForThis">The string to look for</param>
            <returns>The number of timer the pattern was found</returns>
        </member>
        <member name="M:Engine.StringHelper.Left(System.String,System.Int32)">
            <summary>
            returns the left part of the string with the required length
            </summary>
            <param name="text">The text you want to crop</param>
            <param name="Length">The number of characters you want</param>
            <returns>The left portion of the string requested</returns>
        </member>
        <member name="M:Engine.StringHelper.ReduceLengthBy(System.String,System.Int32)">
            <summary>
            returns a string that is shortened by the amount specified
            </summary>
            <param name="text">The original string to shorten</param>
            <param name="byThis">the number of characters to remove</param>
            <returns>The new version of the string with the characters removed</returns>
        </member>
        <member name="M:Engine.StringHelper.SubStringRestart(System.String,System.Int32,System.Int32)">
            <summary>
            returns a string which contains the substring of required length padded from the start of
            the string if necessary
            </summary>
            <param name="text">The original string we wish to manipulate</param>
            <param name="startPos">The starting position we wish to take characters from</param>
            <param name="length">The length of the string we want back</param>
            <returns>A string containing the number of characters specified in length</returns>
        </member>
        <member name="M:Engine.StringHelper.Pad(System.String,System.Int32)">
            <summary>
            Returns a string with the given text repeated a number of times
            </summary>
            <param name="text">The text to repeat</param>
            <param name="repeat">The number of times to repeat it</param>
            <returns>The string with multiple copies</returns>
        </member>
        <member name="M:Engine.StringHelper.RPk(System.Single,System.Int32,System.Int32)">
            <summary>
            produces a 2dp, rounded value packed for a specific length with leading zero's
            </summary>
            <param name="value">Value to display</param>
            <param name="dp">Number of decimal places</param>
            <param name="packLength">total number of characters</param>
            <returns>formatted string</returns>
        </member>
        <member name="M:Engine.StringHelper.PadZero(System.Int32,System.Int32,System.Char)">
            <summary>
            returns a string from a number with a fixed length padding the front of string with given character
            </summary>
            <param name="number">number to convert</param>
            <param name="packLength">total number of characters</param>
            <param name="padWith">The character to pad front of string with</param>
            <returns>formatted string</returns>
        </member>
        <member name="T:Engine.Tex">
            <summary>
            stores General textures
            </summary>
        </member>
        <member name="F:Engine.Tex.SingleWhitePixel">
            <summary>
            defines a texture with a single pixel, coloured white
            </summary>
        </member>
        <member name="F:Engine.Tex.Rectangle50by50">
            <summary>
            holds a white rectangle 50 pixels wide and 50 pixels high
            </summary>
        </member>
        <member name="F:Engine.Tex.Triangle">
            <summary>
            holds a white 32x32 triangle, with transparent background
            </summary>
        </member>
        <member name="F:Engine.Tex.TriangleBlack">
            <summary>
            holds a black 32x32 triangle with white surround for colouring
            </summary>
        </member>
        <member name="F:Engine.Tex.Target">
            <summary>
            holds a 32x32 white target sprite wiht transparent background
            </summary>
        </member>
        <member name="F:Engine.Tex.TargetBlack">
            <summary>
            holds a 32x32 black target sprite with white interior for colouring
            </summary>
        </member>
        <member name="F:Engine.Tex.TrackMarker">
            <summary>
            holds the default sprite used to show the position of a track
            </summary>
        </member>
        <member name="F:Engine.Tex.SystemFont">
            <summary>
            will eventually hold the dynamically created arcade font texture
            </summary>
        </member>
        <member name="F:Engine.Tex.ShinyBalls">
            <summary>
            holds ball texture for ball font
            </summary>
        </member>
        <member name="F:Engine.Tex.NumberGrid">
            <summary>
            a grid of 25 number squares, really for animation testing
            </summary>
        </member>
        <member name="F:Engine.Tex.Grid">
            <summary>
            a 2000 by 2000 transparent grid to be used for alignment purposes to
            build either a tilemap or as a sprite
            </summary>
        </member>
        <member name="F:Engine.Tex.Circle4by4">
            <summary>
            a 4 by 4 circle graphics
            </summary>
        </member>
        <member name="F:Engine.Tex.Circle8by8">
            <summary>
            a 8 by 8 circle graphics
            </summary>
        </member>
        <member name="F:Engine.Tex.Circle16by16">
            <summary>
            a 16 by 16 circle graphics
            </summary>
        </member>
        <member name="F:Engine.Tex.Circle32by32">
            <summary>
            a 32 by 32 circle graphics
            </summary>
        </member>
        <member name="F:Engine.Tex.Circle64by64">
            <summary>
            a 64 by 64 circle graphics
            </summary>
        </member>
        <member name="F:Engine.Tex.recShinyBall">
            <summary>
            holds a list of all the rectangle for the ball sprites
            </summary>
        </member>
        <member name="P:Engine.Tex.RecShinyBall">
            <summary>
            gets the shiny ball rectangle list so you can define a simple ball sprite
            which is stored in the Tex.ShinyBalls of the engine manager
            </summary>
        </member>
        <member name="F:Engine.Tex.recNumberGrid">
            <summary>
            holds the retangles defining the number grids
            </summary>
        </member>
        <member name="P:Engine.Tex.RecNumnberGrid">
            <summary>
            gets the rectangle list for specifying the numbergrid textures
            </summary>
        </member>
        <member name="T:Engine.TexAnalyser">
            <summary>
            provides texture processing services to various classes
            </summary>
        </member>
        <member name="F:Engine.TexAnalyser._pixelArray">
            <summary>
            holds the pixel colour information for the corresponding texture
            </summary>
        </member>
        <member name="F:Engine.TexAnalyser._alphaArray">
            <summary>
            exactly same as full _pixelArray but only storing alpha for faster processing
            </summary>
        </member>
        <member name="F:Engine.TexAnalyser._texId">
            <summary>
            each texture is given an ID which is stored in the Name property
            so its references can be looked up easily
            </summary>
        </member>
        <member name="M:Engine.TexAnalyser.Process(Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            Adds a new textute to the texture bank returning a reference to the texture
            </summary>
            <param name="texture">The texture loaded using the content manager</param>
            <returns>The reference to the texture to be used for texture operations</returns>
        </member>
        <member name="M:Engine.TexAnalyser.PixelHere(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Point)">
            <summary>
            Gets the colour of the pixel within a texture. Make sure pixel getting is within the bounds of texture
            </summary>
            <param name="texture">Texture to examine</param>
            <param name="pixel">pixel position to check</param>
            <returns>the colour of te pixel</returns>
        </member>
        <member name="M:Engine.TexAnalyser.ReProcess(Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            reprocesses a dynamic texture
            </summary>
            <param name="texture"></param>
        </member>
        <member name="M:Engine.TexAnalyser.Array2Dto1D(System.UInt32[0:,0:])">
            <summary>
            takes a 2d array of unsigned integers and converts it into a linear 1d array of unsigned integers
            This is specifically to make it easier to build dynamic textures which can only have their data set from a linear array
            </summary>
            <param name="table">The 2d array to translate to 1 dimensions</param>
            <returns>1 dimensional array of unisigned integers</returns>
        </member>
        <member name="M:Engine.TexAnalyser.Array2Dto1D(Microsoft.Xna.Framework.Color[0:,0:])">
            <summary>
            takes a 2d array of colors and converts it into a linear 1d array of colors
            This is specifically to make it easier to build dynamic textures which can only have their data set from a linear array
            </summary>
            <param name="table">The 2d array to translate to 1 dimensions</param>
            <returns>1 dimensional array of colors</returns>
        </member>
        <member name="M:Engine.TexAnalyser.GenerateAlphaBank(Microsoft.Xna.Framework.Color[])">
            <summary>
            grabs the alpha pixels from the pixel array given
            </summary>
            <param name="pixels">The pixel array of ARGB colour to process for this texture</param>
        </member>
        <member name="M:Engine.TexAnalyser.DefineVisibleBoundingBox(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            Works out and produces maximum Width and Height based on sprite texture
            for the visible pixels and places this in a personal boundingbox for the given frame
            </summary>
            <param name="texture">The texture processed by the TextureBank</param>
            <param name="r">The Rectangle of the texture for this frame</param>
        </member>
        <member name="M:Engine.TexAnalyser.GetOutlinePixelMap(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            NOT FINISHED YET NEED SOBOL OR ROBERTS DETECTION IMPLEMENTING
            ROBS 1 0     0  1
                 0 -1    -1 0
            </summary>
            <param name="texture"></param>
            <param name="region"></param>
            <returns></returns>
        </member>
        <member name="M:Engine.TexAnalyser.CheckRequested(System.Int32,Microsoft.Xna.Framework.Rectangle,System.Collections.Generic.List{Microsoft.Xna.Framework.Vector2}@)">
            <summary>
            Checks to see if this particular outline polygon has already been generated
            </summary>
            <param name="textureId">textureId</param>
            <param name="r">The rectangle requested</param>
            <param name="v">an array list of Vector2 to pass the list out through</param>
            <returns>True if previously generated, False if new request</returns>
        </member>
        <member name="M:Engine.TexAnalyser.TransparentRegion(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            Takes a region and determines if it is transparent
            </summary>
            <param name="texture">The texture to look at</param>
            <param name="region">The region of the texture to compare</param>
            <returns>True if it is transparent, false if not</returns>
        </member>
        <member name="M:Engine.TexAnalyser.GetRegionAlphaList(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            Returns a byte array of the alpha values of 
            the pixels in the texture and region specified
            </summary>
            <param name="texture">The texture to look for the transparent pixels of</param>
            <param name="region">The rectangle portion of the texture you want the alpha pixels of</param>
            <returns>A byte array containing the alpha values</returns>
        </member>
        <member name="M:Engine.TexAnalyser.GetRegionAlphaGrid(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            Returns a 2d byte array of the alpha values of 
            the pixels in the texture and region specified
            </summary>
            <param name="texture">The texture to look for the transparent pixels of</param>
            <param name="region">The rectangle portion of the texture you want the alpha pixels of</param>
            <returns>A byte array containing the alpha values</returns>
        </member>
        <member name="M:Engine.TexAnalyser.GetWhiteMaskPixels(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle,Engine.InterpretAlpha)">
            <summary>
            gets the pixel mask in white unsigned integers for the region and texture
            </summary>
            <param name="texture">texture to look at</param>
            <param name="region">rectangle region to pull mask from</param>
            <param name="alphaChoice">How to interpret alpha values</param>
            <returns>a mask array in white</returns>
        </member>
        <member name="M:Engine.TexAnalyser.GetWhiteMaskPixels(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle,Engine.InterpretAlpha,System.Int32)">
            <summary>
            gets the pixel mask in white unsigned integers for the region and texture
            </summary>
            <param name="texture">texture to look at</param>
            <param name="region">rectangle region to pull mask from</param>
            <param name="alphaChoice">How to interpret alpha values</param>
            <param name="tolerance">only works with InterpretAlpha.makeOpaque alpha (0-255) value to accept as transparent</param>
            <returns>a mask array in white</returns>
        </member>
        <member name="M:Engine.TexAnalyser.GetWhiteMaskPixels(Microsoft.Xna.Framework.Graphics.Texture2D,Engine.InterpretAlpha,System.Int32)">
            <summary>
            gets the pixel mask in white unsigned integers for the entire texture
            </summary>
            <param name="texture">texture to look at</param>
            <param name="alphaChoice">How to interpret alpha values</param>
            <param name="tolerance">only works with InterpretAlpha.makeOpaque alpha (0-255) value to accept as transparent</param>
            <returns>a mask array in white</returns>
        </member>
        <member name="M:Engine.TexAnalyser.GetWhiteMaskPixels(Microsoft.Xna.Framework.Graphics.Texture2D,Engine.InterpretAlpha)">
            <summary>
            gets the pixel mask in white unsigned integers for the entire texture
            </summary>
            <param name="texture">texture to look at</param>
            <param name="alphaChoice">How to interpret alpha values</param>
            <returns>a mask array in white</returns>
        </member>
        <member name="M:Engine.TexAnalyser.GetWhiteMaskPixels(Engine.Sprite,System.Int32,Engine.InterpretAlpha,System.Int32)">
            <summary>
            gets the pixel mask in white unsigned integers for the the given frame of a sprite
            </summary>
            <param name="s">Sprite with frame we want masking</param>
            <param name="frame">frame number - which must exist</param>
            <param name="alphaChoice">How to interpret alpha values</param>
            <param name="tolerance">only works with InterpretAlpha.makeOpaque alpha (0-255) value to accept as transparent</param>
            <returns>array of uint white mask pixels</returns>
        </member>
        <member name="M:Engine.TexAnalyser.GetWhiteMaskPixels(Engine.Sprite,System.Int32,Engine.InterpretAlpha)">
            <summary>
            gets the pixel mask in white unsigned integers for the the given frame of a sprite
            </summary>
            <param name="s">Sprite with frame we want masking</param>
            <param name="frame">frame number - which must exist</param>
            <param name="alphaChoice">How to interpret alpha values</param>
            <returns>array of uint white mask pixels</returns>
        </member>
        <member name="M:Engine.TexAnalyser.FlipAlphaPixels(System.Byte[],System.Int32)">
            <summary>
            flips alpha data for sprites that are horizontally flipped to allow collision detection to work
            </summary>
            <param name="pixels"></param>
            <param name="width"></param>
            <returns></returns>
        </member>
        <member name="M:Engine.TexAnalyser.OverlappingAlphaPixels(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle,System.Int32)">
            <summary>
            Attempts to compare texture portions alpha values to determine wether visible pixels overlap for pixel accurate collision detection
            this does not work with rotated sprites, this does not work with scaled sprites
            </summary>
            <param name="textureA">the first texture to look at</param>
            <param name="portionA">the overlapping portion of the first texture to look at alpha pixels</param>
            <param name="textureB">the second texture to look at</param>
            <param name="portionB">the overlapping portion of the second texture to look at the alpha pixels</param>
            <param name="tolerance">tolerance value for alpha (0-255). if the alpha is the same or higher it's considered visible</param>
            <returns>true if overlapping pixels found, false if not</returns>
            <remarks>Does not work with rotated or scaled sprites</remarks>
        </member>
        <member name="M:Engine.TexAnalyser.PixelCollision(Engine.Sprite,Engine.Sprite,Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point,System.Single)">
            <summary>
            attempts to determine if two rectangular sprite frame regions have overlapping pixels (non- transparent)
            does not work with rotated sprites
            </summary>
            <param name="my">the first sprite involved</param>
            <param name="hit">the second sprite involved</param>
            <param name="Overlap">the rectangular overlap determined by the pixel collision system</param>
            <param name="myOffset">the offset for the first sprite</param>
            <param name="hitOffset">the offset for the second sprite</param>
            <param name="tolerance">the alpha for which pixels are considered solid/opaque (1 is anything other than fully transparent)</param>
            <returns>true if overlapping pixels detected, false if not</returns>
        </member>
        <member name="M:Engine.TexAnalyser.OverlappingAlphaPixels(Engine.Sprite,Microsoft.Xna.Framework.Rectangle,Engine.Sprite,Microsoft.Xna.Framework.Rectangle,System.Int32)">
            <summary>
            determines if the two alpha regions have coadjacent pixels, used when testing overlapping sprites for pixel level detection
            this does not work with rotated sprites, this does not work with scaled sprites
            </summary>
            <param name="A">The first sprite to test</param>
            <param name="portionA">the portion of the first texture to examine</param>
            <param name="B">the second sprite</param>
            <param name="portionB">the portion of the second texture to examine</param>
            <param name="tolerance">the tolerance to detect full pixels, put 1 to accept anything other than noe alpha as a hittable pixel</param>
            <returns>true if pixels overlap, false if no pixel collision</returns>
        </member>
        <member name="M:Engine.TexAnalyser.GetWhiteSolidMaskPixels(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle,Engine.InterpretAlpha,System.Int32)">
            <summary>
            gets the pixel mask in white unsigned integers for the region and texture.
            This sets all the pixels from the left and right edge to white so you can have a filled version of the mask
            </summary>
            <param name="texture">texture to look at</param>
            <param name="region">rectangle region to pull mask from</param>
            <param name="alphaChoice">Only accepts InterpretAlpha.makeOpaque at the moment, How to interpret alpha values</param>
            <param name="tolerance">only works with InterpretAlpha.makeOpaque alpha (0-255) value to accept as transparent</param>
            <returns>a mask array in white</returns>
        </member>
        <member name="M:Engine.TexAnalyser.GetWhiteSolidMaskPixels(Engine.Sprite,System.Int32,Engine.InterpretAlpha,System.Int32)">
            <summary>
            gets the pixel mask in white unsigned integers for the the given frame of a sprite
            </summary>
            <param name="s">Sprite with frame we want masking</param>
            <param name="frame">frame number - which must exist</param>
            <param name="alphaChoice">How to interpret alpha values</param>
            <param name="tolerance">only works with InterpretAlpha.makeOpaque alpha (0-255) value to accept as transparent</param>
            <returns>array of uint white mask pixels</returns>
        </member>
        <member name="M:Engine.TexAnalyser.GetRegionPixelGrid(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            Returns a 2d Color array of the pixel colour values 
            the pixels in the texture and region specified
            </summary>
            <param name="texture">The texture to look for the transparent pixels of</param>
            <param name="region">The rectangle portion of the texture you want the alpha pixels of</param>
            <returns>A byte array containing the alpha values</returns>
        </member>
        <member name="M:Engine.TexAnalyser.MassFromPixels(Engine.Sprite)">
            <summary>
            Calculates number of non transparent pixels in the 
            current frame of the given sprite to be used as a mass
            </summary>
            <param name="s">The sprite to grab the mass for</param>
            <returns>The mass of the current frame of the sprite (non alpha pixels)</returns>
        </member>
        <member name="M:Engine.TexAnalyser.MassFromPixels(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            Calculates number of non transparent pixels in 
            region given to be used as a mass
            </summary>
            <param name="texture">The texture to look at</param>
            <param name="region">The region of the texture to compare</param>
            <returns>The mass of the rectangle (non alpha pixels)</returns>
        </member>
        <member name="P:Engine.TexAnalyser.Count">
            <summary>
            gets the number of textures processed
            </summary>
            <value>A number representing the number of textures added to the bank</value>
        </member>
        <member name="T:Engine.TextAtt">
            <summary>
            holds a series of attributes which are applied to text when drawn
            </summary>
        </member>
        <member name="F:Engine.TextAtt.Scale">
            <summary>
            how much to scale the font by
            </summary>
        </member>
        <member name="F:Engine.TextAtt.Kerning">
            <summary>
            pixels between each character, default of 2
            </summary>
        </member>
        <member name="F:Engine.TextAtt.Colour">
            <summary>
            colour to draw the text
            </summary>
        </member>
        <member name="F:Engine.TextAtt.Alpha">
            <summary>
            holds transparency information for the text
            </summary>
        </member>
        <member name="F:Engine.TextAtt.Align">
            <summary>
            Align for text display (in relation to x and y position specified)
            default is topLeft (as previous version)
            </summary>
        </member>
        <member name="F:Engine.TextAtt.Angle">
            <summary>
            angle to draw text at in radians
            </summary>
        </member>
        <member name="F:Engine.TextAtt.LineBreaksAfter">
            <summary>
            after how many pixels should the line wrap occur
            </summary>
        </member>
        <member name="F:Engine.TextAtt.LineSpacing">
            <summary>
            additional amount to adjust lines by (height wise)
            </summary>
        </member>
        <member name="F:Engine.TextAtt.worldCoordinates">
            <summary>
            The position mode for the text
            </summary>
        </member>
        <member name="F:Engine.TextAtt.proportionate">
            <summary>
            If true characters will be placed based on their width
            If false characters will be placed at a fixed distance apart (based on widest character in font)
            </summary>
        </member>
        <member name="M:Engine.TextAtt.#ctor(System.Single,System.Single,Microsoft.Xna.Framework.Color)">
            <summary>
            Creates a TextAtt with the given settings
            </summary>
            <param name="scale">The size to draw at</param>
            <param name="kerning">the space between letters in pixels</param>
            <param name="colour">the colour wash to apply</param>
        </member>
        <member name="P:Engine.TextAtt.Left">
            <summary>
            gets a basic left aligned white normal size Text property
            </summary>
        </member>
        <member name="P:Engine.TextAtt.Right">
            <summary>
            gets a basic right aligned white normal size Text property
            </summary>
        </member>
        <member name="P:Engine.TextAtt.Centred">
            <summary>
            gets a basic centred aligned white normal size Text property
            </summary>
        </member>
        <member name="P:Engine.TextAtt.BottomLeft">
            <summary>
            gets a basic bottomleft aligned white normal size Text property
            </summary>
        </member>
        <member name="P:Engine.TextAtt.Bottom">
            <summary>
            gets a basic bottom aligned white normal size Text property
            </summary>
        </member>
        <member name="P:Engine.TextAtt.BottomRight">
            <summary>
            gets a basic bottomright aligned white normal size Text property
            </summary>
        </member>
        <member name="P:Engine.TextAtt.TopLeft">
            <summary>
            gets a basic topleft aligned white normal size Text property
            </summary>
        </member>
        <member name="P:Engine.TextAtt.Top">
            <summary>
            gets a basic top aligned white normal size Text property
            </summary>
        </member>
        <member name="P:Engine.TextAtt.TopRight">
            <summary>
            gets a basic topright aligned white normal size Text property
            </summary>
        </member>
        <member name="M:Engine.TextAtt.#ctor(System.Single,System.Single,Microsoft.Xna.Framework.Color,Engine.Align)">
            <summary>
            Creates a TextAtt with the given settings
            </summary>
            <param name="scale">The size to draw at</param>
            <param name="kerning">the space between letters in pixels</param>
            <param name="colour">the colour wash to apply</param>
            <param name="textAlign">The Align of the text</param>
        </member>
        <member name="M:Engine.TextAtt.#ctor(System.Single,System.Single,Microsoft.Xna.Framework.Color,Engine.Align,System.Single)">
            <summary>
            Creates a TextAtt with the given settings
            </summary>
            <param name="scale">The size to draw at</param>
            <param name="kerning">the space between letters in pixels</param>
            <param name="colour">the colour wash to apply</param>
            <param name="angle">The rotation to apply</param>
            <param name="textAlign">The Align of the text</param>
        </member>
        <member name="M:Engine.TextAtt.#ctor(System.Single,System.Single,Microsoft.Xna.Framework.Color,Engine.Align,System.Single,System.Boolean)">
            <summary>
            Creates a TextAtt with the given settings
            </summary>
            <param name="scale">The size to draw at</param>
            <param name="kerning">the space between letters in pixels</param>
            <param name="colour">the colour wash to apply</param>
            <param name="angle">The rotation to apply</param>
            <param name="worldCoordinates">world or viewport co-ordinates</param>
            <param name="textAlign">The Align of the text</param>
        </member>
        <member name="M:Engine.TextAtt.#ctor(System.Single,System.Single,Microsoft.Xna.Framework.Color,Engine.Align,System.Single,System.Boolean,System.Single,System.Single)">
            <summary>
            Creates a TextAtt with the given settings
            </summary>
            <param name="scale">The size to draw at</param>
            <param name="kerning">the space between letters in pixels</param>
            <param name="colour">the colour wash to apply</param>
            <param name="angle">The rotation to apply</param>
            <param name="worldCoordinates">true - world or false -viewport co-ordinates</param>
            <param name="linebreak">how many pixels till line break</param>
            <param name="linespacing">the distance between lines</param>
            <param name="textAlign">The Align of the text</param>
        </member>
        <member name="P:Engine.TextAtt.Clone">
            <summary>
            get a cloned version of the TextAtt
            required for menus, so select and reject handlers are changing different attributes
            </summary>
            <returns>cloned attribute</returns>
        </member>
        <member name="T:Engine.TextManager">
            <summary>
            A class to manage the text that is wanting to be displayed
            </summary>
        </member>
        <member name="M:Engine.TextManager.#ctor">
            <summary>
            constructs the default text manager
            </summary>
        </member>
        <member name="M:Engine.TextManager.#ctor(System.Int32)">
            <summary>
            specifies the screen width which sets the default line wrapping length for text attributes
            </summary>
            <param name="defaultWidth"></param>
        </member>
        <member name="F:Engine.TextManager.alphabet">
            <summary>
            the standard 26 characters of the alphabet
            </summary>
        </member>
        <member name="F:Engine.TextManager.sr">
            <summary>
            spritbatch object being used
            </summary>
        </member>
        <member name="F:Engine.TextManager.off">
            <summary>
            displacement of layer being used
            </summary>
        </member>
        <member name="F:Engine.TextManager.renderViewport">
            <summary>
            current viewport
            </summary>
        </member>
        <member name="F:Engine.TextManager.engine">
            <summary>
            reference to engine manager for sprite text stuff
            </summary>
        </member>
        <member name="F:Engine.TextManager.CharactersDrawn">
            <summary>
            number of characters rendered
            </summary>
        </member>
        <member name="F:Engine.TextManager.process">
            <summary>
            holds index to the pending text being processed
            </summary>
        </member>
        <member name="F:Engine.TextManager.current">
            <summary>
            holds current textstore being processed
            </summary>
        </member>
        <member name="F:Engine.TextManager.rendered">
            <summary>
            lets engine draw routine know that text had been rendered and batch needs ending
            </summary>
        </member>
        <member name="M:Engine.TextManager.RenderText">
            <summary>
            called by EngineManager renderer to run through buffered text draw calls
            </summary>
        </member>
        <member name="M:Engine.TextManager.AllRenderingComplete">
            <summary>
            clears up after this round of dynamic text rendering
            </summary>
        </member>
        <member name="M:Engine.TextManager.QuickDirtyDraw">
            <summary>
            A quick draw method for straight non correcting text called by RenderText()
            </summary>
            <returns>number of characters drawn</returns>
        </member>
        <member name="M:Engine.TextManager.Draw">
            <summary>
            Draw piece of text on screen called by RenderText()
            </summary>
            <remarks>This is called by the GameManager.Draw() method and should not be called manually.
            Bendy text will be coming in a future version of the engine</remarks>
        </member>
        <member name="M:Engine.TextManager.FixAlign(Microsoft.Xna.Framework.Vector2,Engine.Align,System.Single,System.Single)">
            <summary>
            examines the properties of the text to be displayed
            </summary>
            <param name="pos">the vector2 value that holds the given x and y text position</param>
            <param name="h"></param>
            <param name="ta"></param>
            <param name="w"></param>
            <remarks>Defined as a static member so I can use it from the EngineManager.DrawTextOnceAsSprite
            method to fix its Align</remarks>
        </member>
        <member name="M:Engine.TextManager.FixAlignHorizontalOnly(System.Single,Engine.Align,System.Single)">
            <summary>
            works out the horizontal offset for Align
            </summary>
            <param name="pos">display position</param>
            <param name="ta">Align</param>
            <param name="w">width of current line</param>
            <returns>horizontal offset</returns>
        </member>
        <member name="M:Engine.TextManager.DrawAsSprites(Engine.TextStore,System.Single,Engine.Sprite)">
            <summary>
            Draws a textstore object as a series of sprites
            </summary>
            <param name="ts">the TextStore containing text information to display</param>
            <param name="zPosition">The Z value for the text sprites</param>
            <param name="spriteAttributes">A sprite containing attributes to copy.
            The following attributes can be set and copied to each character of your text:
            TimerActions all the flashing and killing stuff
            Limit box stuff
            OnShow() - a sprite handler called whenever sprite shown, great for flashing effects
            OnUpdate() - a sprite handler called whenever sprite updated
            OnFuneral() - a sprite handler called when sprite is killed
            OnHide() - a sprite handler called when sprite is hidden
            Layer - overwrites default text layer
            Velocity 
            Type
            RotationVelocity
            UpdateRate - alters timing of sprites updates
            VisibleDebugOutput
            CollisionEnable();
            </param>
            <remarks>You should only call this method once when you setup your game state.
            Do not place run this from the GameLoop as it will generate a ridiculous 
            number of sprites</remarks>
        </member>
        <member name="M:Engine.TextManager.DrawAsSprites(Engine.FontSprite,System.String,System.Single,System.Single,Engine.TextAtt,System.Single,Engine.Sprite)">
            <summary>
            Draw a piece of text as a series of sprites
            </summary>
            <param name="font">font to use</param>
            <param name="text">text to display</param>
            <param name="x">x position to show it at</param>
            <param name="y">y position to show it at</param>
            <param name="attributes">the attriubtes of the text to display</param>
            <param name="zPosition">The Z value for the text sprites</param>
            <param name="spriteAttributes">A sprite containing attributes to copy</param>
        </member>
        <member name="M:Engine.TextManager.DrawAsHorizontalScroller(Engine.TextStore,System.Single,Engine.Sprite)">
            <summary>
            Draws a textstore object as an assited simple scrolling horizontal display
            This will allow accurate wrapping of proportional text.
            This only works with fonts of fixed width currently (alpha chars):
            Vector
            Robotron (alpha characters)
            Hopping Mappy
            Year 1943
            Arcade large
            arcade pixel
            Silkworm
            </summary>
            <param name="ts">the TextStore containing text information to display</param>
            <param name="zPosition">The Z value for the text sprites</param>
            <param name="spriteAttributes">A sprite containing attributes to copy.</param>
        </member>
        <member name="M:Engine.TextManager.DrawAsHorizontalScroller(Engine.FontSprite,System.String,System.Single,System.Single,Engine.TextAtt,System.Single,Engine.Sprite)">
            <summary>
            Draw a piece of text as an assited simple scrolling horizontal display
            This will allow accurate wrapping of proportional text
            This only works with fonts of fixed width currently (alpha chars):
            Vector
            Robotron (alpha characters)
            Hopping Mappy
            Year 1943
            Arcade large
            arcade pixel
            Silkworm
            </summary>
            <param name="font">font to use</param>
            <param name="text">text to display</param>
            <param name="x">x position to show it at</param>
            <param name="y">y position to show it at</param>
            <param name="attributes">the attriubtes of the text to display</param>
            <param name="zPosition">The Z value for the text sprites</param>
            <param name="spriteAttributes">A sprite containing attributes to copy</param>
        </member>
        <member name="M:Engine.TextManager.DrawAsTypewriter(Engine.TextStore,System.Single,System.Single,Engine.Sprite,Engine.SpriteCallBack)">
            <summary>
            Draw a TextStore object as a series of sprites that appear as if typed
            </summary>
            <param name="ts">The textstore object containing the information about the text to display</param>
            <param name="zPosition">The z position to associate with the sprites produced</param>
            <param name="typeDelay">The delay in seconds between each letter appearing</param>
            <param name="spriteAttributes">A dummy sprite with further attributes to associate with each character
            The following attributes can be set and copied to each character of your text:
            TimerActions all the flashing and killing stuff
            Limit box stuff
            OnShow() - a sprite handler called whenever sprite shown, great for flashing effects
            OnUpdate() - a sprite handler called whenever sprite updated
            OnFuneral() - a sprite handler called when sprite is killed
            OnHide() - a sprite handler called when sprite is hidden
            Layer - overwrites default text layer
            Velocity 
            Type
            RotationVelocity
            UpdateRate - alters timing of sprites updates
            VisibleDebugOutput
            CollisionEnable();
            </param>
            <param name="lineBreakHandler">an eventHandler called when a line break would occur</param>
        </member>
        <member name="M:Engine.TextManager.Draw(Engine.TextStore)">
            <summary>
            Draws the specifed text already held in a text store
            </summary>
            <param name="thisTextStore">The TextStore object containing the details of the text to draw</param>
            <remarks>This needs to be run from the GameLoop() subroutine so it is drawn every
            frame</remarks>
        </member>
        <member name="M:Engine.TextManager.Draw(Engine.FontSprite,System.String,System.Single,System.Single,Engine.TextAtt)">
            <summary>
            Draw the specified text without the need to create a textstore object yourself
            </summary>
            <param name="font">font to use</param>
            <param name="text">text to display</param>
            <param name="x">x position to show it at</param>
            <param name="y">y position to show it at</param>
            <param name="attributes">the attriubtes of the text to display</param>
        </member>
        <member name="M:Engine.TextManager.Draw(Engine.FontSprite,System.String,System.Single,System.Single)">
            <summary>
            Draw the specified text without the need to create a textstore object yourself, aligning to the topLeft
            </summary>
            <param name="font">font to use</param>
            <param name="text">text to display</param>
            <param name="x">x position to show it at</param>
            <param name="y">y position to show it at</param>
        </member>
        <member name="M:Engine.TextManager.Requested(Engine.TextStore)">
            <summary>
            Attempts (!) to see if this Textstore as already been requested
            This tries to ensure that text requested during several consecutive update calls
            is not rendered multiple times, when draw hasn't been called yet.
            </summary>
            <param name="thisTextStore">the new textstore to render</param>
            <returns>true if we think already requested or false if we don't think it exists</returns>
        </member>
        <member name="M:Engine.TextManager.Requested(System.Single,System.Single)">
            <summary>
            Attempts (!) to see if this Textstore as already been requested
            This tries to ensure that text requested during several consecutive update calls
            is not rendered multiple times, when draw hasn't been called yet.
            </summary>
            <param name="x">x position to render at</param>
            <param name="y">y position to render at</param>
            <returns>true if we think already requested or false if we don't think it exists</returns>
        </member>
        <member name="M:Engine.TextManager.DrawQuick(Engine.TextStore)">
            <summary>
            Provides a method to quickly draw text for simple text
            </summary>
            <param name="thisTextStore">The TextStore object containing the text to be drawn</param>
            <remarks>This needs to be run from the GameLoop() subroutine so it is drawn every
            frame</remarks>
        </member>
        <member name="M:Engine.TextManager.DrawQuick(Engine.FontSprite,System.String,System.Single,System.Single,Engine.TextAtt)">
            <summary>
            Provides a method to quickly draw text for simple text, along a single line, works
            quicker than the full Draw() method
            </summary>
            <param name="font">font to use</param>
            <param name="text">text to display</param>
            <param name="x">x position to show it at</param>
            <param name="y">y position to show it at</param>
            <param name="attributes">the attriubtes of the text to display</param>
            <remarks>This needs to be run from the GameLoop() subroutine so it is drawn every
            frame</remarks>
        </member>
        <member name="M:Engine.TextManager.DrawAsTypewriterFinal(Engine.TextStore,System.Single,System.Single,Engine.Sprite,Engine.SpriteCallBack,System.Boolean,System.Int32)">
            <summary>
            Draw a TextStore object as a series of sprites that appear as if typed
            used by both typewriter and normal sprite drawn text
            </summary>
            <param name="ts">The textstore object containing the information about the text to display</param>
            <param name="z">The z position to associate with the sprites produced</param>
            <param name="typeDelay">The delay in seconds between each letter appearing</param>
            <param name="spriteAttributes">A dummy sprite with further attributes to associate with each character</param>
            <param name="lineBreakHandler">an eventHandler called when a line break would occur</param>
            <param name="notTyped">Determines if timer actions are overwritten or not</param>
            <param name="scrollDirection">If zero parameter is ignored - -1 or 1 is attachment for wrap buddy</param>
            <remarks>Used internally by the typewriter and sprite text methods</remarks>
        </member>
        <member name="M:Engine.TextManager.UseAttributes(Engine.Sprite,Engine.Sprite,System.Boolean,System.Single)">
            <summary>
            sets the sprites to use attributes pre-specified
            
            attributes usable:
            Timer
            Limit
            OnUpdate
            OnFuneral
            OnHide
            OnShow
            OnPoint
            Layer
            Velocity
            Type
            RotationVelocity
            UpdatePeriod
            Debug
            CollisionActive
            PerspectiveProjection
            Alpha ?? unsure as to implcations of this
            </summary>
            <param name="s">The sprite to update</param>
            <param name="spriteAttributes">The sprite with required attributes</param>
            <param name="useTimer">If true then timeractions cloned from given sprite</param>
            <param name="typeDelay">delay value - but not used ??</param>
        </member>
        <member name="M:Engine.TextManager.SpriteGenerateTextAsFrames(Engine.FontSprite,System.String,System.Single,Microsoft.Xna.Framework.Color)">
            <summary>
            Creates a sprite with a sequence of frames which are the individual characters
            of the text given
            </summary>
            <param name="font">the font to use</param>
            <param name="text">The string containing the character frames you want</param>
            <param name="size">1.0f is stock size</param>
            <param name="colour">the wash to apply to the sprite</param>
            <returns>A sprite ready to be used as you wish</returns>
            <remarks>Can be used for track based signage</remarks>
        </member>
        <member name="M:Engine.TextManager.SpriteGenerateCharacter(Engine.FontSprite,System.String,System.Single,Microsoft.Xna.Framework.Color)">
            <summary>
            produces a Sprite for a the single character given, to be used for score entry etc...
            </summary>
            <param name="font">the font to use</param>
            <param name="charRequired">The single character required</param>
            <param name="size">1.0f is stock size</param>
            <param name="colour">the wash to apply to the sprite</param>
            <returns>A sprite ready to be used as you wish</returns>
        </member>
        <member name="M:Engine.TextManager.SpriteGenerateCharacter(Engine.FontSprite,System.Char,System.Single,Microsoft.Xna.Framework.Color)">
            <summary>
            produces a Sprite for a single character, to be used for score entry etc...
            </summary>
            <param name="font">the font to use</param>
            <param name="charRequired">The single character required</param>
            <param name="size">1.0f is stock size</param>
            <param name="colour">the wash to apply to the sprite</param>
            <returns>A sprite ready to be used as you wish</returns>
        </member>
        <member name="M:Engine.TextManager.SpriteGenerateFrameForCharacter(Engine.Sprite,Engine.FontSprite,System.String)">
            <summary>
            Generates and adds a frame for a character to a sprite
            </summary>
            <param name="sprite">The sprite to add the frame too</param>
            <param name="font">The font required</param>
            <param name="charRequired">The character required</param>
            <remarks>Very useful for High score entry work</remarks>
        </member>
        <member name="M:Engine.TextManager.GetCharacterAlphaGrid(Engine.FontSprite,System.String)">
            <summary>
            Gets a 2d byte array containing the transparent pixels for a given character of a given font, 
            this can be used to generate per-pixel sprites or particles from a font to make weird font based shapes
            </summary>
            <param name="font">The font to get the character from</param>
            <param name="charRequired">The character to obtain</param>
            <returns>a 2d array of alpha bytes</returns>
        </member>
        <member name="M:Engine.TextManager.MenuText(Engine.FontSprite,System.String,System.Single,System.Single,Engine.TextAtt)">
            <summary>
            returns a TextStore object that defines the text for a text based menu item 
            </summary>
            <param name="font">The  font to use</param>
            <param name="txt">The text to display</param>
            <param name="x">x position</param>
            <param name="y">y position</param>
            <param name="tp">the text properties to use</param>
            <returns> TextStore object that can added as a MenuItem</returns>
        </member>
        <member name="M:Engine.TextManager.CreateCharacterSpritesList(Engine.FontSprite,System.String,System.Single,Microsoft.Xna.Framework.Color)">
            <summary>
            Creates a list of MenuSprites with colours and names set
            Ready to be added to the menu using AddListOfSprites 
            </summary>
            <param name="requestedChars">a string with the characters you want</param>
            <param name="colour">The colour of the text</param>
            <param name="size">Scale of each sprite (1 is normal)</param>
            <param name="font">The FontSprite to use for the text</param>
            <returns>A list of menu sprites</returns>
            <remarks>This should be used when you wish to create a number of separate
            sprites each with a frame based on the characters in the string given.
            This can be used for building a menu to allow users to select characters, during
            name entry for high score entry.</remarks>
        </member>
        <member name="M:Engine.TextManager.SpriteGenerateCharacterSpritesList(Engine.FontSprite,System.String,System.Single,Microsoft.Xna.Framework.Color)">
            <summary>
            Creates a list of MenuSprites with colours and names set
            Ready to be added to the menu using AddListOfSprites 
            </summary>
            <param name="requestedChars">a string with the characters you want</param>
            <param name="colour">The colour of the text</param>
            <param name="size">Scale of each sprite (1 is normal)</param>
            <param name="font">The FontSprite to use for the text</param>
            <returns>A list of menu sprites</returns>
            <remarks>This should be used when you wish to create a number of separate
            sprites each with a frame based on the characters in the string given.
            This can be used for building a menu to allow users to select characters, during
            name entry for high score entry.</remarks>
        </member>
        <member name="M:Engine.TextManager.RemoveMyPendingText(System.Int32)">
            <summary>
            attempts to remove any pending textstores from the pending array with this originator
            </summary>
            <param name="code">The code to remove if possible</param>
        </member>
        <member name="T:Engine.TextStore">
            <summary>
            Holds all pending text to draw.
            </summary>
            <remarks>This is used by the GameManager when it receives a DrawText method call.
            There is no need to use this directly it will have absolutly no effect.</remarks>
        </member>
        <member name="F:Engine.TextStore.originator">
            <summary>
            holds the creator of this textstore, this allows unwanted pending items
            to be removed during update cycles for instance by the menu manager clearing
            any pending text when a text menu has made a new selection before the scene was rendered
            when only one item should be shown
            </summary>
        </member>
        <member name="F:Engine.TextStore.OnUpdate">
            <summary>
            Holds the delegate passed by the user
            </summary>
        </member>
        <member name="F:Engine.TextStore.DontClear">
            <summary>
            maybe not needed
            </summary>
        </member>
        <member name="F:Engine.TextStore._text">
            <summary>
            The text to display
            </summary>
        </member>
        <member name="F:Engine.TextStore._pos">
            <summary>
            position to display the text at
            </summary>
        </member>
        <member name="F:Engine.TextStore._font">
            <summary>
            The font being used
            </summary>
        </member>
        <member name="F:Engine.TextStore.Properties">
            <summary>
            holds the properties for this text
            </summary>
        </member>
        <member name="F:Engine.TextStore._widthSoFar">
            <summary>
            holds number of pixels displayed so far while drawing this text
            </summary>
        </member>
        <member name="F:Engine.TextStore.quick">
            <summary>
            determines if quick formatting is to be performed on text
            </summary>
        </member>
        <member name="F:Engine.TextStore.CountTowardsRenderTotal">
            <summary>
            determines if the text drawn for this textstore should count towards
            the total worked out for all text drawn. Set this to false if you are debugging
            text display and need to count how many characters, but display this without affecting the count
            </summary>
        </member>
        <member name="M:Engine.TextStore.RenderLengthLine(System.Int32)">
            <summary>
            looks for next line break
            </summary>
            <param name="start">starting position along the string</param>
            <returns>length of the current line</returns>
        </member>
        <member name="M:Engine.TextStore.RenderLengthSingleLine">
            <summary>
            Quick version of line length for a single text line
            </summary>
            <returns>width in pixels of visibly rendered text</returns>
        </member>
        <member name="P:Engine.TextStore.RenderHeight">
            <summary>
            Returns the height in pixels this textstore will take to render
            </summary>
        </member>
        <member name="P:Engine.TextStore.RenderLines">
            <summary>
            Returns the number of lines this text would occupy with current wrap settings
            </summary>
        </member>
        <member name="P:Engine.TextStore.RenderHeightFull">
            <summary>
            returns the number of pixels this text would take to render
            </summary>
            <remarks>Rough approximation at the moment, needs some work</remarks>
        </member>
        <member name="M:Engine.TextStore.#ctor(Engine.FontSprite,System.String,System.Single,System.Single,Engine.TextAtt)">
            <summary>
            Create a new piece of pending text specifying standard drawing parameters
            </summary>
            <param name="spriteFont">The FontSprite to draw the text with</param>
            <param name="txt">The string to displaye</param>
            <param name="x">x position of top left corner of text</param>
            <param name="y">y position of top left corner of text</param>
            <param name="props">The text property</param>
        </member>
        <member name="M:Engine.TextStore.#ctor(Engine.FontSprite,System.String,System.Single,System.Single,Engine.TextAtt,Engine.TextHandler)">
            <summary>
            Create a new piece of pending text specifying standard drawing parameters as well as
            information about display angle for angled text
            </summary>
            <param name="spriteFont">The FontSprite to draw the text with</param>
            <param name="txt">The string to displaye</param>
            <param name="x">x position of top left corner of text</param>
            <param name="y">y position of top left corner of text</param>
            <param name="props">The text property</param>
            <param name="userUpdate">The name of the subroutine to call after each character is drawn</param>
            <remarks>angleChange is not actually doing anything yet I'm currently testing stuff</remarks>
        </member>
        <member name="M:Engine.TextStore.RemoveIllegalChars">
            <summary>
            Removes any illegal characters from the string given text
            </summary>
        </member>
        <member name="P:Engine.TextStore.NextCharToBeDrawnPosition">
            <summary>
            gets the position of the last character drawn
            </summary>
        </member>
        <member name="P:Engine.TextStore.NextCharToBeDrawn">
            <summary>
            gets the last character drawn
            </summary>
        </member>
        <member name="P:Engine.TextStore.Text">
            <summary>
            Gets or Sets the text to display
            </summary>
            <remarks>Do not use this object directly</remarks>
            <value>A String value</value>
        </member>
        <member name="P:Engine.TextStore.Pos">
            <summary>
            Gets or Sets the position of the top left hand corner of the text
            </summary>
            <remarks>Do not use this object directly</remarks>
            <value>A Vector2 value</value>
        </member>
        <member name="P:Engine.TextStore.X">
            <summary>
            gets or sets the X position of the TextStore object
            </summary>
        </member>
        <member name="P:Engine.TextStore.Y">
            <summary>
            gets or sets the X position of the TextStore object
            </summary>
        </member>
        <member name="P:Engine.TextStore.Font">
            <summary>
            Gets or Sets the sprite font to use for this text
            </summary>
            <remarks>Do not use this object directly</remarks>
            <value>A FontSprite value</value>
        </member>
        <member name="P:Engine.TextStore.PixelsDrawn">
            <summary>
            gets the number of pixels used on screen so far while drawing this line of text
            </summary>
        </member>
        <member name="M:Engine.TextStore.PixelsDrawnReset">
            <summary>
            resets the number of pixels drawn, use this in a texthandler when you have forced the text
            onto a new line, so you can count the width again.
            </summary>
        </member>
        <member name="P:Engine.TextStore.SwapCurrentCharWithChar">
            <summary>
            sets the current character to another character
            </summary>
        </member>
        <member name="P:Engine.TextStore.SwapCurrentCharWithString">
            <summary>
            sets the current character to another string
            </summary>
        </member>
        <member name="M:Engine.TextStore.CharOnScreen(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Rectangle,System.Single,System.Int32,System.Int32)">
            <summary>
            Works out roughly whether the character to be drawn is visible on screen.
            This allows the renderer to skip non-visible characters and hence speed up text drawing
            </summary>
            <param name="p">Position on screen</param>
            <param name="r">Rectangle character occupies</param>
            <param name="scale">the scale factor of the font</param>
            <param name="w">The Width of the screen</param>
            <param name="h">The Height of the screen</param>
            <returns>True if it is on screen, False otherwise</returns>
        </member>
        <member name="M:Engine.TextStore.CheckAndConvert(Engine.FontSprite,System.String)">
            <summary>
            Checks a string for illegal characters and swaps them for legal ones
            </summary>
            <param name="f">Font used</param>
            <param name="s">the string to check</param>
            <returns>A safe string</returns>
        </member>
        <member name="M:Engine.TextStore.QuickDirtyDraw(Microsoft.Xna.Framework.Graphics.SpriteBatch,Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Vector2)">
            <summary>
            A quick draw method for straight non correcting text
            </summary>
            <param name="sr">SpriteBatch to use</param>
            <param name="vp">left hand corner of viewport</param>
            <param name="off">offset to apply to the text</param>
            <returns></returns>
        </member>
        <member name="P:Engine.TextStore.Depth">
            <summary>
            determines the draw layer of the text (between 0 back and forward 1) default is 0.8f 
            </summary>
        </member>
        <member name="M:Engine.TextStore.Draw(Microsoft.Xna.Framework.Graphics.SpriteBatch,Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Draw piece of text on screen
            </summary>
            <param name="sr">The spritebatch to be used</param>
            <param name="vp">The top left corner of view port</param>
            <param name="off">An offset to apply to the text</param>
            <remarks>This is called by the GameManager.Draw() method and should not be called manually.
            Bendy text will be coming in a future version of the engine</remarks>
        </member>
        <member name="P:Engine.TextStore.Area">
            <summary>
            Gets the area occupied by the text
            </summary>
        </member>
        <member name="M:Engine.TextStore.FixAlign(Microsoft.Xna.Framework.Vector2,Engine.Align,System.Single,System.Single)">
            <summary>
            examines the properties of the text to be displayed
            </summary>
            <param name="pos">the vector2 value that holds the given x and y text position</param>
            <param name="h"></param>
            <param name="ta"></param>
            <param name="w"></param>
            <remarks>Defined as a static member so I can use it from the EngineManager.DrawTextOnceAsSprite
            method to fix its Align</remarks>
        </member>
        <member name="M:Engine.TextStore.AdjustAlignRotation(Microsoft.Xna.Framework.Vector2,Engine.Align,System.Single,System.Single)">
            <summary>
            Adjusts Align during rotated text
            </summary>
            <param name="pos">Position of text</param>
            <param name="ta">Align</param>
            <param name="w">width of text</param>
            <param name="h">height of text</param>
            <returns></returns>
        </member>
        <member name="M:Engine.TextStore.DrawWithUpdate(Microsoft.Xna.Framework.Graphics.SpriteBatch,Microsoft.Xna.Framework.GraphicsDeviceManager,Microsoft.Xna.Framework.Point)">
            <summary>
            Draw piece of text on screen using a TextHandler
            </summary>
            <param name="sr">The spritebatch to be used</param>
            <param name="g">The GraphicsDeviceManager being used to get hold of screen dimensions</param>
            <param name="vp">Viewport top left</param>
            <remarks>This is called by the GameManager.Draw() method and should not be called manually.
            The TextHandler is responsible for all manipulation of the text to display</remarks>
        </member>
        <member name="T:Engine.Tile">
            <summary>
            specifies a particular tile for use in a Tilemap
            </summary>
        </member>
        <member name="M:Engine.Tile.ToString">
            <summary>
            returns information about the tile
            </summary>
            <returns></returns>
        </member>
        <member name="F:Engine.Tile.offsets">
            <summary>
            holds slope offsets for height map of tile, defaults to 2 elements to be used for sloping tiles
            but can be changed to any number of elements if required
            </summary>
        </member>
        <member name="P:Engine.Tile.LeftOffset">
            <summary>
            quick reference to the left hand slope offset of a tile
            </summary>
        </member>
        <member name="P:Engine.Tile.RightOffset">
            <summary>
            quick reference to the right hand slope offsets of a tile
            </summary>
        </member>
        <member name="M:Engine.Tile.LerpHeight(System.Single)">
            <summary>
            works out the slope offset given a position along a tile
            </summary>
            <param name="distanceFromLeft"></param>
            <returns>the effective slope offset at this position</returns>
        </member>
        <member name="M:Engine.Tile.LerpHeight(System.Single,System.Single)">
            <summary>
            linear interpolates the offset along a tile returning the actual tile y offset from the top of the tile
            </summary>
            <param name="xpos">the x position to check inside the tile</param>
            <param name="tileX">left hand position of the tile</param>
            <returns>The actual offset from the top of tile based on the left and right depth positions of the tile</returns>
        </member>
        <member name="M:Engine.Tile.LerpTopPosition(System.Single,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Calculates the physical y top position of the slope at the xpos offset along the tile given
            </summary>
            <param name="xpos">position to check for offset of</param>
            <param name="tilepos">current tile topleft TilePosition() will give you this</param>
            <returns>y value for top of slope at the xpos given</returns>
        </member>
        <member name="M:Engine.Tile.PassableSlope(System.Int32)">
            <summary>
            determines if a slope is facing towards the players direction of movement and therefore can be climbed or not
            </summary>
            <param name="direction"></param>
            <returns>true if we can move up slope, false if we can't</returns>
        </member>
        <member name="P:Engine.Tile.IsSlope">
            <summary>
            returns true if the tile represents a slope
            </summary>
        </member>
        <member name="P:Engine.Tile.IsFlat">
            <summary>
            returns true if the tile represents a standard flat tile object (not sloped)
            </summary>
        </member>
        <member name="F:Engine.Tile.portion">
            <summary>
            holds the rectangle portion from the given texture
            </summary>
        </member>
        <member name="F:Engine.Tile.texture">
            <summary>
            texture this tile refers to
            </summary>
        </member>
        <member name="F:Engine.Tile.wash">
            <summary>
            holds a wash to apply to the tile when rendered (defaults to white)
            </summary>
        </member>
        <member name="M:Engine.Tile.#ctor(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            Creates a new Tile with the given parameters
            </summary>
            <param name="texture">texture containing graphic</param>
            <param name="rectangle">portion of texture with image</param>
        </member>
        <member name="M:Engine.Tile.#ctor(Microsoft.Xna.Framework.Graphics.Texture2D,System.Int32,System.Int32)">
            <summary>
            Creates a new Tile using the entire texture given with height map values
            </summary>
            <param name="texture">texture containing graphic</param>
            <param name="left">the height offset at the left hand edge of the tile</param>
            <param name="right">the height offset at the right hand edge of the tile</param>
        </member>
        <member name="M:Engine.Tile.#ctor(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle,System.Int32,System.Int32)">
            <summary>
            Creates a new Tile with using the texture portion and with height map values
            </summary>
            <param name="texture">texture containing graphic</param>
            <param name="rectangle">portion of texture with image</param>
            <param name="left">the height offset at the left hand edge of the tile</param>
            <param name="right">the height offset at the right hand edge of the tile</param>
        </member>
        <member name="M:Engine.Tile.#ctor(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Color,System.Int32,System.Int32)">
            <summary>
            Creates a new Tile with the given parameters including a wash colour and height map values
            </summary>
            <param name="texture">texture containing graphic</param>
            <param name="rectangle">portion of texture with image</param>
            <param name="wash">The tint to apply to the tile when rendered</param>
            <param name="left">the height offset at the left hand edge of the tile</param>
            <param name="right">the height offset at the right hand edge of the tile</param>
        </member>
        <member name="M:Engine.Tile.#ctor(Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            Creates a new Tile with the which uses the entire texture specified
            </summary>
            <param name="texture">texture containing graphic</param>
        </member>
        <member name="M:Engine.Tile.#ctor">
            <summary>
            constructs an empty tile
            </summary>
        </member>
        <member name="M:Engine.Tile.#ctor(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Color)">
            <summary>
            Creates a new Tile with the given parameters including a wash colour
            </summary>
            <param name="texture">texture containing graphic</param>
            <param name="rectangle">portion of texture with image</param>
            <param name="wash">The tint to apply to the tile when rendered</param>
        </member>
        <member name="T:Engine.TileMap">
            <summary>
            Specifies the type and structure of a particular tilemap layer
            </summary>
        </member>
        <member name="F:Engine.TileMap.defaultTileSize">
            <summary>
            a default size to use for tile width and height
            works well with 800x600 and 1280x720
            </summary>
        </member>
        <member name="F:Engine.TileMap.LEFT">
            <summary>
            number representing left direction in tilemap
            </summary>
        </member>
        <member name="F:Engine.TileMap.RIGHT">
            <summary>
            number representing right direction in tilemap
            </summary>
        </member>
        <member name="F:Engine.TileMap.UP">
            <summary>
            number representing up direction in tilemap
            </summary>
        </member>
        <member name="F:Engine.TileMap.DOWN">
            <summary>
            number representing down direction in tilemap
            </summary>
        </member>
        <member name="F:Engine.TileMap.UP_LEFT">
            <summary>
            number representing NW direction in tilemap
            </summary>
        </member>
        <member name="F:Engine.TileMap.UP_RIGHT">
            <summary>
            number representing NE direction in tilemap
            </summary>
        </member>
        <member name="F:Engine.TileMap.DOWN_LEFT">
            <summary>
            number representing SE direction in tilemap
            </summary>
        </member>
        <member name="F:Engine.TileMap.DOWN_RIGHT">
            <summary>
            number representing SE direction in tilemap
            </summary>
        </member>
        <member name="F:Engine.TileMap.NONE">
            <summary>
            no direction or not moving
            </summary>
        </member>
        <member name="F:Engine.TileMap.EMPTY">
            <summary>
            empty tile (no tile exists at this location)
            </summary>
        </member>
        <member name="F:Engine.TileMap.myTileList">
            <summary>
            the unique tiles that this sheet uses (calculated if generated automatically)
            or overwritten if generated by the user
            </summary>
        </member>
        <member name="P:Engine.TileMap.tileCount">
            <summary>
            holds the number of unique tiles used by this tilemap
            </summary>
        </member>
        <member name="P:Engine.TileMap.MyTileList">
            <summary>
            gets or sets the array of Tiles that are used to draw this tilemap
            You only need to set this if you are dynamically creating your own Tilemaps
            If you are just tiling a texture (graphic) you should not alter this
            </summary>
        </member>
        <member name="F:Engine.TileMap.dTiles">
            <summary>
            the tile indexes for drawing this tilemap
            empty tiles recorded with a -1 index
            this is row major (row specified as first index then column)
            </summary>
        </member>
        <member name="P:Engine.TileMap.Map">
            <summary>
            gets the tile map used to draw this map
            row major, first index is the row of the tile, second index is the column of the tile
            </summary>
        </member>
        <member name="M:Engine.TileMap.RouteToVector3(System.Collections.Generic.List{Microsoft.Xna.Framework.Point})">
            <summary>
            takes a route of tile locations and converts into vector3 co-ordinates fro a track based sprite for instance
            </summary>
            <param name="route">The route of tile locations to follow</param>
            <returns>A list of vector 3 locations</returns>
        </member>
        <member name="M:Engine.TileMap.RouteToVector2(System.Collections.Generic.List{Microsoft.Xna.Framework.Point})">
            <summary>
            takes a route of tile locations and converts into vector2 co-ordinates for your own path following
            </summary>
            <param name="route">The route of tile locations to follow</param>
            <returns>A list of vector 2 locations</returns>
        </member>
        <member name="M:Engine.TileMap.RouteToVector3(Microsoft.Xna.Framework.Vector3,System.Collections.Generic.List{Microsoft.Xna.Framework.Point})">
            <summary>
            takes a route of tile locations and converts into vector3 co-ordinates fro a track based sprite for instance
            </summary>
            <param name="route">The route of tile locations to follow</param>
            <param name="prePend">A position to start the route from (use the sprites current position so you don't jump to the centre of current tile)</param>
            <returns>A list of vector 3 locations</returns>
        </member>
        <member name="M:Engine.TileMap.RouteToVector2(Microsoft.Xna.Framework.Vector2,System.Collections.Generic.List{Microsoft.Xna.Framework.Point})">
            <summary>
            takes a route of tile locations and converts into vector2 co-ordinates for your own path following
            </summary>
            <param name="route">The route of tile locations to follow</param>
            <param name="prePend">A position to start the route from (use the sprites current position so you don't jump to the centre of current tile)</param>
            <returns>A list of vector 2 locations</returns>
        </member>
        <member name="M:Engine.TileMap.TileDirectionTo3D(System.Int32)">
            <summary>
            creates a vector3 direction vector from a tile direction
            </summary>
            <param name="tileDirection"></param>
            <returns>unit direction vector3, zero if no ordinal direction</returns>
        </member>
        <member name="M:Engine.TileMap.TileDirectionTo2D(System.Int32)">
            <summary>
            creates a vector2 direction vector from a tile direction
            </summary>
            <param name="tileDirection"></param>
            <returns>unit direction vector2, zero if no ordinal direction</returns>
        </member>
        <member name="M:Engine.TileMap.SetGraphic(Microsoft.Xna.Framework.Point,System.Int32)">
            <summary>
            sets a tile value at a given location
            </summary>
            <param name="location">The tile position, x is the column, y is the row</param>
            <param name="tile">the tile number to place here, -1 clears a tile</param>
            <code>
            //this code picks a tile location based on a sprites position and uses
            //this to set a tile value at that location
            
            Point tile = GFX.tmTheGrid.TileLocation(cycle.Centre.X, cycle.Bottom + 1);
            GFX.tmTheGrid.SetTile(tile, tileNumber);
            </code>
        </member>
        <member name="M:Engine.TileMap.SetCollision(Microsoft.Xna.Framework.Point,System.Int32)">
            <summary>
            sets a collision tile to a particular value
            </summary>
            <param name="location">The tile position, x is the column, y is the row</param>
            <param name="tile">the collision tile number to place here</param>
        </member>
        <member name="M:Engine.TileMap.CleanUp">
            <summary>
            overridable called when a TileMap is removed
            add code to remove/kill any other resources managed by the TileMap (helper/friend sprites, events etc...)
            if you don't they could still be active
            </summary>
        </member>
        <member name="M:Engine.TileMap.Info(System.Int32)">
            <summary>
            gets the tile for a particular tile number
            </summary>
            <param name="tileNumber"></param>
            <returns></returns>
        </member>
        <member name="M:Engine.TileMap.GetGraphic(Microsoft.Xna.Framework.Point)">
            <summary>
            gets the contents of a tile from the given tile location
            </summary>
            <param name="location">The tile position, x is the column, y is the row</param>
            <returns>contents of the tile or -1 if the tile is not within the tilemap</returns>
        </member>
        <member name="M:Engine.TileMap.GetGraphic(Microsoft.Xna.Framework.Point,System.Int32,System.Int32)">
            <summary>
            gets the contents of a tile from the given tile location and direction
            </summary>
            <param name="location">tile location to retrieve</param>
            <param name="direction">TileMap.Left, TileMap.Right, TileMap.Right, TileMap.Down</param>
            <param name="distance">tile offset</param>
            <returns>tile id or -1 if no tile exists or location is not valid</returns>
        </member>
        <member name="M:Engine.TileMap.GetCollision(Microsoft.Xna.Framework.Point)">
            <summary>
            gets the contents of a collision tile from the given tile location
            </summary>
            <param name="location">The tile position, x is the column, y is the row</param>
            <returns>contents of the tile or -1 if the tile is not within the tilemap</returns>
        </member>
        <member name="M:Engine.TileMap.GetCollision(Microsoft.Xna.Framework.Point,System.Int32,System.Int32)">
            <summary>
            gets the contents of a collision tile from the given tile location and direction
            </summary>
            <param name="location">tile location to retrieve</param>
            <param name="direction">TileMap.Left, TileMap.Right, TileMap.Right, TileMap.Down</param>
            <param name="distance">tile offset</param>
            <returns>tile id or -1 if no tile exists or location is not valid</returns>
        </member>
        <member name="M:Engine.TileMap.LoadMapFromStringFile(System.String)">
             <summary>
             uses a string map file that contains the information on map size and tile map values
             size is determined automatically by the width of data and number of lines in map.
             
             first string is a string containing the tile positions for the characters.
             eg if the first string contained "abcd" this would convert
             subsequent tile values from a to 0, b to 1, c to 2, and d to tile 3
             any other character turned into a null tile -1
             
             second string in file contains the width and height of the tiles in tilemap
             
             example file start - lines starting with ; are ignored
             
             ;a - is border
             ;b - is a breakable wall character
             ;c - is player start position
             ;x - ignored so empty tile is placed at this location
             abcdefg
             ;tile width 16 and 20 high
             16,20
             aaaaaaa
             axxbxxa
             axxcxxa
             axxbxxa
             aaaaaaa
             
             would create a tile map 5 rows and 7 columns, tile size 16 pixles wide and 20 pixels high with 7 different tiles
             a border of tile 0 with tile 1 in a line down the centre, null tiles everywhere else
            
             </summary>
             <param name="filename">filename containing the map</param>
             <returns>true if read correctly</returns>
             <remarks></remarks>
        </member>
        <member name="M:Engine.TileMap.LoadMapFromDelimetedFile(System.String,System.Char)">
             <summary>
             uses a ascii comma separated map file that contains the information on map size and tile map values
             size is determined automatically by the width of data and number of lines in map.
             
             first string is a string containing the tile positions for the characters.
             eg if the first string contained "abcd" this would convert
             subsequent tile values from a to 0, b to 1, c to 2, and d to tile 3
             any other character turned into a null tile -1
             
             second string in file contains the width and height of the tiles in tilemap
             
             exmaple file start, using space as a delimeter
             
             abcdefg
             16,20
             a a a a a a a
             a x x b x x a
             a x x b x x a
             a x x b x x a
             a a a a a a a
             
             would create a tile map 5 rows and 7 columns, tile size 16 pixles wide and 20 pixels high with 7 different tiles
             a border of tile 0 with tile 1 in a line down the centre, null tiles everywhere else
            
             </summary>
             <param name="filename">filename containing the map</param>
             <param name="delimeter">The character that separates each tile reference in the map</param>
             <returns>true if read correctly</returns>
             <remarks></remarks>
        </member>
        <member name="M:Engine.TileMap.LoadMapFromCSVFile(System.String)">
             <summary>
             uses a ascii comma separated map file that contains the information on map size and tile map values
             size is determined automatically by the width of data and number of lines in map.
             
             first string is a string containing the tile positions for the characters.
             eg if the first string contained "abcd" this would convert
             subsequent tile values from a to 0, b to 1, c to 2, and d to tile 3
             any other character turned into a null tile -1
             
             second string in file contains the width and height of the tiles in tilemap
             
             exmaple file start
             
             abcdefg
             16,20
             a,a,a,a,a,a,a
             a,x,x,b,x,x,a
             a,x,x,b,x,x,a
             a,x,x,b,x,x,a
             a,a,a,a,a,a,a
             
             would create a tile map 5 rows and 7 columns, tile size 16 pixles wide and 20 pixels high with 7 different tiles
             a border of tile 0 with tile 1 in a line down the centre, null tiles everywhere else
            
             </summary>
             <param name="filename">filename containing the map</param>
             <returns>true if read correctly</returns>
             <remarks></remarks>
        </member>
        <member name="M:Engine.TileMap.SetSamplingMap(System.Int32,System.Int32,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            Easily creates the correct sized sampling map based on area chosen and resolution. If you want per pixel sampling for collision set the tile size to 1,1
            </summary>
            <param name="horizontalResolution">resolution of map width must be a factor of map size e.g. if 1000 then 1, 5, 10 etc.. if 1024 needs to be 1, 2, 4, 8 etc...</param>
            <param name="verticalResolution">resolution of map height must be a factor of map size e.g. if 1000 then 1, 5, 10 etc.. if 1024 needs to be 1, 2, 4, 8 etc...</param>
            <param name="Area">The area the map needs to cover (should be same as level size)</param>
            <returns>true if the map was successfully created</returns>
        </member>
        <member name="M:Engine.TileMap.SetSamplingMap(System.Int32,System.Int32,Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            Easily creates the correct sized sampling map based on area chosen and resolution. If you want per pixel sampling for collision set the tile size to 1,1
            </summary>
            <param name="horizontalResolution">resolution of map width must be a factor of map size e.g. if 1000 then 1, 5, 10 etc.. if 1024 needs to be 1, 2, 4, 8 etc...</param>
            <param name="verticalResolution">resolution of map height must be a factor of map size e.g. if 1000 then 1, 5, 10 etc.. if 1024 needs to be 1, 2, 4, 8 etc...</param>
            <param name="tex">The texture whose dimensions specifies the area the map needs to cover (should be same as level size)</param>
            <returns>true if the map was successfully created</returns>
        </member>
        <member name="M:Engine.TileMap.SetSamplingMap(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Easily creates the correct sized sampling map based on area chosen and resolution. If you want per pixel sampling for collision set the tile size to 1,1
            </summary>
            <param name="horizontalResolution">resolution of map width must be a factor of map size e.g. if 1000 then 1, 5, 10 etc.. if 1024 needs to be 1, 2, 4, 8 etc...</param>
            <param name="verticalResolution">resolution of map height must be a factor of map size e.g. if 1000 then 1, 5, 10 etc.. if 1024 needs to be 1, 2, 4, 8 etc...</param>
            <param name="width">The width of the area the map needs to cover (should be same as level size)</param>
            <param name="height">The height of the area the map needs to cover (should be same as level size)</param>
            <returns>true if the map was successfully created</returns>
        </member>
        <member name="M:Engine.TileMap.SetMap(System.Int32,System.Int32,System.Int32[0:,0:])">
            <summary>
            Manually sets the tilemap, if you want an empty tile (no content than place -1)
            Tile maps are a 2d array of integers referring to your tilelist.
            row major, first index is the row of the tiel, second index is the column of the tile
            It is your responsibility to ensure the tileList contains entries for tiles in your tilemap
            </summary>
            <param name="map">The 2d array of integers comprising the map</param>
            <param name="tileWidth">width of a tile</param>
            <param name="tileHeight">height of a tile</param>
            <returns>true if map given meets current Map definition, false if different from current spec
            If false new settings are made for map metrics</returns>
        </member>
        <member name="M:Engine.TileMap.ProcessGraphicMap(Engine.TileCallBack)">
            <summary>
            traverses the map and sends the call back the tile and location being processed
            </summary>
            <param name="tileProcessor">The method to call with tile data</param>
        </member>
        <member name="M:Engine.TileMap.SetMapCopy(System.Int32,System.Int32,System.Int32[0:,0:])">
            <summary>
            Manually sets the tilemap making a copy of the original so any dynamic changes
            will not affect the original map, if you want an empty tile (no content than place -1)
            Tile maps are a 2d array of integers referring to your tilelist.
            row major, first index is the row of the tiel, second index is the column of the tile
            It is your responsibility to ensure the tileList contains entries for tiles in your tilemap
            </summary>
            <param name="map">The 2d array of integers comprising the map which we want to copy without destroying</param>
            <param name="tileWidth">width of a tile</param>
            <param name="tileHeight">height of a tile</param>
            <returns>true if map given meets current Map definition, false if different from current spec
            If false new settings are made for map metrics</returns>
        </member>
        <member name="M:Engine.TileMap.SetMapCloneFrom(Engine.TileMap)">
            <summary>
            Attempts to take a tilemap.
            Use this to setup a mini map from an existing tilemap
            you will need to manually setup you tiles in your minimap constructor 
            as well as clone any alpha and colour maps using CopyColorMap and CopyAlphaMap if you need those
            </summary>
            <param name="cloneThis">The tilemap to take the definitions from</param>
        </member>
        <member name="M:Engine.TileMap.CopyColorMap">
            <summary>
            takes a copy of an exisiting colour map
            </summary>
            <returns>copy of color map</returns>
        </member>
        <member name="M:Engine.TileMap.CopyAlphaMap">
            <summary>
            returns a copy of an existing colour map
            </summary>
            <returns>copy of alpha map</returns>
        </member>
        <member name="M:Engine.TileMap.CopyMap">
            <summary>
            gets a copy of the current TileMap
            </summary>
            <returns>a copy of the map for storage purposes</returns>
        </member>
        <member name="F:Engine.TileMap.cTiles">
            <summary>
            Collision tile indexes (same dimensions as the tile map) can refer to any numbers you want
            By default filled with 0
            </summary>
        </member>
        <member name="P:Engine.TileMap.CollisionMap">
            <summary>
            gets or sets the Collision tile indexes (same dimensions as the tile map)
            can refer to any numbers you want
            </summary>
        </member>
        <member name="F:Engine.TileMap._scroll">
            <summary>
            the number of pixels (x,y) that we wish to scroll the tilemap per second
            </summary>
        </member>
        <member name="P:Engine.TileMap.Scroll">
            <summary>
            the number of pixels (x,y) that we wish to scroll the tilemap per second
            </summary>
        </member>
        <member name="P:Engine.TileMap.ScrollX">
            <summary>
            gets or sets the X component of the scrolling for the tilemap
            </summary>
        </member>
        <member name="P:Engine.TileMap.ScrollY">
            <summary>
            gets or sets the Y component of the scrolling for the tilemap
            </summary>
        </member>
        <member name="F:Engine.TileMap._scrollMultiplier">
            <summary>
            the a factor to multiply the scrolling by to make it easier to achieve parallax effects
            default is 1
            </summary>
        </member>
        <member name="P:Engine.TileMap.ScrollMultiplier">
            <summary>
            the a factor to multiply the scrolling by to make it easier to achieve parallax effects
            default is 1
            </summary>
        </member>
        <member name="F:Engine.TileMap._scrollAmount">
            <summary>
            holds pre-calculated scroll and scrollMultiplier
            </summary>
        </member>
        <member name="F:Engine.TileMap.Wash">
            <summary>
            color wash to apply to the entire tilemap if GlobalWash is set to true.
            Which by default is turned off to allow per tile washes instead
            </summary>
        </member>
        <member name="F:Engine.TileMap._alpha">
            <summary>
            internal alpha
            </summary>
        </member>
        <member name="P:Engine.TileMap.Alpha">
            <summary>
            the transparency of the tilemap
            </summary>
        </member>
        <member name="F:Engine.TileMap.UseAlphaMap">
            <summary>
             if true the new AlphaMap is used to determine the transparency of each tile rendered. if false the global Alpha value will be used to render tiles
            </summary>
        </member>
        <member name="F:Engine.TileMap.alphaMap">
            <summary>
            A 2d array that holds an alpha value (a float between 0 and 1)  for individual tiles, this could be used to create fade effects across tilemaps. Only active when UseAlphaMap is set to true, otherwise global Alpha is applied to a tile when rendered.
            The AlphaMap will be created when the tilemap is Constructed populated with full alpha (1.0f)
            </summary>
        </member>
        <member name="P:Engine.TileMap.AlphaMap">
            <summary>
            gets or sets a 2d array that holds an alpha value (a float between 0 and 1)  for individual tiles, this could be used to create fade effects across tilemaps. Only active when UseAlphaMap is set to true, otherwise global Alpha is applied to a tile when rendered
            </summary>
        </member>
        <member name="F:Engine.TileMap.colorMap">
            <summary>
            holds the colour map for the tilemap
            </summary>
        </member>
        <member name="P:Engine.TileMap.ColourMap">
            <summary>
            gets or sets a 2d array that holds a Color wash value for individual tiles, 
            this could be used to black out fade effects across tilemaps. 
            Only active when UseWashMap is set to true, otherwise global or per tile Washing is applied to a tile when rendered
            </summary>
        </member>
        <member name="F:Engine.TileMap.WashMode">
            <summary>
            specifies how to use colour washing when rendering TileMaps, default is Tile
            </summary>
        </member>
        <member name="F:Engine.TileMap._position">
            <summary>
            the current position of the tilemap
            </summary>
        </member>
        <member name="P:Engine.TileMap.Position">
            <summary>
            gets or sets the position of the tilemap
            </summary>
        </member>
        <member name="P:Engine.TileMap.X">
            <summary>
            gets or sets the X position of the tilemap
            </summary>
        </member>
        <member name="P:Engine.TileMap.Y">
            <summary>
            gets or sets the Y position of the tilemap
            </summary>
        </member>
        <member name="F:Engine.TileMap._uniqueTileId">
            <summary>
            holds last id generated
            </summary>
        </member>
        <member name="F:Engine.TileMap.Type">
            <summary>
            specifies type of tilemap we have {back, middle, front, final}
            </summary>
        </member>
        <member name="F:Engine.TileMap._visible">
            <summary>
            specifies whether we can see the tilemap or not
            </summary>
        </member>
        <member name="P:Engine.TileMap.Visible">
            <summary>
            specifies whether we can see the tilemap or not.
            You cannot make a tilemap visible if it has no tiles
            </summary>
        </member>
        <member name="F:Engine.TileMap.IgnoreViewport">
            <summary>
            if true the position of the viewport is irrelevant to the tilemap
            so positioning will be controlled manually
            </summary>
        </member>
        <member name="P:Engine.TileMap.Wrap">
            <summary>
            determines whether we wrap the tilemap in both X and Y if we go outside the bounds
            default is no wrapping
            </summary>
        </member>
        <member name="F:Engine.TileMap.WrapX">
            <summary>
            determines whether we wrap the tilemap in X if we go outside the bounds
            default is no wrapping
            </summary>
        </member>
        <member name="F:Engine.TileMap.WrapY">
            <summary>
            determines whether we wrap the tilemap in Y if we go outside the bounds
            default is no wrapping
            </summary>
        </member>
        <member name="F:Engine.TileMap.RenderProperties">
            <summary>
            Renderproperties of the tilemap you should not need to generally alter these
            </summary>
        </member>
        <member name="F:Engine.TileMap.Name">
            <summary>
            holds the name of the tilemap
            </summary>
        </member>
        <member name="F:Engine.TileMap.nameId">
            <summary>
            unique id creator
            </summary>
        </member>
        <member name="F:Engine.TileMap.Columns">
            <summary>
            width of tilemap in tiles
            </summary>
        </member>
        <member name="P:Engine.TileMap.ColumnCount">
            <summary>
            gets the number of columns in the map
            </summary>
        </member>
        <member name="F:Engine.TileMap.Rows">
            <summary>
            height of tilemap in tiles
            </summary>
        </member>
        <member name="P:Engine.TileMap.RowCount">
            <summary>
            gets the number of rows in the map
            </summary>
        </member>
        <member name="F:Engine.TileMap.tileWidth">
            <summary>
            width of an individual tile
            </summary>
        </member>
        <member name="P:Engine.TileMap.TileWidth">
            <summary>
            gets the width of a tile in the current map
            </summary>
        </member>
        <member name="F:Engine.TileMap.tileHeight">
            <summary>
            height of an individual tile
            </summary>
        </member>
        <member name="P:Engine.TileMap.TileHeight">
            <summary>
            gets the height of a tile in the current map
            </summary>
        </member>
        <member name="F:Engine.TileMap.Width">
            <summary>
            width of tilemap in pixels
            </summary>
        </member>
        <member name="F:Engine.TileMap.Height">
            <summary>
            height if tilemap in pixels
            </summary>
        </member>
        <member name="P:Engine.TileMap.Area">
            <summary>
            gets the area of the the tilemap, including the current X and Y displacements
            </summary>
        </member>
        <member name="P:Engine.TileMap.Dimension">
            <summary>
            gets the zero positioned area of the tilemap, for comparisons with screen size
            </summary>
        </member>
        <member name="F:Engine.TileMap.uid">
            <summary>
            internal name of tilemap
            </summary>
        </member>
        <member name="P:Engine.TileMap.Uid">
            <summary>
            gets the unique id for this tilemap
            </summary>
        </member>
        <member name="P:Engine.TileMap.tileIndex">
            <summary>
            Provides access to the tileindex for a file based tilemap
            will be null unless LoadMapFromFile method used
            </summary>
        </member>
        <member name="M:Engine.TileMap.ToString">
            <summary>
            Provides a text friendly version of the TileMap (its name)
            </summary>
            <returns>The name of the tilesheet</returns>
        </member>
        <member name="M:Engine.TileMap.#ctor(Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Point)">
            <summary>
            Creates a new tilemap with the given area and tilesize
            </summary>
            <param name="area">The rectangular area for this tile (only the width and height matter)</param>
            <param name="tileSize">the width and height of each tile</param>
        </member>
        <member name="M:Engine.TileMap.#ctor(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Point,System.Boolean)">
            <summary>
            Creates a new tilemap taking the texture to set the size of the map and specifiying a specific tile size
            and auto tiles the texture when the tilemap is added to the tilemap manager
            </summary>
            <param name="texture">texture size specifies the width and height of the map and auto tile</param>
            <param name="tileSize">the width and height of each tile</param>
            <param name="autotile">set to true to automatically tile the texture given</param>
        </member>
        <member name="M:Engine.TileMap.#ctor(System.String,Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Point,System.Boolean)">
            <summary>
            Creates a new tilemap with the given name taking the texture to set the size of the map and specifiying a specific tile size
            and auto tiles the texture when the tilemap is added to the tilemap manager
            </summary>
            <param name="debugName">name for debug display</param>
            <param name="texture">texture size specifies the width and height of the map and auto tile</param>
            <param name="tileSize">the width and height of a tile in the map (use X and Y of Point)</param>
            <param name="autotile">set to true to automatically tile the texture given</param>
        </member>
        <member name="M:Engine.TileMap.#ctor(Microsoft.Xna.Framework.Graphics.Texture2D,System.Boolean)">
            <summary>
            Creates a new un-named tilemap same size as texture given
            and auto tiles the texture when the tilemap is added to the tilemap manager
            </summary>
            <param name="autotile">set to true to automatically tile the texture given</param>
            <param name="texture">texture size specifies the width and height of the map and auto tile</param>
        </member>
        <member name="M:Engine.TileMap.#ctor(System.String,Microsoft.Xna.Framework.Graphics.Texture2D,System.Boolean)">
            <summary>
            Creates a new named tilemap same size as texture given
            and auto tiles the texture when the tilemap is added to the tilemap manager
            </summary>
            <param name="debugName">name for debug display</param>
            <param name="texture">texture size specifies the width and height of the map and auto tile</param>
            <param name="autotile">set to true to automatically tile the texture given</param>
        </member>
        <member name="M:Engine.TileMap.#ctor(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Point)">
            <summary>
            Creates a new tilemap taking the texture to set the size of the map and specifiying a specific tile size
            and auto tiles the texture when the tilemap is added to the tilemap manager
            </summary>
            <param name="texture">texture size specifies the width and height of the map and auto tile</param>
            <param name="tileSize">the width and height of each tile</param>
        </member>
        <member name="M:Engine.TileMap.#ctor(System.String,Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Point)">
            <summary>
            Creates a new tilemap with the given name taking the texture to set the size of the map and specifiying a specific tile size
            and auto tiles the texture when the tilemap is added to the tilemap manager
            </summary>
            <param name="debugName">name for debug display</param>
            <param name="texture">texture size specifies the width and height of the map and auto tile</param>
            <param name="tileSize">the width and height of a tile in the map (use X and Y of Point)</param>
        </member>
        <member name="M:Engine.TileMap.#ctor(Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            Creates a new un-named tilemap same size as texture given
            and auto tiles the texture when the tilemap is added to the tilemap manager
            </summary>
            <param name="texture">texture size specifies the width and height of the map and auto tile</param>
        </member>
        <member name="M:Engine.TileMap.#ctor(System.String,Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            Creates a new named tilemap same size as texture given
            and auto tiles the texture when the tilemap is added to the tilemap manager
            </summary>
            <param name="debugName">name for debug display</param>
            <param name="texture">texture size specifies the width and height of the map and auto tile</param>
        </member>
        <member name="M:Engine.TileMap.GenErrorIfUntileable(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            checks to see if an auto tile texture is tileable with the given point sizes
            </summary>
            <param name="width">texture width</param>
            <param name="height">texture height</param>
            <param name="tw">tile width selected</param>
            <param name="th">tile height selected</param>
        </member>
        <member name="M:Engine.TileMap.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Creates a new tilemap with the given width and height in pixels using a standard tile size of 40,40
            </summary>
            <param name="debugName">name for debug display</param>
            <param name="width">number of pixels wide</param>
            <param name="height">number of pixels high</param>
        </member>
        <member name="M:Engine.TileMap.#ctor(System.String,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            Creates a new tilemap with the given width and height in pixels using a standard tile size of 40,40
            </summary>
            <param name="debugName">name for debug display</param>
            <param name="area">specify the width and height using a rectangle</param>
        </member>
        <member name="M:Engine.TileMap.#ctor(System.String,Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Point)">
            <summary>
            Creates a new tilemap with the given width and height in pixels using a standard a given tile size
            </summary>
            <param name="debugName">name for debug display</param>
            <param name="area">specify the width and height using a rectangle</param>
            <param name="tileSize">the width and height of a tile in the map (use X and Y of Point)</param>
        </member>
        <member name="M:Engine.TileMap.#ctor(System.String)">
            <summary>
            Creates a basic tilemap ready for a user defined tilemap to be created.
            You must supply the tilemap and tile data manually for this tilemap.
            You will also need to manually set a valid AlphaMap if you choose to use one, this must be the same dimension
            as the tilemap itself.
            </summary>
            <param name="debugName">Name to give the tile map</param>
        </member>
        <member name="M:Engine.TileMap.#ctor">
            <summary>
            creates a basic tilemap with no settings 
            ready to be built
            </summary>
        </member>
        <member name="M:Engine.TileMap.CorrectFactor">
            <summary>
            checks that the tile size settings are factors of the width and height of the tilemap
            </summary>
        </member>
        <member name="M:Engine.TileMap.#ctor(System.String,System.Int32,System.Int32,Microsoft.Xna.Framework.Point)">
            <summary>
            Creates a new tilemap with the given area being the same as the texture and tilesize
            </summary>
            <param name="debugName"></param>
            <param name="width">Width of tilemap</param>
            <param name="height">width of tilemap</param>
            <param name="tileSize">width and height of individual tiles</param>
        </member>
        <member name="M:Engine.TileMap.CreateColorMap">
            <summary>
            creates a full color map for tilemap
            </summary>
        </member>
        <member name="M:Engine.TileMap.FillColourMap(Microsoft.Xna.Framework.Color)">
            <summary>
            fills the colour map with a specified colour
            </summary>
            <param name="fillColour">The colour to set all elements of the map to</param>
        </member>
        <member name="M:Engine.TileMap.CreateAlphaMap">
            <summary>
            creates a full alpha alphamap
            </summary>
        </member>
        <member name="M:Engine.TileMap.FillAlphaMap(System.Single)">
            <summary>
            fills the alpha map with a specified value
            </summary>
            <param name="alphaValue">The alpha value (1f opaque, 0 transparent) to set all elements of the map to</param>
        </member>
        <member name="M:Engine.TileMap.ClearTiles">
            <summary>
            clears tile set to no draw (-1)
            </summary>
        </member>
        <member name="F:Engine.TileMap._draw_tile_nums_position">
            <summary>
            holds a copy of start position to draw text overlay if tile locations
            z holds startX, used by engine debug settings to produce overlay tile info
            </summary>
        </member>
        <member name="F:Engine.TileMap._draw_tile_nums_coordStart">
            <summary>
            holds start column and row for overlay drawing
            </summary>
        </member>
        <member name="F:Engine.TileMap._draw_offset">
            <summary>
            offset calculation goes here
            </summary>
        </member>
        <member name="F:Engine.TileMap._draw_rowCounter">
            <summary>
            loop variable for rows
            </summary>
        </member>
        <member name="F:Engine.TileMap._draw_colCounter">
            <summary>
            loop variable for columns
            </summary>
        </member>
        <member name="F:Engine.TileMap._draw_row">
            <summary>
            row tile to look at
            </summary>
        </member>
        <member name="F:Engine.TileMap._draw_col">
            <summary>
            col tile to look at
            </summary>
        </member>
        <member name="F:Engine.TileMap._draw_col_start">
            <summary>
            the left hand column to restart at for each row
            </summary>
        </member>
        <member name="F:Engine.TileMap._draw_height">
            <summary>
            number of tiles high to draw based on scale
            </summary>
        </member>
        <member name="F:Engine.TileMap._draw_width">
            <summary>
            number of tiles wide to draw based on scale
            </summary>
        </member>
        <member name="F:Engine.TileMap._draw_tile">
            <summary>
            holds the tile currently being processed
            </summary>
        </member>
        <member name="F:Engine.TileMap.debug">
            <summary>
            debug output data is stored here
            </summary>
        </member>
        <member name="F:Engine.TileMap.vc">
            <summary>
            internal nullified rotation centre for rendering 
            </summary>
        </member>
        <member name="M:Engine.TileMap.Draw(Microsoft.Xna.Framework.Graphics.SpriteBatch,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            draws the tilemap using the given spritebatch DOING FULL WRAP RENDERING HERE
            </summary>
            <param name="spriteBatch"></param>
            <param name="viewport"></param>
        </member>
        <member name="M:Engine.TileMap.CheckValidTileSet">
            <summary>
            checks to make sure that you have supplied enough tiles for the tilemap presented.
            An exception will be throw showing how many more tiles you need to define
            This should only be used for file based created tile maps
            </summary>
        </member>
        <member name="P:Engine.TileMap.TileRectangleSize">
            <summary>
            specifies the default rectangle size for tiles, to be used when defining color based temporary tiles
            </summary>
        </member>
        <member name="F:Engine.TileMap.OverlayShow">
            <summary>
            determines if tile information should be shown on top of tilemap.
            This is very expensive so only use for debugging
            </summary>
        </member>
        <member name="F:Engine.TileMap.OverlaySkip">
            <summary>
            how many columns,rows to skip display of, normally 1 which shows all.
            set to 2 to show every other row, column can be used with small tile tilemaps.
            Keep to factors of 2
            </summary>
        </member>
        <member name="F:Engine.TileMap.OverlayScale">
            <summary>
            determines render size for system font
            </summary>
        </member>
        <member name="F:Engine.TileMap.OverlayColor">
            <summary>
            specifies colour of the overlay text
            </summary>
        </member>
        <member name="F:Engine.TileMap.overlayAtt">
            <summary>
            holds text attribute for rendering ovelay
            </summary>
        </member>
        <member name="F:Engine.TileMap.OverlayOutput">
            <summary>
            specifies what information should be overlayed
            </summary>
        </member>
        <member name="M:Engine.TileMap.DrawOverlay(Engine.TextManager,Engine.FontSprite,Engine.EngineManager)">
            <summary>
            called by debug system of engine
            </summary>
            <param name="tm">text manager who is going to draw these items</param>
            <param name="f">font to use</param>
            <param name="em">ref to enginemanager</param>
        </member>
        <member name="F:Engine.TileMap.drawn">
            <summary>
            number of tiles drawn during last pass
            </summary>
        </member>
        <member name="F:Engine.TileMap.virtualView">
            <summary>
            specifies virtual width of viewport based on scale
            </summary>
        </member>
        <member name="M:Engine.TileMap.DrawNew(Microsoft.Xna.Framework.Graphics.SpriteBatch,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            new version of draw routine
            </summary>
            <param name="spriteBatch"></param>
            <param name="viewport"></param>
        </member>
        <member name="M:Engine.TileMap.MoveBy(System.Single@)">
            <summary>
            moves the tilemap over the specified period of time
            </summary>
            <param name="period">the fraction of a second we are dealing with for this update</param>
        </member>
        <member name="M:Engine.TileMap.AddTile(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            attempts to add an individual tile to the tile list for the tilemap
            if it already exist then this will be rejected and the index returned
            </summary>
            <param name="texture">texture of tile</param>
            <param name="rect">rectangluar portion of the texture for this tile</param>
            <returns>the index of the new tile or the existing index if this is a duplicate</returns>
        </member>
        <member name="M:Engine.TileMap.TileExists(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            attempt to locate a tile in the tilemaps list
            </summary>
            <param name="texture">texture to look for</param>
            <param name="rect">rectangle to see if exist</param>
            <returns>-1 if tile not found or tile index if already generated</returns>
        </member>
        <member name="M:Engine.TileMap.Location(Microsoft.Xna.Framework.Point,System.Int32,System.Int32)">
            <summary>
            gets the location of a tile from the given tile location and direction
            </summary>
            <param name="startingPoint">tile location to retrieve</param>
            <param name="direction">TileMap.Left, TileMap.Right, TileMap.Right, TileMap.Down</param>
            <param name="distance">tile offset</param>
            <returns>tile location or point with -1,-1 if no direction is picked</returns>
        </member>
        <member name="F:Engine.TileMap.MinorOrdinals">
            <summary>
            specifies if search and direction helpers should generate NE, NW, SE and SW directions
            </summary>
        </member>
        <member name="M:Engine.TileMap.ValidTile(Microsoft.Xna.Framework.Point)">
            <summary>
            returns true of a given tile location is actually within the tilemap
            </summary>
            <param name="tile">the tile to check</param>
            <returns>true if located in the map, false otherwise</returns>
        </member>
        <member name="M:Engine.TileMap.Location(Microsoft.Xna.Framework.Vector2,System.Collections.Generic.List{Microsoft.Xna.Framework.Vector2})">
            <summary>
            returns a list of tile locations for a given position and any number of offsets
            These can then be processed
            </summary>
            <param name="basePosition">A 2d position to add to each offset</param>
            <param name="offsets">a list of positions to combine with the basePosition to determine a tile location</param>
            <returns>A list of unique locations</returns>
        </member>
        <member name="M:Engine.TileMap.Location(System.Single,System.Single)">
            <summary>
            returns the tile that the given pixel location would occupy.
            If the position is out of bounds then a tile at the extremety will be returned
            This may change in a future version
            </summary>
            <param name="x">X position to use</param>
            <param name="y">Y position to use</param>
            <returns>A tile location</returns>
        </member>
        <member name="F:Engine.TileMap.ClampTileLocation">
            <summary>
            if true instructs the tile map to clamp any TileLocation checks. Default is true
            if set to false you will need to check to make sure tile locations are usable using ValidTile()
            (as they may be outside your valid tile locations)
            </summary>
        </member>
        <member name="M:Engine.TileMap.Location(Engine.Sprite)">
            <summary>
            returns location of the centre of an actor
            </summary>
            <param name="actor">the sprite to determine the tile location of its centre</param>
            <returns>A tile location</returns>
        </member>
        <member name="M:Engine.TileMap.PixelLocationCentre(Microsoft.Xna.Framework.Point)">
            <summary>
            gets the centre of a tile as a vector2
            </summary>
            <param name="location">the tile to investigate</param>
            <returns>the position of its centre</returns>
        </member>
        <member name="M:Engine.TileMap.PixelLocationCentreX(Microsoft.Xna.Framework.Point)">
            <summary>
            gets the x position of the centre of a tile
            </summary>
            <param name="location">the tile to investigate</param>
            <returns>the x position of the centre</returns>
        </member>
        <member name="M:Engine.TileMap.PixelLocationCentreY(Microsoft.Xna.Framework.Point)">
            <summary>
            gets the y position of the centre of a tile
            </summary>
            <param name="location">the tile to investigate</param>
            <returns>the y position of the centre</returns>
        </member>
        <member name="M:Engine.TileMap.PixelLocationTopLeft(Microsoft.Xna.Framework.Point)">
            <summary>
            Returns a pixel position based on a tile (upper left corner)
            </summary>
            <param name="location">The tile to get coords of</param>
            <returns>A zero z valued position of the tile</returns>
        </member>
        <member name="M:Engine.TileMap.PixelLocationLeft(Microsoft.Xna.Framework.Point)">
            <summary>
            gets the X position of a given tile (the left hand side)
            </summary>
            <param name="location">tile to examine</param>
            <returns>left hand side</returns>
        </member>
        <member name="M:Engine.TileMap.PixelLocationRight(Microsoft.Xna.Framework.Point)">
            <summary>
            gets the right hand position of a given tile
            </summary>
            <param name="location">tile to examine</param>
            <returns>right hand side</returns>
        </member>
        <member name="M:Engine.TileMap.PixelLocationBottom(Microsoft.Xna.Framework.Point)">
            <summary>
            gets the bottom position of a given tile
            </summary>
            <param name="location">tile to examine</param>
            <returns>bottom of the tile</returns>
        </member>
        <member name="M:Engine.TileMap.PixelLocationTop(Microsoft.Xna.Framework.Point)">
            <summary>
            gets the y position of a given tile (the top of the tile)
            </summary>
            <param name="location">tile to examine</param>
            <returns>top of the tile</returns>
        </member>
        <member name="M:Engine.TileMap.PixelLocationTop(Microsoft.Xna.Framework.Point,System.Single)">
            <summary>
            gets the y position of a given tile (the top of the tile)
            </summary>
            <param name="location">tile location to examine</param>
            <param name="horizontalOffset">horizontal position along the tile (for sloped tiles)</param>
            <returns>height at given offset for given tile location</returns>
        </member>
        <member name="M:Engine.TileMap.SetActorAt(Engine.Sprite,Microsoft.Xna.Framework.Point)">
            <summary>
            places a sprite at the specific tile location
            the alignment of the sprite needs to be taken into account
            </summary>
            <param name="s">the sprite to position</param>
            <param name="location">the tile to use for positioning</param>
        </member>
        <member name="M:Engine.TileMap.SetActorAtTop(Engine.Sprite,Microsoft.Xna.Framework.Point)">
            <summary>
            places the bottom centre of a sprite at the top of a specific tile location
            taking into account any slope information of the tile
            this does not affect the x position of the sprite
            </summary>
            <param name="s">the sprite to position</param>
            <param name="location">the tile to use for positioning</param>
        </member>
        <member name="M:Engine.TileMap.SetActorAtTop(Engine.Sprite,System.Single,Microsoft.Xna.Framework.Point)">
            <summary>
            places the bottom of a sprite at the top of a specific tile location
            taking into account any slope information of the tile
            this does not affect the x position of the sprite, but will use the horizontal position given 
            as a marker for penetration of the tile (for slope testing)
            </summary>
            <param name="s">the sprite to position</param>
            <param name="horizontalPosition">The position to test along the slope of the tile</param>
            <param name="tile">the tile to use for positioning</param>
        </member>
        <member name="M:Engine.TileMap.SetActorAtTop(Engine.Sprite,System.Single,Microsoft.Xna.Framework.Point,System.Single)">
            <summary>
            places the bottom of a sprite at the top of a specific tile location
            taking into account any slope information of the tile
            this does not affect the x position of the sprite, but will use the horizontal position given 
            as a marker for penetration of the tile (for slope testing)
            </summary>
            <param name="s">the sprite to position</param>
            <param name="horizontalPosition">The position to test along the slope of the tile</param>
            <param name="tile">the tile to use for positioning</param>
            <param name="verticalOffset">An offset value to either sink (+ve) or float -ve the sprite into tile top</param>
        </member>
        <member name="M:Engine.TileMap.SetActorOnGraphicTile(Engine.Sprite,Microsoft.Xna.Framework.Point,System.Single,System.Single,System.Single,System.Collections.Generic.List{System.Int32})">
            <summary>
            will attempt to sit an actor on top of graphic tile given. If this sprite is moving down and the tolerance with the top is ok
            then the sprites bottom will be placed on top of the tile. This will work with sloping tiles as well
            You must already have determined collision with a tile first before attempting to do this.
            </summary>
            <param name="s">The sprite to attempt to sit</param>
            <param name="mytile">The tile to potentially sit on</param>
            <param name="xCentre">the x position to use as the sprite centre (only useful for sloping tiles)</param>
            <param name="depthTolerance">The pixel distance from top of tile to assume on top</param>
            <param name="passableTiles">A list of tiles considered movable on, this should contain empty -1 at least</param>
            <param name="verticalOffset">An offset value from centre of sprite to act as the bottom, if this is smaller than half the height of the sprite it will sink into tile top</param>
            <returns>true if sprite was aligned to top of tile, false if it wasn't considered to be on top</returns>
        </member>
        <member name="M:Engine.TileMap.SetActorOnCollisionTile(Engine.Sprite,Microsoft.Xna.Framework.Point,System.Single,System.Single,System.Single,System.Collections.Generic.List{System.Int32})">
            <summary>
            will attempt to sit an actor on top of collision tile given. If this sprite is moving down and the tolerance with the top is ok
            then the sprites bottom will be placed on top of the tile. 
            You must already have determined collision with a tile first before attempting to do this.
            </summary>
            <param name="s">The sprite to attempt to sit</param>
            <param name="mytile">The tile to potentially sit on</param>
            <param name="xCentre">the x position to use as the sprite centre</param>
            <param name="verticalOffset">An offset value to either sink (+ve) or float -ve the sprite into tile top</param>
            <param name="depthTolerance">The pixel distance from top of tile to assume on top</param>
            <param name="passableTiles">A list of tiles considered movable on, this should contain empty 0 at least</param>
            <returns>true if sprite was aligned to top of tile, false if it wasn't considered to be on top</returns>
        </member>
        <member name="M:Engine.TileMap.SetActorAtCentreY(Engine.Sprite,Microsoft.Xna.Framework.Point)">
            <summary>
            places a sprites y position at the specific tile centre location
            the alignment of the sprite needs to be taken into account
            </summary>
            <param name="s">the sprite to position</param>
            <param name="tile">the tile to use for positioning</param>
        </member>
        <member name="M:Engine.TileMap.SetActorAtCentreX(Engine.Sprite,Microsoft.Xna.Framework.Point)">
            <summary>
            places a sprites x position at the specific tile centre location
            the alignment of the sprite needs to be taken into account
            </summary>
            <param name="s">the sprite to position</param>
            <param name="tile">the tile to use for positioning</param>
        </member>
        <member name="M:Engine.TileMap.SetActorAtCentre(Engine.Sprite,Microsoft.Xna.Framework.Point)">
            <summary>
            places a sprite at the specific tile centre location
            the alignment of the sprite needs to be taken into account
            </summary>
            <param name="s">the sprite to position</param>
            <param name="tile">the tile to use for positioning</param>
        </member>
        <member name="M:Engine.TileMap.SetActorAtCentre(Engine.Sprite)">
            <summary>
            sets an actor at the centre of its current tile. Useful for quick alignment
            </summary>
            <param name="s">the sprite to centre</param>
        </member>
        <member name="M:Engine.TileMap.ActorAtCentre(Engine.Sprite,System.Single)">
            <summary>
            Determines if an actor is near the centre of a tile
            </summary>
            <param name="s">The sprite to check</param>
            <param name="tolerance">tolerance to apply</param>
            <returns>returns true if sprite is in centre of a tile and false if not</returns>
        </member>
        <member name="M:Engine.TileMap.ItemHereGraphic(Microsoft.Xna.Framework.Point,System.Int32)">
            <summary>
            Determines if an item actually exists in the tile map
            at the tile position given
            </summary>
            <param name="pos">The tile position to examine</param>
            <param name="item">an integer describing the tile type to search for</param>
            <returns>True if item exists, or false if doesn't exist or illegal tile position</returns>
        </member>
        <member name="M:Engine.TileMap.ItemHereGraphic(Microsoft.Xna.Framework.Point,System.Int32[])">
            <summary>
            Determines if an item within the specified list actually exists
            in the tilemap at the tile position given
            </summary>
            <param name="pos">The tile position to examine</param>
            <param name="items">a list of integers describing the tile types to search for</param>
            <returns>True if one exist or false if not</returns>
        </member>
        <member name="F:Engine.TileMap.WrapTileInterrogation">
            <summary>
            determines if tile locations outside of manual tilemaps are wrapped (default is False)
            if true then tunnels can be implemented as locations past left will be wrapped to right of tilemap
            and the same for top and bottom
            </summary>
        </member>
        <member name="F:Engine.TileMap.engineManager">
            <summary>
            holds an internal reference to the engine manager so we can acccess the engine directly for special tasks
            </summary>
        </member>
        <member name="F:Engine.TileMap.autotile">
            <summary>
            if true then when tilemap is added to the tilemap manager the
            autotileTexture will be tiled at 0,0
            </summary>
        </member>
        <member name="F:Engine.TileMap.autotileTexture">
            <summary>
            texture for the tilemap manager to auto tile
            </summary>
        </member>
        <member name="M:Engine.TileMap.ItemHereCollision(Microsoft.Xna.Framework.Point,System.Int32[])">
            <summary>
            Determines if an item within the specified list actually exists
            in the collision map at the tile position given
            </summary>
            <param name="pos">The tile position to examine</param>
            <param name="items">a list of integers describing the tile types to search for</param>
            <returns>True if one exist or false if not</returns>
        </member>
        <member name="M:Engine.TileMap.ItemHereCollision(Microsoft.Xna.Framework.Point,System.Int32)">
            <summary>
            Determines if an item actually exists in the collision map
            at the tile position given
            </summary>
            <param name="pos">The tile position to examine</param>
            <param name="item">an integer describing the tile types to search for</param>
            <returns>True if one exist or false if not</returns>
        </member>
        <member name="M:Engine.TileMap.CentreTileMap(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Centres map inside given area
            </summary>
            <param name="left">the left hand side of the area</param>
            <param name="top">The top of the area</param>
            <param name="width">the width of the area to centre within</param>
            <param name="height">The height of the area to centre within</param>
        </member>
        <member name="M:Engine.TileMap.CentreTileMap(Microsoft.Xna.Framework.Rectangle)">
            <summary>
            Centres map inside given rectangle area
            </summary>
            <param name="area">The rectangle that we want to centre inside of</param>
        </member>
        <member name="M:Engine.TileMap.CentreTileMapY(System.Single,System.Single)">
            <summary>
            Centres the tilemap vertically
            </summary>
            <param name="top">The top of the area</param>
            <param name="height">The height of the area to centre within</param>
        </member>
        <member name="M:Engine.TileMap.CentreTileMapY(Microsoft.Xna.Framework.Rectangle)">
            <summary>
            Centres map horizontally inside given area
            </summary>
            <param name="area">Rectangluar area to centre within</param>
        </member>
        <member name="M:Engine.TileMap.CentreTileMapX(System.Single,System.Single)">
            <summary>
            Centres map horizontally inside given area
            </summary>
            <param name="left">the left hand side of the area</param>
            <param name="width">the width of the area to centre within</param>
        </member>
        <member name="M:Engine.TileMap.CentreTileMapX(Microsoft.Xna.Framework.Rectangle)">
            <summary>
            Horizontally centres the tilemap
            </summary>
            <param name="area">Rectangluar area to centre within</param>
        </member>
        <member name="M:Engine.TileMap.CreateCollisionMap(System.Int32[])">
            <summary>
            Converts existing tileMap into a collision map
            You can use CollisionMap to set directly your own map but this must be the same size 
            as your tilemap
            </summary>
            <param name="collisionBlocks">A list of collision tiles which map the display tiles to specific collision ones, 
            make sure this has enough entries to cover all the display tiles</param>
        </member>
        <member name="M:Engine.TileMap.LegalMoveGraphic(Microsoft.Xna.Framework.Point,System.Int32,System.Int32[])">
            <summary>
            Checks to see if a proposed move is legal from current tile in direction propsed
            checks against tile map
            </summary>
            <param name="currentTile">tile location</param>
            <param name="direction">direction to check 0 - left, 1, right, 2 up 3 down</param>
            <param name="illegal">array of illegal tiles</param>
            <returns>true if propsed move is legal</returns>
        </member>
        <member name="M:Engine.TileMap.LegalMoveCollision(Microsoft.Xna.Framework.Point,System.Int32,System.Int32[])">
            <summary>
            Checks to see if a proposed move is legal from current tile in direction propsed
            checks against collision map
            </summary>
            <param name="currentTile">tile location</param>
            <param name="direction">direction to check 0 - left, 1, right, 2 up 3 down</param>
            <param name="illegal">array of illegal tiles</param>
            <returns>true if propsed move is legal</returns>
        </member>
        <member name="M:Engine.TileMap.DirectionsCollision(Microsoft.Xna.Framework.Point,System.Int32[])">
            <summary>
            Indentifies the immediate directions a particular set of tiles are available from the collision map
            </summary>
            <param name="pos">The starting tile</param>
            <param name="search">Item array to look for</param>
            <returns>list of ordinals to target</returns>
        </member>
        <member name="M:Engine.TileMap.ValidDirectionsCollision(Microsoft.Xna.Framework.Point,System.Int32[])">
            <summary>
            Checks the collision map for available positions from given tile
            </summary>
            <param name="pos">The position to look for valid directions from</param>
            <param name="illegal">A list of the tiles that cannot be moved onto</param>
            <returns>a list of valid directions</returns>
        </member>
        <member name="M:Engine.TileMap.ValidDirectionsLegalListCollision(Microsoft.Xna.Framework.Point,System.Int32[])">
            <summary>
            Checks the collision map for available positions from given tile, given a legal list of tiles to occupy
            </summary>
            <param name="pos">The position to look for valid directions from</param>
            <param name="legal">A list of the tiles that can be moved onto</param>
            <returns>a list of valid directions</returns>
        </member>
        <member name="M:Engine.TileMap.RemoveDirectionsOutOfBounds(Microsoft.Xna.Framework.Point,System.Collections.Generic.List{System.Int32}@,System.Int32)">
            <summary>
            removes any directions that move outside of tile space
            </summary>
            <param name="currentPosition">current tile location</param>
            <param name="possibleDirections">directions to test</param>
            <param name="distance">number of tiles to move</param>
        </member>
        <member name="M:Engine.TileMap.RemoveDirectionsOutOfBounds(Microsoft.Xna.Framework.Point,System.Collections.Generic.List{System.Int32}@)">
            <summary>
            removes any directions that move outside of tile space in one direction
            </summary>
            <param name="currentPosition">current tile location</param>
            <param name="possibleDirections">directions to test</param>
        </member>
        <member name="M:Engine.TileMap.ValidDirectionsGraphic(Microsoft.Xna.Framework.Point,System.Int32[])">
            <summary>
            Checks the tile map for availble positions from given tile, given a set of illegal tiles
            </summary>
            <param name="pos">The position to look for valid directions from</param>
            <param name="illegal">A list of the tiles that cannot be moved onto</param>
            <returns>a list of valid directions</returns>
        </member>
        <member name="M:Engine.TileMap.ValidDirectionsLegalListGraphic(Microsoft.Xna.Framework.Point,System.Int32[])">
            <summary>
            Checks the tile map for availble positions from given tile, given a set of legal tiles
            </summary>
            <param name="pos">The position to look for valid directions from</param>
            <param name="legal">A list of the tiles that can be moved onto</param>
            <returns>a list of valid directions</returns>
        </member>
        <member name="M:Engine.TileMap.OppositeOrdinalDirection(Engine.Sprite)">
            <summary>
            Gets the opposite direction a sprite is moving int terms of TileMap ordinal directions
            only to be used for sprites moving in ordinal tile maps
            </summary>
            <param name="me">The sprite to observe</param>
            <returns>TileMap.Left or TileMap.Right or TileMap.Down or TileMap.UP or TileMap.NONE if not moving</returns>
        </member>
        <member name="M:Engine.TileMap.OppositeOrdinalDirection(Microsoft.Xna.Framework.Vector3)">
            <summary>
            Gets the opposite direction a velocity is moving int terms of TileMap ordinal directions
            only to be used for velocities  in ordinal tile maps
            </summary>
            <param name="velocity">The velocity to examine</param>
            <returns>TileMap.Left or TileMap.Right or TileMap.Down or TileMap.UP or TileMap.NONE if not moving</returns>
        </member>
        <member name="M:Engine.TileMap.OppositeOrdinalDirection(System.Int32)">
            <summary>
            returns the opposite ordinal direction of the given direction (TILEMAP.LEFT, ..RIGHT, ..UP, ..DOWN)
            </summary>
            <param name="direction">Direction to determine opposite of</param>
            <returns>Opposite of given direction</returns>
        </member>
        <member name="M:Engine.TileMap.CollisionGraphic(Engine.Sprite,System.Int32[])">
            <summary>
            determines if the sprite is in collision with a tile, does not check centre of sprite 
            </summary>
            <param name="me">sprite to check for collision with</param>
            <param name="tileList">List of tile indexes to check against</param>
            <returns>A list of points or an empty list if no collisions</returns>
        </member>
        <member name="M:Engine.TileMap.CollisionAlignGraphic(Engine.Sprite,System.Int32[],System.Single)">
            <summary>
            determines if the sprite is in collision with a tile, does not check centre of sprite 
            will align sprite so it is touching the edge of the tile + an offset
            </summary>
            <param name="me">sprite to check for collision with</param>
            <param name="tileList">List of tile indexes to check against</param>
            <param name="offset">A pixel amount to apply to the adjusted sprite position</param>
            <returns>A list of points or an empty list if no collisions</returns>
        </member>
        <member name="M:Engine.TileMap.LineOfSiteCollision(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single,System.Int32[])">
            <summary>
            determines if there is a clear path between the position A to position B without encountering any specific collision tiles
            only the tiles specified in the tilelist are including in the line of sight test.
            if a tile blocks the sight then its position is returned
            </summary>
            <param name="A">the first tile location</param>
            <param name="B">the second location to cast a ray to</param>
            <param name="stepratio">0.2f is a good starter value here, percentage of tile width to move along ray to determine collision with tile 1, will step the width and height of a tile 0.5f will step half the width, the smaller the number the more accurate but slower collision checks will be </param>
            <param name="tileList">List of tile indexes to check against</param>
            <returns>a the index</returns>
        </member>
        <member name="M:Engine.TileMap.InListCollision(System.Collections.Generic.List{Microsoft.Xna.Framework.Point},System.Int32[])">
            <summary>
            Checks a list of tile locations to see of a given collision tile exists, returning the first occurance 
            </summary>
            <param name="tileLocations">a list of tile locations to check</param>
            <param name="tileList">collision tiles to check existence of</param>
            <returns>the tile location of the first wanted collision tile, or -1,-1 if non exist</returns>
        </member>
        <member name="M:Engine.TileMap.LocationsBetween(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            Generates a list of tiles between two points given a ratio of accuracy
            </summary>
            <param name="A">start point</param>
            <param name="B">end point</param>
            <param name="stepratio">0.2f is a good starter value here, percentage of tile width to move along ray to determine collision with tile 1, will step the width and height of a tile 0.5f will step half the width, the smaller the number the more accurate but slower collision checks will be </param>
            <returns>the list of tile locations between the 2 points</returns>
        </member>
        <member name="M:Engine.TileMap.LineOfSiteGraphic(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single,System.Int32[])">
            <summary>
            determines if there is a clear path between the position A to position B without encountering any specific graphic tiles
            only the tiles specified in the tilelist are including in the line of sight test.
            if a tile blocks the sight then its position is returned
            </summary>
            <param name="A">the first tile location</param>
            <param name="B">the second location to cast a ray to</param>
            <param name="stepratio">0.2f is a good starter value here, percentage of tile width to move along ray to determine collision with tile 1, will step the width and height of a tile 0.5f will step half the width, the smaller the number the more accurate but slower collision checks will be </param>
            <param name="tileList">List of tile indexes to check against</param>
            <returns>a point with negative values if no tile is blocking, otherwise the tile location where collision did occur</returns>
        </member>
        <member name="M:Engine.TileMap.InListGraphic(System.Collections.Generic.List{Microsoft.Xna.Framework.Point},System.Int32[])">
            <summary>
            Checks a list of tile locations to see of a given tile exists. 
            </summary>
            <param name="tileLocations">a list of tile locations to check</param>
            <param name="tileList">tiles to check existence of</param>
            <returns>the tile location of the first wanted tile, or -1,-1 if non exist</returns>
        </member>
        <member name="M:Engine.TileMap.CollisionCollision(Engine.Sprite,System.Int32[])">
            <summary>
            determines if the sprite is in collision with a collision tile, does not check centre of sprite 
            </summary>
            <param name="me">sprite to check for collision with</param>
            <param name="tileList">List of tile indexes to check against</param>
            <returns>A list of points or an empty list if no collisions</returns>
        </member>
        <member name="M:Engine.TileMap.CollisionCollision(Engine.Sprite,System.Int32[],System.Single)">
            <summary>
            determines if the sprite is in collision with a collision tile, does not check centre of sprite 
            </summary>
            <param name="me">sprite to check for collision with</param>
            <param name="tileList">List of tile indexes to check against</param>
            <param name="pad">An amount ot add to sprites boundaries before checking for collision</param>
            <returns>A list of points or an empty list if no collisions</returns>
        </member>
        <member name="M:Engine.TileMap.CollisionAlignCollision(Engine.Sprite,System.Int32[],System.Single)">
            <summary>
            determines if the sprite is in collision with a collision tile, does not check centre of sprite 
            will align sprite so it is touching the edge of the tile + an offset
            </summary>
            <param name="me">sprite to check for collision with</param>
            <param name="tileList">List of tile indexes to check against</param>
            <param name="offset">A pixel amount to apply to the adjusted sprite position</param>
            <returns>A list of points or an empty list if no collisions</returns>
        </member>
        <member name="M:Engine.TileMap.CollisionAlignCollision(Engine.Sprite,System.Int32[],System.Single,System.Single)">
            <summary>
            determines if the sprite is in collision with a collision tile, does not check centre of sprite 
            will align sprite so it is touching the edge of the tile + an offset
            </summary>
            <param name="me">sprite to check for collision with</param>
            <param name="tileList">List of tile indexes to check against</param>
            <param name="offset">A pixel amount to apply to the adjusted sprite position</param>
            <param name="pad">An overlap to apply to sprite position before testing</param>
            <returns>A list of points or an empty list if no collisions</returns>
        </member>
        <member name="M:Engine.TileMap.GetOrdinalDirectionTo(Engine.Sprite,Microsoft.Xna.Framework.Point)">
            <summary>
            Determines the general direction of the centre of a sprite to the tile given
            used for collision work (reflection)
            </summary>
            <param name="me">Sprite to compare with tile</param>
            <param name="to">tile to look towards</param>
            <returns>TileMap.Left or TileMap.Right or TileMap.Down or TileMap.UP or TileMap.NONE if not moving</returns>
        </member>
        <member name="M:Engine.TileMap.GetOrdinalDirectionTo(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>
            Determines the general direction of one tile to the tile given
            </summary>
            <param name="from">tile to look from</param>
            <param name="to">tile to look towards</param>
            <returns>TileMap.Left or TileMap.Right or TileMap.Down or TileMap.UP or TileMap.NONE if not moving</returns>
        </member>
        <member name="M:Engine.TileMap.GetOrdinalDirection(Engine.Sprite)">
            <summary>
            Gets the direction a sprite is moving int terms of TileMap ordinal directions
            only to be used for sprites moving in ordinal tile maps e.g only one direction no diagonals
            </summary>
            <param name="me">The sprite to observe</param>
            <returns>TileMap.Left or TileMap.Right or TileMap.Down or TileMap.UP or TileMap.NONE if not moving</returns>
        </member>
        <member name="M:Engine.TileMap.GetOrdinalDirection(Microsoft.Xna.Framework.Vector3)">
            <summary>
            Gets the direction a velocity or direction vector and ordinalises it (determines which north, south, east or west is most similar)
            returning direction in terms of TileMap ordinal directions
            only to be used for velocities  in ordinal tile maps
            </summary>
            <param name="velocity">The velocity to examine</param>
            <returns>TileMap.Left or TileMap.Right or TileMap.Down or TileMap.UP or TileMap.NONE if not moving</returns>
        </member>
        <member name="M:Engine.TileMap.GetOrdinalDirection(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Gets the direction vector and ordinalises it (determines which north, south, east or west is most similar)
            returning direction in terms of TileMap ordinal directions
            only to be used for velocities  in ordinal tile maps
            </summary>
            <param name="direction">The 2d direction vector to examine</param>
            <returns>TileMap.Left or TileMap.Right or TileMap.Down or TileMap.UP or TileMap.NONE if not moving</returns>
        </member>
        <member name="M:Engine.TileMap.RemoveOppositeDirection(System.Collections.Generic.List{System.Int32}@,Engine.Sprite)">
            <summary>
            Attempts to remove the opposite direction that a sprite is moving in a list
            of possible directions. This stops actors from going back on themselves when
            making decisions at junctions (not a very desirable trait)
            </summary>
            <param name="possibleDirections">List of directions create with TileValidDirections (possibly)</param>
            <param name="me">The sprite that is moving and going to make a decision</param>
        </member>
        <member name="M:Engine.TileMap.RemoveOppositeDirection(System.Collections.Generic.List{System.Int32}@,System.Int32)">
            <summary>
            removes if possible the opposite direction to the one given from the list
            </summary>
            <param name="possibleDirections">a list of directions</param>
            <param name="direction">the direction which we want the opposite direction</param>
        </member>
        <member name="M:Engine.TileMap.RemoveDirection(System.Collections.Generic.List{System.Int32}@,System.Int32)">
            <summary>
            Attempts to remove a given direction if it is in the given list
            of possible directions. This stops actors from taking certain routes from specific tiles
            in maps. if one direction only available then it will not be removed
            </summary>
            <param name="possibleDirections">List of directions create with TileValidDirections (possibly)</param>
            <param name="ordinalDirection">direction to attempt to remove</param>
        </member>
        <member name="M:Engine.TileMap.LocationForward(Engine.Sprite,System.Int32)">
            <summary>
            works out a displacement from a sprites centre tile in the direction it is moving
            </summary>
            <param name="displacement">number of tiles to look, uses negative numbers for behind</param>
            <param name="actor">The sprite to find the tile in front of</param>
            <returns>a tile displacement positions in front of the actor</returns>
        </member>
        <member name="M:Engine.TileMap.LocationForward(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Vector3,System.Int32)">
            <summary>
            works out the displacement from a tile in the direction given
            </summary>
            <param name="displacement">number of tiles to look, use negative numbers for behind</param>
            <param name="location">Tile to displace from</param>
            <param name="direction">direction to look</param>
            <returns>a tile location which is displaced as requested</returns>
        </member>
        <member name="M:Engine.TileMap.ShortestDistanceCrow(System.Collections.Generic.List{System.Int32},Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>
            Attempts to determine which of a list of directions would give the shortest distance as the crow
            would fly (direct distance), returning the ordinal direction (TileMap.Left, TileMap.Right etc...)
            </summary>
            <param name="directions">a list of available directions to try</param>
            <param name="currentTile">The current tile to check distance from</param>
            <param name="targetTile">Tile checking distance to</param>
            <returns>ordinal number of direction with shortest distance (TileMap.Left, TileMap.Right etc...)</returns>
        </member>
        <member name="M:Engine.TileMap.SurroundingGraphic(Microsoft.Xna.Framework.Point)">
            <summary>
            returns a list of tiles that surround this tile
            why??? needed
            </summary>
            <param name="pos"></param>
            <returns>an array of tile positions</returns>
        </member>
        <member name="M:Engine.TileMap.CheckDirty">
            <summary>
            checks to see if renderproperties are dirty and updates any values necessary
            </summary>
        </member>
        <member name="M:Engine.TileMap.Highlight(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Color,System.Single,System.Single)">
            <summary>
            generates a temporary tile sized sprite for testing and special effects,
            using a standard plain tile
            </summary>
            <param name="location">the tile location to render at</param>
            <param name="colour">colour wash to apply</param>
            <param name="duration">time before the highlight should be remove</param>
            <param name="alpha">Transparency to apply</param>
            <returns>The highlight sprite create in case you want mess about with it</returns>
        </member>
        <member name="M:Engine.TileMap.Highlight(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Color,System.Single,System.Int32,System.Single,Microsoft.Xna.Framework.Graphics.Texture2D,System.Single)">
            <summary>
            generates a temporary tile sized sprite for testing and special effects
            </summary>
            <param name="location">the tile location to render at</param>
            <param name="colour">colour wash to apply</param>
            <param name="duration">time before the highlight should be remove</param>
            <param name="layer">The sprite layer to drop this on</param>
            <param name="alpha">Transparency to apply</param>
            <param name="tex">texture to use</param>
            <param name="depth">Z position of sprite within it's layer</param>
            <returns>The highlight sprite create in case you want mess about with it</returns>
        </member>
        <member name="M:Engine.TileMap.Highlight(Microsoft.Xna.Framework.Point,Engine.Sprite,System.Boolean,System.Boolean)">
            <summary>
            Highlights a particular tilemap location
            </summary>
            <param name="location">the tile location to render at</param>
            <param name="cloneFrom">A set of Sprite data to take settings, see Sprite.GetClone() for a list of all attributes cloned:</param>
            <param name="scale">if true the sprite will be scaled to same dimension as tile</param>
            <param name="useFrames">If true the frame data will be cloned from the cloneFrom sprite</param>
            <returns></returns>
        </member>
        <member name="M:Engine.TileMap.HighlightDirections(Microsoft.Xna.Framework.Point,System.Collections.Generic.List{System.Int32},Microsoft.Xna.Framework.Color[],System.Single,System.Single,System.Int32,System.Single)">
            <summary>
            Highlights automatically tiles in the directions given from the current tile location
            </summary>
            <param name="location">central location</param>
            <param name="directions">list of tile directions</param>
            <param name="colour">colour array to draw directions, which must contain 4 colours, 1 for each direction</param>
            <param name="duration">how long for the directions to appear</param>
            <param name="alpha">transparency of highlight</param>
            <param name="layer">The sprite layer to show the higlighting</param>
            <param name="depth">the Z value to assign the highlight</param>
        </member>
        <member name="M:Engine.TileMap.HighlightDirections(Microsoft.Xna.Framework.Point,System.Collections.Generic.List{System.Int32},Microsoft.Xna.Framework.Color,System.Single,System.Single)">
            <summary>
            Highlights automatically tiles in the directions given from the current tile location
            </summary>
            <param name="location">central location</param>
            <param name="directions">list of tile directions</param>
            <param name="colour">colour to draw each highlight</param>
            <param name="duration">how long for the directions to appear</param>
            <param name="alpha">transparency of highlight</param>
        </member>
        <member name="T:Engine.TileMapManager">
            <summary>
            Overseas the updating, adding and removal of layers
            and tiling of layers using static methods
            </summary>
        </member>
        <member name="F:Engine.TileMapManager.MaximumTileMaps">
            <summary>
            cap for tilemaps for batching purposes may re-write that part
            </summary>
        </member>
        <member name="F:Engine.TileMapManager.sheet">
            <summary>
            used for interating during update
            </summary>
        </member>
        <member name="F:Engine.TileMapManager.period">
            <summary>
            holds update period
            </summary>
        </member>
        <member name="M:Engine.TileMapManager.#ctor(Microsoft.Xna.Framework.Game)">
            <summary>
            constructs the tilemap manager
            </summary>
            <param name="game"></param>
        </member>
        <member name="M:Engine.TileMapManager.Initialize">
            <summary>
            initialises the tilemap manager
            </summary>
        </member>
        <member name="M:Engine.TileMapManager.Update(Microsoft.Xna.Framework.GameTime)">
            <summary>
            updates all the tilemaps if the system is not paused
            </summary>
            <param name="gameTime"></param>
        </member>
        <member name="M:Engine.TileMapManager.Add(Engine.TileMap)">
            <summary>
            adds a tilemap to the active list
            </summary>
            <param name="tilemap">The tilemap to draw</param>
        </member>
        <member name="M:Engine.TileMapManager.Clear">
            <summary>
            removes all active tilemaps
            </summary>
        </member>
        <member name="M:Engine.TileMapManager.Remove(Engine.TileMap)">
            <summary>
            removes the specified tilemap
            </summary>
            <param name="tilemap">The tilemap</param>
        </member>
        <member name="M:Engine.TileMapManager.CreateCollisionMap(Engine.TileMap,System.Int32[])">
            <summary>
            Builds a collision map from the tilemap and a list of mappings to convert normal tiles into collidable types
            You must have already provided the 
            </summary>
            <param name="collisionMappings">the list of collision tiles</param>
            <param name="tileMap">The tile map to create collision map for</param>
        </member>
        <member name="M:Engine.TileMapManager.Tile(Engine.TileMap,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            NOT IMPLEMENTED YET
            tiles a portion of a texture to a tilemap, use this if you have a background graphic that is on a spritesheet
            </summary>
            <param name="tileMap">The tilemap to tile the texture to</param>
            <param name="position">The start position for this tile, this must start on a tile boundary.
            If your tilewidth is 50, your x position must be a factor of 50 and similar for the y value</param>
            <param name="texture">The texture to tile</param>
            <param name="portion"></param>
        </member>
        <member name="M:Engine.TileMapManager.FillMapFromAlphaChannel(Engine.TileMap,Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            Fills a tilemap where each tile is at least 1 by 1 pixel. The data for this comes from a texture using it's alpha channel.
            Transparent areas generate a tile number of 0 and non transparent areas generate a tile number of 1
            These are not intended to be drawn (and do not need adding to the tilemap manager), but rather used for pixel level collision detection. As Such the tilemap will be disabled.
            You need to make sure you have set the size of tilemap using SetSamplingMap() first.
            </summary>
            <param name="tileMap">The tilemap to fill the map in for</param>
            <param name="texture">The texture whose alpha channel will be used</param>
        </member>
        <member name="M:Engine.TileMapManager.FillMapFromAlphaChannel(Engine.TileMap,Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            Fills a portion of a tilemap where each tile is at least 1 by 1 pixel. The data for this comes from a texture using it's alpha channel.
            Transparent areas generate a tile number of 0 and non transparent areas generate a tile number of 1
            These are not intended to be drawn (and do not need adding to the tilemap manager), but rather used for pixel level collision detection. As Such the tilemap will be disabled.
            You need to make sure you have set the size of tilemap using SetSamplingMap() first.
            </summary>
            <param name="tileMap">The tilemap to fill the map in for</param>
            <param name="cornerOffset">The start (pixel position) co-ordinates of the tilemap where this alpha data should be placed</param>
            <param name="texture">The texture whose alpha channel will be used</param>
            <param name="portion">The area of the texture to place in the tilemap</param>
        </member>
        <member name="M:Engine.TileMapManager.FillMapFromPixelData(Engine.TileMap,Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            Fills a portion of a tilemap where each tile is at least 1 by 1 pixel. The data for this comes from a texture using each pixels colour.
            For larger tile sizes (2x2) and (4x4) the sampling resolution is changed which gives 
            Each pixels colour is converted into a packed value (unsigned integer) which is then converted into a signed int to be stored in the tilemap
            These are not intended to be drawn (and do not need adding to the tilemap manager), but rather used for pixel level collision detection. As Such the tilemap will be disabled.
            You need to make sure you have set the size of tilemap using SetSamplingMap() first.
            You should use this with special graphic maps using colour regions for different collision purposes.
            </summary>
            <param name="tileMap">The tilemap to fill the map in for</param>
            <param name="texture">The texture whose pixels will be used</param>
        </member>
        <member name="M:Engine.TileMapManager.FillMapFromPixelData(Engine.TileMap,Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            Fills a portion of a tilemap where each tile is at least 1 by 1 pixel. The data for this comes from a texture using each pixels colour.
            For larger tile sizes (2x2) and (4x4) the sampling resolution is changed which gives 
            Each pixels colour is converted into a packed value (unsigned integer) which is then converted into a signed int to be stored in the tilemap
            These are not intended to be drawn (and do not need adding to the tilemap manager), but rather used for pixel level collision detection. As Such the tilemap will be disabled.
            You need to make sure you have set the size of tilemap using SetSamplingMap() first.
            You should use this with special graphic maps using colour regions for different collision purposes.
            
            These colour maps can be used for a large variety of tasks, collision detection, height maps for scaling etc...
            </summary>
            <param name="tileMap">The tilemap to fill the map in for</param>
            <param name="cornerOffset">The start (pixel position) co-ordinates of the tilemap where this alpha data should be placed</param>
            <param name="texture">The texture whose pixels will be used</param>
            <param name="portion">The area of the texture to place in the tilemap</param>
        </member>
        <member name="M:Engine.TileMapManager.Tile(Engine.TileMap,Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            tiles an entire texture to a tilemap setting it to the top left corner
            </summary>
            <param name="tileMap">The tilemap to tile the texture to</param>
            <param name="texture">The texture to tile</param>
        </member>
        <member name="M:Engine.TileMapManager.Tile(Engine.TileMap,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            tiles an entire texture to a tilemap
            </summary>
            <param name="tileMap">The tilemap to tile the texture to</param>
            <param name="position">The start position for this tile, this must start on a tile boundary.
            If your tilewidth is 50, your x position must be a factor of 50 and similar for the y value</param>
            <param name="texture">The texture to tile</param>
        </member>
        <member name="M:Engine.TileMapManager.TilePortion(Engine.TileMap,Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            tiles part of a texture to a tilemap.
            You must ensure that the size of your tilemap has been defined properly to accomodate your portion
            </summary>
            <param name="tileMap">The tilemap to tile the texture to</param>
            <param name="portion">the rectangular area of the texture to tile</param>
            <param name="position">The start position for this tile, this must start on a tile boundary.
            If your tilewidth is 50, your x position must be a factor of 50 and similar for the y value</param>
            <param name="texture">The texture to tile</param>
        </member>
        <member name="M:Engine.TileMapManager.TileToExtents(Engine.TileMap,Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            Attempts to fill the extents of the tilemap with the given texture
            repeating it as many times as necessary, better to create a smaller tilemap
            the same size as your texture and set it to repeat the drawing to fill viewport
            </summary>
            <param name="tileMap">The tilemap to tile the texture to</param>
            <param name="texture">The texture to tile</param>
            <remarks>This will work best if your texture divides exactly into the size of your tilemap. tilemap 800 by 600
            with a texture 200,200 this would be tiled 8 times across the tilemap (4 across 2 down)</remarks>
        </member>
        <member name="P:Engine.TileMapManager.BackTileMaps">
            <summary>
            
            </summary>
        </member>
        <member name="T:Engine.Timing">
            <summary>
            provides sprite specific timing functions, for flashing and killing
            </summary>
        </member>
        <member name="T:Engine.Timing.Phase">
            <summary>
            specifies phases of flashing, these are private
            </summary>
        </member>
        <member name="F:Engine.Timing.Phase.startAfter">
            <summary>
            waiting for flashing to start
            </summary>
        </member>
        <member name="F:Engine.Timing.Phase.stopAfter">
            <summary>
            waiting for flashing to stop
            </summary>
        </member>
        <member name="F:Engine.Timing.Phase.killAfter">
            <summary>
            waiting to kill sprite
            </summary>
        </member>
        <member name="T:Engine.Timing.Action">
            <summary>
            What the timing operates, these are private
            </summary>
        </member>
        <member name="F:Engine.Timing.Action.none">
            <summary>
            do nothing with the sprite
            </summary>
        </member>
        <member name="F:Engine.Timing.Action.killAfterTime">
            <summary>
            kills the sprite after time elapsed
            </summary>
        </member>
        <member name="F:Engine.Timing.Action.FlashStopAfterTime">
            <summary>
            flashes until the stopAfter period has elapsed then stays on screen
            </summary>
        </member>
        <member name="F:Engine.Timing.Action.FlashStartAfterTime">
            <summary>
            starts flashing once the startAfter period has elapsed and continues to flash
            </summary>
        </member>
        <member name="F:Engine.Timing.Action.FlashContinuous">
            <summary>
            flashes continuously
            </summary>
        </member>
        <member name="F:Engine.Timing.Action.FlashStopAfterTimeKill">
            <summary>
            flashes until the stopAfter period has elapsed then kills the sprite
            </summary>
        </member>
        <member name="F:Engine.Timing.Action.FlashStartAfterTimeStopAfterTime">
            <summary>
            starts flashing once the AfterTime has elapsed and then flashes until the TillTime elapses then stays on screen
            </summary>
        </member>
        <member name="F:Engine.Timing.Action.FlashStartAfterTimeKillAfterTime">
            <summary>
            starts flashing once the AfterTime has elapsed and then flashes until the TillTime elapses then is killed
            </summary>
        </member>
        <member name="F:Engine.Timing.Action.ShowAfterTime">
            <summary>
            makes a sprite invisible and then shows it after the time period elapses
            </summary>
        </member>
        <member name="F:Engine.Timing.Action.ShowAfterTimeFlash">
            <summary>
            makes a sprite invisible then shows it with a flash rate
            </summary>
        </member>
        <member name="F:Engine.Timing.Action.ShowAfterTimerKillAfterTime">
            <summary>
            makes a sprite invisible then shows it then kills it
            </summary>
        </member>
        <member name="F:Engine.Timing.Action.ImpulseStopAfterTime">
            <summary>
            applys a force for a period of time
            </summary>
        </member>
        <member name="F:Engine.Timing.Action.ImpulseOnce">
            <summary>
            applys a force for one game cycle
            </summary>
        </member>
        <member name="F:Engine.Timing.Action.TimerFireEvent">
            <summary>
            Triggers an event handler (the OnTimingDone event) when timer elapses
            </summary>
        </member>
        <member name="F:Engine.Timing.Action.TimerFireEventOnce">
            <summary>
            Triggers an event handler once (the OnTimingDone event) when timer elapses
            </summary>
        </member>
        <member name="P:Engine.Timing.TimingDoneCallBack">
            <summary>
            holds a reference to method called when timing action ends under circumstances
            will be called under the following circumstances
            <para>will be called at the end of EventOnce(),</para>
            <para>will be called each time EventContinuous() triggers,</para>
            <para>will be called at the end of ShowAfter() before sprite is shown,</para>
            <para>will be called when sprite appears during ShowAfterFlashContinuous(),</para>
            <para>will be called when sprite appears during ShowAfterKillAfter(),</para>
            <para>will be called when Impulse stops for ImpulseStopAfter(),</para>
            <para>will be called when flashing starts for StartAfterFlashContinuous(),</para>
            <para>will be called when flashing starts for StartAfterStopAfter() and when flashing stops,</para>
            <para>will be called when flashing starts for FlashAfterKillAfter(),</para>
            <para>will be called when flashing stops for FlashStopAfter(),</para>
            
            in other general circumstances you can use ShowCallBack, HideCallBack to call methods for flashing (sounds etc...) and FuneralCallBack for sprite death
            </summary>
        </member>
        <member name="F:Engine.Timing._impulse">
            <summary>
            holds the force to be applied
            </summary>
        </member>
        <member name="F:Engine.Timing._allowOverWrite">
            <summary>
            determines if duplicate actions should reset values
            </summary>
        </member>
        <member name="F:Engine.Timing._method">
            <summary>
            holds the current flashing method to employ
            </summary>
        </member>
        <member name="F:Engine.Timing._elapsedTime">
            <summary>
            holds the elapsed time so far for this timer
            </summary>
        </member>
        <member name="F:Engine.Timing._actionTime">
            <summary>
            timer used to specify at which time an action should take place
            </summary>
        </member>
        <member name="F:Engine.Timing._mySprite">
            <summary>
            The ref to the sprite to access Show() and Hide()
            </summary>
        </member>
        <member name="F:Engine.Timing._hidden">
            <summary>
            are we visible or not used to see if _flashCounter is tracking on or off duration
            </summary>
        </member>
        <member name="F:Engine.Timing._phase">
            <summary>
            stores current phase of flashing
            </summary>
        </member>
        <member name="P:Engine.Timing.GetPhase">
            <summary>
            gets the current phase of a sprites timing actions for multipart actions such as
            when using StartAfterStopAfter() 
            </summary>
        </member>
        <member name="P:Engine.Timing.Active">
            <summary>
            Gets Active status of flashing, true means flashing active
            </summary>
        </member>
        <member name="P:Engine.Timing.InActive">
            <summary>
            Gets the InActive status of flashing, true means no flashing
            </summary>
        </member>
        <member name="M:Engine.Timing.#ctor(Engine.Sprite)">
            <summary>
            Creates a new Sprite Timer
            </summary>
            <param name="s">store the reference to the sprite</param>
        </member>
        <member name="M:Engine.Timing.FlashContinuous(System.Single,System.Single)">
            <summary>
            Flashes a sprite continuously
            </summary>
            <param name="onDuration">number of seconds to display</param>
            <param name="offDuration">number of seconds to hide</param>
        </member>
        <member name="M:Engine.Timing.KillAfter(System.Single)">
            <summary>
            Kill sprite once the given time has elapsed
            <param name="killAfterThis">the number of seconds that should elapse before death</param>
            </summary>
            <remarks>This is very useful if you want to introduce Sprites with a limited life span, such
            as bullets, bonus displays, Get Ready etc...</remarks>
            <example>This example sets up a Sprite to live for 0.5 seconds
            <code>
            s.TimerActions.KillAfter(0.5f);
            </code>
            </example>
        </member>
        <member name="M:Engine.Timing.FlashStopAfter(System.Single,System.Single,System.Single)">
            <summary>
            Setup the Flashing to stop once the given time has elapsed, sprite then displays permanently
            <param name="stopAfterTime">the number of seconds that should elapse before flashing stops</param>
            <param name="onDuration">how many seconds to show on screen during flashing</param>
            <param name="offDuration">how many seconds to hide on screen during flashing</param>
            </summary>
            <remarks>Very useful for showing something is invunerable for a few seconds by flashing it</remarks>
            <example>
            This example sets a very quick flash lasting for 2 seconds
            <code>
            s.TimerActions.StopFlashingAfterTime(2, 0.05f, 0.05f);
            </code>
            </example>
        </member>
        <member name="M:Engine.Timing.ImpulseStopAfter(System.Single,Microsoft.Xna.Framework.Vector3)">
            <summary>
            sets up a timer to allow an impulse force to be applied for a certain amount of time
            </summary>
            <param name="stopAfterTime">the time period during which the force will be applied</param>
            <param name="force">The degree of force in newtons to apply</param>
        </member>
        <member name="M:Engine.Timing.ImpulseOnce(Microsoft.Xna.Framework.Vector3)">
            <summary>
            Applies an impulse force once
            </summary>
            <param name="force">The degree of force in newtons to apply</param>
        </member>
        <member name="M:Engine.Timing.StopAfterKill(System.Single,System.Single,System.Single)">
            <summary>
            Setup the Flashing to stop once the given time has elapsed, then kills sprite
            <param name="stopAfterTime">the number of seconds that should elapse before flashing stops</param>
            <param name="onDuration">how many seconds to show on screen during flashing</param>
            <param name="offDuration">how many seconds to hide on screen during flashing</param>
            </summary>
            <remarks>Useful if you want to flash a message then make it dissapear after a period of time</remarks>
            <example>
            This example sets up flashing to stop after 10 seconds killing the Sprite, it stays on for 
            half a second and off for 2 tenths of a second
            <code>
            s.TimerActions.StopAfterKill(10, 0.5f, 0.2f);
            </code>
            </example>
        </member>
        <member name="M:Engine.Timing.FlashAfter(System.Single,System.Single,System.Single)">
            <summary>
            Setup the Flashing to start once the given time has elapsed
            <param name="startAfterThis">the number of seconds that should elapse before flashing starts</param>
            <param name="onDuration">how many seconds to show on screen during flashing </param>
            <param name="offDuration">how many seconds to hide on screen during flashing</param>
            </summary>
            <remarks>Can use this to have a sprite appear normal to start with then start flashing to
            signify something</remarks>
            <example>Sets up a Sprite which will start flashing after 15 seconds on off for a tenth of a second
            <code>
            s.TimerActions.StartFlashingAfterTime(15, 0.1f, 0.1f);
            </code>
            </example>
        </member>
        <member name="M:Engine.Timing.EventContinous(System.Single,Engine.SpriteCallBack)">
            <summary>
            Specifies an event to trigger after a certain amount of time. The event will loop
            </summary>
            <param name="interval">the time period before event fires</param>
            <param name="spriteEvent">the SpriteHandler to call when time elapses</param>
        </member>
        <member name="M:Engine.Timing.EventOnce(System.Single,Engine.SpriteCallBack)">
            <summary>
            Specifies an event to trigger after a certain amount of time. The event will stop after being called once
            </summary>
            <param name="interval">the time period before event fires</param>
            <param name="spriteEvent">the SpriteHandler to call when time elapses</param>
        </member>
        <member name="M:Engine.Timing.ShowAfter(System.Single)">
            <summary>
            makes a sprite visible after a period of time
            </summary>
            <param name="startAfterThis">The timer period before the sprite should be shown</param>
        </member>
        <member name="M:Engine.Timing.ShowAfterFlashContinuous(System.Single,System.Single,System.Single)">
            <summary>
            Makes a sprite hidden for a period of time then allows it to flash at the given rate
            </summary>
            <param name="startAfterThis">The time to stay hidden</param>
            <param name="onDuration">How long to display on screen during flashing</param>
            <param name="offDuration">How long to hide from screen during flashing</param>
        </member>
        <member name="M:Engine.Timing.StartAfterStopAfter(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            starts flashing after start time elapses then continuous to flash until stop time elapses, stays visible
            </summary>
            <param name="startAfterTime">the number of seconds that should elapse before flashing starts</param>
            <param name="stopAfterTime">the number of seconds that should elapse before flashing stops</param>
            <param name="onDuration">how many seconds to show on screen during flashing</param>
            <param name="offDuration">how many seconds to hide on screen during flashing</param>
            <remarks>This can be used to make a Sprite Flash but not straight away and then go back to normal</remarks>
            <example>
            This timer is setup to flash after 3 seconds, and flash for 5 seconds at 10th second on and off
            <code>
            s.TimerActions.StartAfterStopAfter(3, 5, 0.1f, 0.1f);
            </code>
            </example>
        </member>
        <member name="M:Engine.Timing.FlashAfterKillAfter(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            starts flashing after start time elapses then continuous to flash until stop time elapses then kills
            </summary>
            <param name="startAfterThis">the number of seconds that should elapse before flashing starts</param>
            <param name="killAfterThis">the number of seconds that should elapse before flashing kills</param>
            <param name="onDuration">how many seconds to show on screen during flashing</param>
            <param name="offDuration">how many seconds to hide on screen during flashing</param>
            <remarks>This is great for pickups, which should only be available for a limited amount of time.
            You can setup a sprite to remain normal for 5 seconds, then start flashing for a further 5 seconds then be Killed,
            given the player 10 seconds to pick it up.</remarks>
            <example>Setup a sprite to remain normal for 5 seconds, then start flashing for a further 5 seconds then be Killed,
            given the player 10 seconds to pick it up.
            <code>
             s.TimerActions.StartFlashingAfterTimeThenKillAfterTime(5, 5, 0.1f, 0.1f);
            </code>
            </example>
        </member>
        <member name="M:Engine.Timing.ShowAfterKillAfter(System.Single,System.Single)">
            <summary>
            shows a sprite after start time elapses until stop time elapses then kills
            </summary>
            <param name="startAfterThis">the number of seconds that should elapse before sprite appears</param>
            <param name="killAfterThis">the number of seconds that should elapse before flashing kills</param>
        </member>
        <member name="M:Engine.Timing.OverwriteEnable">
            <summary>
            Allows modification of timing settings after they have been set
            </summary>
            <remarks>This allows you to change the flash rate without changing the 
            flashing mode.
            The default is disabled (can't change timing).</remarks>
        </member>
        <member name="M:Engine.Timing.OverwriteDisable">
            <summary>
            Disbles Flash rate changes
            </summary>
            <remarks>This is the default, you can't alter flash rate unless
            you change the flashing mode</remarks>
        </member>
        <member name="M:Engine.Timing.Off(System.Boolean)">
            <summary>
            turns flashing off
            </summary>
            <param name="display">If true sets sprite to display, if false sprite is hidden</param>
        </member>
        <member name="M:Engine.Timing.Update">
            <summary>
            performs flashing duties for this sprite
            called from Sprite update method
            </summary>
        </member>
        <member name="M:Engine.Timing.SortVisibilityTest">
            <summary>
            Used to check physical show/hide time for sprite
            used by all methods except the pure killer
            </summary>
        </member>
        <member name="M:Engine.Timing.Clone">
            <summary>
            Clones the timer settings
            </summary>
            <returns>A fully cloned new timing system for the sprite</returns>
        </member>
        <member name="T:Engine.Track">
            <summary>
            a simple class to hold a track number and an offset
            to apply to the track
            </summary>
        </member>
        <member name="F:Engine.Track.trackId">
            <summary>
            unique id created for every track used?
            </summary>
        </member>
        <member name="P:Engine.Track.Offset">
            <summary>
            The offset to displace the original track positions by
            </summary>
            <remarks>This can be used to make use of the shape of a pre-defined track
            but starting at a different position to its original definition</remarks>
        </member>
        <member name="F:Engine.Track._offset">
            <summary>
            holds the offset for this track
            </summary>
        </member>
        <member name="F:Engine.Track.trackDef">
            <summary>
            holds a reference to the raw track data being used
            </summary>
        </member>
        <member name="F:Engine.Track.Visible">
            <summary>
            specifies whether track should be drawn or not
            </summary>
        </member>
        <member name="F:Engine.Track.Moving">
            <summary>
            specifies whether the track definition is designated as moving
            </summary>
        </member>
        <member name="M:Engine.Track.#ctor(Engine.TrackDefinition)">
            <summary>
            Constructs a new track manager track from given track definition
            </summary>
            <param name="trackDef">The track definition to add to the track manager</param>
        </member>
        <member name="M:Engine.Track.#ctor(Engine.TrackDefinition,Microsoft.Xna.Framework.Vector3)">
            <summary>
            Constructs a new track manager track from given track definition with an offset
            </summary>
            <param name="trackDef">The track definition to add to the track manager</param>
            <param name="offset">The 3d displacement to apply to this track</param>
        </member>
        <member name="F:Engine.Track.dirtyMe">
            <summary>
            specifed true if the offset has been changed
            </summary>
        </member>
        <member name="P:Engine.Track.IsDirty">
            <summary>
            gets (resetting in the process) the dirty status of a track
            </summary>
        </member>
        <member name="P:Engine.Track.IsMeDirty">
            <summary>
            gets or set the dirty status of the track, when reading this is reset
            </summary>
        </member>
        <member name="T:Engine.TrackDefinition">
            <summary>
            holds a collection of points that are used by the track manager
            to direct sprites along pre-described paths
            </summary>
        </member>
        <member name="F:Engine.TrackDefinition.Points">
            <summary>
            a collection of points
            </summary>
        </member>
        <member name="F:Engine.TrackDefinition.Name">
            <summary>
            An internal name only used for debugging purposes
            </summary>
        </member>
        <member name="F:Engine.TrackDefinition.Length">
            <summary>
            the length of the track in pixels
            </summary>
        </member>
        <member name="F:Engine.TrackDefinition.DisplayNumber">
            <summary>
            Number of points to display on the track
            </summary>
        </member>
        <member name="F:Engine.TrackDefinition.ColorWash">
            <summary>
            wash for the track
            </summary>
        </member>
        <member name="F:Engine.TrackDefinition.Marker">
            <summary>
            A sprite with just a single frame definition
            </summary>
        </member>
        <member name="F:Engine.TrackDefinition.pointsOverLength">
            <summary>
            pre calculate value giving us the ratio of points to length
            for velocity calculations during the TrackManager update
            </summary>
        </member>
        <member name="F:Engine.TrackDefinition._dirty">
            <summary>
            specifies if a track has been transformed
            </summary>
        </member>
        <member name="P:Engine.TrackDefinition.IsDirty">
            <summary>
            Gets the dirty (transformed) status of a track, resetting it in the process 
            or sets the dirty status
            </summary>
        </member>
        <member name="M:Engine.TrackDefinition.Dirty">
            <summary>
            forces a track to marked as transformed
            this is important for when lines have been drawn
            </summary>
        </member>
        <member name="T:Engine.TrackHelper">
            <summary>
            provides methods for creating and manipulating tracks
            </summary>
        </member>
        <member name="T:Engine.TrackHelper.WayPoint">
            <summary>
            holds information about portions of point based tracks
            </summary>
        </member>
        <member name="F:Engine.TrackHelper.WayPoint.xstep">
            <summary>
            the x step in unit terms as proportion of distance
            </summary>
        </member>
        <member name="F:Engine.TrackHelper.WayPoint.ystep">
            <summary>
            the x step in unit terms as proportion of distance
            </summary>
        </member>
        <member name="F:Engine.TrackHelper.WayPoint.zstep">
            <summary>
            the x step in unit terms as proportion of distance
            </summary>
        </member>
        <member name="F:Engine.TrackHelper.WayPoint.distance">
            <summary>
            the distance (by pythagorus of this WayPoint
            </summary>
        </member>
        <member name="F:Engine.TrackHelper.WayPoint.start">
            <summary>
            start point
            </summary>
        </member>
        <member name="F:Engine.TrackHelper.WayPoint.end">
            <summary>
            end point
            </summary>
        </member>
        <member name="M:Engine.TrackHelper.WayPoint.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single,System.Single,System.Single,System.Double)">
            <summary>
            quick constructor
            </summary>
            <param name="start">start of waypoint</param>
            <param name="end">end of wapoint</param>
            <param name="xs">stepping for waypoint</param>
            <param name="ys">stepping for waypoint</param>
            <param name="zs">stepping for waypoint</param>
            <param name="dist">distance for this waypoint</param>
        </member>
        <member name="M:Engine.TrackHelper.SpeedForTime(Engine.TrackDefinition,System.Single)">
            <summary>
            Calculates the speed required to traverse a specified track in the timeperiod given
            </summary>
            <param name="track">The track to traverse</param>
            <param name="timePeriod">The time you want to take moving along the track</param>
            <returns>The speed required in pixels per second</returns>
        </member>
        <member name="M:Engine.TrackHelper.Clone(Engine.TrackDefinition,System.String)">
            <summary>
            Takes an existing track definition and copies it creating a new track
            </summary>
            <param name="existingTrack">The existing track to clone</param>
            <param name="newTrackName">The debug name of the new track</param>
            <returns>The newly cloned track definition</returns>
        </member>
        <member name="M:Engine.TrackHelper.GetLength(Engine.TrackDefinition)">
            <summary>
            Determines the length of the track in pixels and also pre-calculates
            the ratio points/length for update calculations
            </summary>
            <param name="newTrack">track definition to approximate the length of</param>
            <returns>the newly created track</returns>
        </member>
        <member name="M:Engine.TrackHelper.FromTexture(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle,System.String)">
            <summary>
            defines a track from an image supplied in a texture.
            The image MUST NOT use Anti-Aliasing
            </summary>
            <param name="texture">The texture containg a track</param>
            <param name="region">the portion of the texture to find the track in</param>
            <param name="newTrackName">the name to give the generated track</param>
            <returns>the newly created track</returns>
        </member>
        <member name="M:Engine.TrackHelper.RawPoints(System.String,System.Collections.Generic.List{Microsoft.Xna.Framework.Vector3})">
            <summary>
            Creates a track with only the points specified
            </summary>
            <param name="newTrackName">The debug name to give to the track</param>
            <param name="points">The List Vector3 of the points you want</param>
            <returns>the newly created track</returns>
            <remarks>Use this to move a sprite to fixed positions</remarks>
        </member>
        <member name="M:Engine.TrackHelper.Smooth(System.String,System.Int32,System.Collections.Generic.List{Microsoft.Xna.Framework.Vector3})">
            <summary>
            Creates a smoothed off track based on the points given.
            As this is a Beizer curve the points at the ends as control points bounding the curve
            </summary>
            <param name="newTrackName">The debug name to give the track</param>
            <param name="numberOfPoints">The number of points to give the track</param>
            <param name="points">The List Vector3 of the points you want to create the track from</param>
            <returns>the newly created track</returns>
        </member>
        <member name="M:Engine.TrackHelper.CloneSmooth(Engine.TrackDefinition,System.Int32,System.String)">
            <summary>
            Generates a new smooth track from the specified track, 
            </summary>
            <param name="existingTrack">The track you want to use
             for the control points of the smoother</param>
            <param name="numberOfPoints">The number of points to use on the track</param>
            <param name="newTrackName">The debug name to give the new track</param>
            <returns>the newly created track</returns>
            <remarks>Be sure not to use tracks with too many points, only use those that were added using RawPoints</remarks>
        </member>
        <member name="M:Engine.TrackHelper.CatmullRomClosed(System.String,System.Int32,System.Collections.Generic.List{Microsoft.Xna.Framework.Vector3})">
            <summary>
            Creates a smooth track than joins to its start from the points given using Catmull-Rom interpolatio
            </summary>
            <param name="newTrackName">The name of the track created</param>
            <param name="pointsPerStep">How many points to smoothly generate between each point in the original list</param>
            <param name="basePoints">the list of points that the curve will go through</param>
            <returns></returns>
        </member>
        <member name="M:Engine.TrackHelper.CR3D(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,System.Single)">
            <summary>
            creates a position along a CatmullRom interpolation
            </summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="v3"></param>
            <param name="v4"></param>
            <param name="amount">what position along spline</param>
            <returns></returns>
        </member>
        <member name="M:Engine.TrackHelper.CatmullRomOpen(System.String,System.Int32,System.Collections.Generic.List{Microsoft.Xna.Framework.Vector3})">
            <summary>
            creates a smooth Catmull-Rom line along the points given
            </summary>
            <param name="newTrackName">The name to give to the new track</param>
            <param name="pointsPerStep">How many points to smoothly generate between each point in the original list</param>
            <param name="basePoints">The list of control points we want to go through</param>
            <returns>A new track with nice smooth paths</returns>
        </member>
        <member name="M:Engine.TrackHelper.InterpolateCR(System.Int32,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>
            generates points between four outlying control points
            </summary>
            <param name="detail"></param>
            <param name="v1"></param>
            <param name="v2"></param>
            <param name="v3"></param>
            <param name="v4"></param>
            <returns></returns>
        </member>
        <member name="M:Engine.TrackHelper.Bezier(System.Collections.Generic.List{Microsoft.Xna.Framework.Vector3},System.Int32,System.Single)">
            <summary>
            Produces a generalised beizer curve using the points given as control points
            </summary>
            <param name="p">control points</param>
            <param name="n">number of points</param>
            <param name="mu">mu is position along the curve 0 is start, 1 is end</param>
            <returns>Returns point on curve</returns>
        </member>
        <member name="M:Engine.TrackHelper.PointsOld(System.String,System.Int32,System.Collections.Generic.List{Microsoft.Xna.Framework.Vector3})">
            <summary>
            Creates a track based on a sequence of points, you 
            set them the same for a level track
            </summary>
            <param name="newTrackName">The debug name of the track to create</param>
            <param name="numberOfPoints">How many points you want the entire track to contain
            (they are distributed along the entire track length, the more points the more flexability you have with 
            speeds travelling along the path</param>
            <param name="points">a list of points defining the fixed position along the track</param>
            <returns>the newly created track</returns>
            <remarks>You can use this to make specific paths for sprites to follow</remarks>
        </member>
        <member name="M:Engine.TrackHelper.Points(System.String,System.Int32,System.Collections.Generic.List{Microsoft.Xna.Framework.Vector3})">
            <summary>
            Creates a track based on a sequence of points, you 
            set them the same for a level track
            </summary>
            <param name="newTrackName">The debug name of the track to create</param>
            <param name="numberOfPoints">How many points you want the entire track to contain
            (they are distributed along the entire track length, the more points the more flexability you have with 
            speeds travelling along the path</param>
            <param name="points">a list of points defining the fixed position along the track</param>
            <returns>the newly created track</returns>
            <remarks>You can use this to make specific paths for sprites to follow</remarks>
        </member>
        <member name="M:Engine.TrackHelper.PointsForceZ(System.String,System.Int32,System.Collections.Generic.List{Microsoft.Xna.Framework.Vector3},System.Single)">
            <summary>
            Generates a track with a number of points overriding the z value
            </summary>
            <param name="newTrackName">The debug name of the track</param>
            <param name="numberOfPoints">How many points you want the entire track to contain
            (they are distributed along the entire track length, the more points the more flexability you have with 
            speeds travelling along the path</param>
            <param name="points">The points which define the track</param>
            <param name="forcedZ">The z value to set all the points to</param>
            <returns>the newly created track</returns>
        </member>
        <member name="M:Engine.TrackHelper.PointsForceZOld(System.String,System.Int32,System.Collections.Generic.List{Microsoft.Xna.Framework.Vector3},System.Single)">
            <summary>
            Generates a track with a number of points overriding the z value
            </summary>
            <param name="newTrackName">The debug name of the track</param>
            <param name="numberOfPoints">How many points you want the entire track to contain
            (they are distributed along the entire track length, the more points the more flexability you have with 
            speeds travelling along the path</param>
            <param name="points">The points which define the track</param>
            <param name="forcedZ">The z value to set all the points to</param>
            <returns>the newly created track</returns>
        </member>
        <member name="M:Engine.TrackHelper.Helix(System.String,System.Int32,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            creates a sinewave with a rotating z component 
            this will allow ever changing circular Z values that can be used for scaling effects
            or just to add nice parallax effects
            </summary>
            <param name="trackName">The debug name to give the track</param>
            <param name="numberOfPoints">How many points to place in the final track</param>
            <param name="start">The right hand X position of the sine wave</param>
            <param name="end">The left hand X position of the sine wave</param>
            <param name="waveAmplitude">The amplitude (the vertical size) of the wave</param>
            <param name="waveFrequency">The number of cycles of the sine wave you want</param>
            <param name="waveStartAngle">The phase (angle) to start sine wave at in radians - 
            use MathHelper.ToRadians(45) to specify value in degrees</param>
            <param name="waveDirection">specify either 1 or -1</param>
            <param name="centreHeight">The central height of the wave form</param>
            <param name="helixAmplitude">The amplitude of the Z value (depth movement front to back)</param>
            <param name="helixPhaseOffset">altering this effects where the track is furthest away. Leave as 0 unless you want to experiment</param>
            <param name="helixRadialDirection">specify either 1 or -1</param>
            <returns>the newly created track</returns>
            <example>
            <code>
            gameTracks.AddHelixTrack("helix", 400, 830, -30, 80, 2, 0, 1, 300, 80, 0, 1);
            </code>
            </example>
        </member>
        <member name="M:Engine.TrackHelper.SineWaveSimple(System.String,System.Int32,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates a simple sineWave shape
            Use AddHelixTrack if you want something that varies the Z position along the track
            </summary>
            <param name="newTrackName">The name to give the track</param>
            <param name="numberOfPoints">How many points to place in the final track</param>
            <param name="start">The right hand X position of the sine wave</param>
            <param name="end">The left hand X position of the sine wave</param>
            <param name="waveAmplitude">The amplitude (the vertical size) of the wave</param>
            <param name="waveFrequency">The number of cycles of the sine wave you want, 
            you can use 0.5f to generate half a sine wave</param>
            <param name="centreHeight">The central height of the wave form</param>
            <param name="depth">the Z position of the sine wave track</param>
            <returns>the newly created track</returns>
            <example>
            <code>
            gameTracks.AddSineWaveTrack("Sine", 100, 800, 0, 200, 0.25f, 300,100);
            </code>
            </example>
        </member>
        <member name="M:Engine.TrackHelper.Translate(Engine.TrackDefinition,System.Single,System.Single,System.Single)">
            <summary>
            moves a track in the X, y and z positions specified
            </summary>
            <param name="existingTrack">The track definition to translate</param>
            <param name="x">the amount in the x direction to move the track</param>
            <param name="y">the amount in the y direction to move the track</param>
            <param name="z">the amount in the z direction to move the track</param>
        </member>
        <member name="M:Engine.TrackHelper.Translate(Engine.TrackDefinition,Microsoft.Xna.Framework.Vector3)">
            <summary>
            moves a track in the X, y and z positions specified in the vector3 value
            </summary>
            <param name="existingTrack">The track definition to translate</param>
            <param name="translation">A vector3 value containing the X, Y and Z movements for track</param>
        </member>
        <member name="M:Engine.TrackHelper.Scale(Engine.TrackDefinition,Microsoft.Xna.Framework.Vector3,System.Single,System.Single,System.Single)">
            <summary>
            scales a specific track around the origin given
            </summary>
            <param name="existingTrack">The track definition to rotate</param>
            <param name="origin">The rotational centre</param>
            <param name="x">The scale factor for X axis</param>
            <param name="y">The scale factor for Y axis</param>
            <param name="z">The scale factor for Z axis</param>
        </member>
        <member name="M:Engine.TrackHelper.Rotate(Engine.TrackDefinition,Microsoft.Xna.Framework.Vector3,System.Single,System.Single,System.Single)">
            <summary>
            Rotates the supplied track around an arbitrary point, by the angles given
            </summary>
            <param name="existingTrack">The track definition to rotate</param>
            <param name="origin">The rotational centre</param>
            <param name="angleX">The rotation in degrees around the X axis</param>
            <param name="angleY">The rotation in degrees around the Y axis</param>
            <param name="angleZ">The rotation in degrees around the Z axis</param>
            <remarks>You should ideally rotate around each axis separately</remarks>
        </member>
        <member name="M:Engine.TrackHelper.Rotate(Engine.TrackDefinition,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>
            Rotates a track around a central position by the given angles specifed
            </summary>
            <param name="existingTrack">The name of the track to rotate</param>
            <param name="origin">the centre of rotation</param>
            <param name="angles">the x, y and z axis rotation amounts specified as a Vector3</param>
            <remarks>You should ideally rotate around each axis separately</remarks>
        </member>
        <member name="M:Engine.TrackHelper.SineWaveComplex(System.String,System.Int32,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates a sine Wave shape wpecifying some more complex parameters
            Use AddHelixTrack if you want something that varies the Z position along the track
            </summary>
            <param name="newTrackName">The debug name of the track</param>
            <param name="numberOfPoints">How many points to place in the final track</param>
            <param name="start">The right hand X position of the sine wave</param>
            <param name="end">The left hand X position of the sine wave</param>
            <param name="waveAmplitude">The amplitude (the vertical size) of the wave</param>
            <param name="waveFrequency">The number of cycles of the sine wave you want, 
            you can use 0.5f to generate half a sine wave</param>
            <param name="waveStartAngle">The phase (angle) to start sine wave at in radians - 
            use MathHelper.ToRadians(45) to specify value in degrees</param>
            <param name="waveDirection">specify either 1 or -1</param>
            <param name="centreHeight">The central height of the wave form</param>
            <param name="depth">the Z position of the sine wave track</param>
            <returns>the newly created track</returns>
            <example>
            <code>
            gameTracks.AddSineWaveTrack("sine", 300, 400, 0, 100, 2, (float)(Math.PI / 2), 1, 400,100);
            </code>
            </example>
        </member>
        <member name="M:Engine.TrackHelper.Circle(System.String,System.Int32,Microsoft.Xna.Framework.Vector3,System.Single)">
            <summary>
            Create a track which is circular, if you want to lean the circle over use the Rotate helpers
            </summary>
            <param name="trackName">The debug name to give the track</param>
            <param name="numberOfPoints">the number of positions on the track required</param>
            <param name="centre">The centre position of the circle</param>
            <param name="radius">the radius of the track</param>
        </member>
        <member name="M:Engine.TrackHelper.Ellipse(System.String,System.Int32,Microsoft.Xna.Framework.Vector3,System.Single,System.Single)">
            <summary>
            Creates an elliptical track
            </summary>
            <param name="newTrackName">The debug name of the track</param>
            <param name="numberOfPoints">the number of points to create</param>
            <param name="centre">the centre of the ellipse</param>
            <param name="radiusX">the horizontal radius</param>
            <param name="radiusY">the vertical radius</param>
        </member>
        <member name="M:Engine.TrackHelper.Spiral(System.String,System.Int32,Microsoft.Xna.Framework.Vector3,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates a spiral shape
            </summary>
            <param name="newTrackName">The debug name of the track</param>
            <param name="numberOfPoints">number of points required along the track</param>
            <param name="centre">The centre of the spiral</param>
            <param name="radiusX">the horizontal radius</param>
            <param name="radiusY">the vertical radius</param>
            <param name="smallestRadius">the smallest value wanted for either radius. 
            the rate at which the radii shrink is determined by this and number of revolutions</param>
            <param name="revolutions">number of revolutions you want, 
            this can be a fractional value 1.5f would be a spiral with 1 and half turns</param>
            <param name="startZ">The starting Z value (depth into the screen)</param>
            <param name="endZ">The ending z value (depth into the screen)</param>
        </member>
        <member name="M:Engine.TrackHelper.Join(Engine.TrackDefinition,Engine.TrackDefinition,System.String)">
            <summary>
            Creates a new track which is made up of the first tracks points
            followed by the second tracks points
            </summary>
            <param name="trackOne">The track definition containing the first set of points</param>
            <param name="trackTwo">The track definition containing the second set of points</param>
            <param name="newTrackName">The name of the track created</param>
            <returns>The newly created track</returns>
            <remarks>Use this to make complex tracks which combine features from several
            tracks</remarks>
        </member>
        <member name="M:Engine.TrackHelper.Join(System.String,Engine.TrackDefinition[])">
            <summary>
            Creates a new track which is made up of the points from all the tracks specified int the 
            array tracks, starting with the first track and adding points from each subsequent one
            </summary>
            <param name="newTrackName">The name of the track created</param>
            <param name="tracks">an array of tracks to join</param>
            <returns>a new track definition containing the points of all the tracks given</returns>
        </member>
        <member name="T:Engine.TrackManager">
            <summary>
            Responsible for storing the Tracks (taken from the TrackBank) and manipulating the movement of a Sprite
            </summary>
            <remarks>In order to use Tracks with a Sprite you need to make sure you create
            a TrackManager and associate it with a Sprite when you create it</remarks>
        </member>
        <member name="P:Engine.TrackManager.InstantMove">
            <summary>
            if set to true then manual track position changes instantly afect the position of the sprite
            defaults to true, if this causes problems then set this to False
            </summary>
        </member>
        <member name="F:Engine.TrackManager.instantmove">
            <summary>
            if true 
            </summary>
        </member>
        <member name="F:Engine.TrackManager.rnd">
            <summary>
            random number generator for the class
            </summary>
        </member>
        <member name="F:Engine.TrackManager._trackList">
            <summary>
            A list of the tracks defined for this sprite
            </summary>
        </member>
        <member name="P:Engine.TrackManager.TrackList">
            <summary>
            gets a list of all the tracks for the sprite
            </summary>
        </member>
        <member name="F:Engine.TrackManager._trackEndAction">
            <summary>
            what to do when you get to the end of the current track
            </summary>
        </member>
        <member name="F:Engine.TrackManager.stepMode">
            <summary>
            Determines how sprite moves along the track
            defaults to pixelsPerSec to take account of the game clock
            </summary>
        </member>
        <member name="F:Engine.TrackManager.pixelsPerSec">
            <summary>
            The speed in pixels per seconds to move along the track
            </summary>
        </member>
        <member name="F:Engine.TrackManager.pixelsPerSecPreCalc">
            <summary>
            precalculated value so we just multply game time
            needs to re-calculated every time speed adjusted
            or track changes MUST IMPLEMENT THIS
            </summary>
        </member>
        <member name="P:Engine.TrackManager.PixelsPerSec">
            <summary>
            Sets the speed at which a sprite should travel along the track in pixels per second
            </summary>
        </member>
        <member name="M:Engine.TrackManager.SetPreCalc">
            <summary>
            needs to be called when pixelsPerSec changes or track being used changes
            </summary>
        </member>
        <member name="F:Engine.TrackManager.trackFractionalPos">
            <summary>
            holds the step distance fractionally so we can integer round
            </summary>
        </member>
        <member name="P:Engine.TrackManager.EndOfTrackCallBack">
            <summary>
            stores the the delegate routine to call when a sprite meets the end of a track
            </summary>
        </member>
        <member name="F:Engine.TrackManager._totalTravelled">
            <summary>
            how many track have I travelled along
            </summary>
        </member>
        <member name="F:Engine.TrackManager._trackCurrent">
            <summary>
            the index of the track in _trackList we are currently using
            </summary>
        </member>
        <member name="P:Engine.TrackManager.TrackCurrent">
            <summary>
            Allows you to manually change the track index at any time
            </summary>
            <remarks>Use with caution, you can often achieve the effect you want using
            the correct means of working with tracks</remarks>
        </member>
        <member name="P:Engine.TrackManager.CurrentTrackData">
            <summary>
            Retrieves the Track data (not a definition of the currently active track)
            The track definition is available within the Track object
            </summary>
        </member>
        <member name="F:Engine.TrackManager._trackPosition">
            <summary>
            the element position of the track we are currently looking at
            </summary>
        </member>
        <member name="F:Engine.TrackManager._trackStep">
            <summary>
            how much to move along the track by each update
            </summary>
        </member>
        <member name="F:Engine.TrackManager._saveTrackStep">
            <summary>
            holds the previous trackstep when paused
            ready to be restored
            </summary>
        </member>
        <member name="F:Engine.TrackManager._trackDirection">
            <summary>
            what direction to move along the track
            </summary>
        </member>
        <member name="F:Engine.TrackManager._mySprite">
            <summary>
            holds a reference to parent sprite
            </summary>
        </member>
        <member name="F:Engine.TrackManager._updateTimer">
            <summary>
            holds a timer that determines when the track position should
            be updated which ensure this is independant of frame rate
            </summary>
        </member>
        <member name="M:Engine.TrackManager.#ctor(Engine.Sprite)">
            <summary>
            Creates a new TrackManager for the Sprite.
            </summary>
            <param name="s">The sprite to associate the trackmanager with</param>
            <remarks>This is created by the Sprite itself if you passed a TrackBank when you create it</remarks>
        </member>
        <member name="P:Engine.TrackManager.EndAction">
            <summary>
            gets or sets the action that should be performed when a sprite reaches the end of 
            a track
            </summary>
        </member>
        <member name="P:Engine.TrackManager.TracksTravelled">
            <summary>
            Gets the number of tracks this sprite has travelled along
            </summary>
            <remarks>I don't know if I implemented this yet</remarks>
        </member>
        <member name="M:Engine.TrackManager.TravelledCountSet(System.Int32)">
            <summary>
            Set the value for number of tracks travelled
            this can be used for counting 
            </summary>
            <param name="newCount">The new setting value you require</param>
        </member>
        <member name="M:Engine.TrackManager.Pause">
            <summary>
            Stop sprite moving along track
            </summary>
            <remarks>Restart track movement using Resume()</remarks>
        </member>
        <member name="M:Engine.TrackManager.Resume">
            <summary>
            Restart a previously Paused() sprite
            </summary>
            <remarks>Don't use this without previously Pausing</remarks>
        </member>
        <member name="M:Engine.TrackManager.Detach">
            <summary>
            Disconnects Sprite from given tracks and sets velocity in last known direction
            </summary>
            <remarks>Can go back to track mode by setting MovementMode to automaticTrack or manualTrack</remarks>
        </member>
        <member name="M:Engine.TrackManager.AttemptToAutoUndraw(System.Boolean)">
            <summary>
            attempts to take value in lastTrackWas and performs the undraw operation
            </summary>
            <param name="drawNextTrack">if true we will attempt to draw the current track after removing previous</param>
        </member>
        <member name="P:Engine.TrackManager.UpdateInterval">
            <summary>
            gets the updated interval for the track update timer
            </summary>
        </member>
        <member name="M:Engine.TrackManager.Remove(System.Int32)">
            <summary>
            Removes a track at the given position.
            The position is the order in which the tracks were added
            The first track added is at position 0.
            If the last track removed is being followed by the sprite then it is
            detached from this track and the end track handler is called if enabled
            </summary>
            <param name="position">The track index for this sprite to remove</param>
        </member>
        <member name="M:Engine.TrackManager.AddTrack(Engine.TrackDefinition)">
            <summary>
            Adds a track from the TrackBank to be used by this Sprite
            </summary>
            <param name="trackDef">The previously generated track definition</param>
            <remarks>Make sure you have added Tracks to your TrackBank first</remarks>
        </member>
        <member name="M:Engine.TrackManager.AddTrackWithOffset(Engine.TrackDefinition,Microsoft.Xna.Framework.Vector3)">
            <summary>
            Adds a track to be used by this Sprite and modifies its starting position 
            by the amount given
            </summary>
            <param name="trackDef">the trackdefinition to add</param>
            <param name="offset">A 3d offset to apply to the original tracks positions</param>
        </member>
        <member name="M:Engine.TrackManager.AddTrackStartAt(Engine.TrackDefinition,Microsoft.Xna.Framework.Vector3)">
            <summary>
            Adds a track to a sprite and translates the track to a specified position
            </summary>
            <param name="trackDef">Track definition</param>
            <param name="startPos">The position to start the track</param>
            <remarks>Use this for a track shape that will be used for a sprite
            generated at a specific position (e.g bullet hell tracks)</remarks>
        </member>
        <member name="M:Engine.TrackManager.TravelWithStep(Engine.EndOfTrackAction,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Specifies how Sprite is to use the tracks allocated to it
            </summary>
            <param name="et">What to do when sprite reaches the end of the track</param>
            <param name="startTrack">The index of the tracks given to the Sprite using Add
            that you wish to start the Sprite on</param>
            <param name="step">The number of positions along the track you wish to move the Sprite
            during each update</param>
            <param name="direction">1 travel from start to end, -1 travel from end to start</param>
            <param name="startposition">Track position to start at, you must check it's in range</param>
            <remarks>This should be used after adding all tracks to a sprite</remarks>
        </member>
        <member name="M:Engine.TrackManager.TravelWithStep(Engine.EndOfTrackAction,System.Int32,System.Int32,System.Int32)">
            <summary>
            Specifies how Sprite is to use the tracks allocated to it
            </summary>
            <param name="et">What to do when sprite reaches the end of the track</param>
            <param name="startTrack">The index of the tracks given to the Sprite using Add
            that you wish to start the Sprite on</param>
            <param name="step">The number of positions along the track you wish to move the Sprite
            during each update</param>
            <param name="direction">1 travel from start to end, -1 travel from end to start</param>
            <remarks>This should be used after adding all tracks to a sprite</remarks>
        </member>
        <member name="M:Engine.TrackManager.TravelWithSpeed(Engine.EndOfTrackAction,System.Int32,System.Single,System.Int32,System.Int32)">
            <summary>
            Sets sprite to move along the track at constant speed irrespective of the frame rate
            </summary>
            <param name="et">What to do when you reach end of track</param>
            <param name="startTrack">The track to start at</param>
            <param name="speed">The speed in pixels per second to move at</param>
            <param name="direction">1 for forward, -1 for backward</param>
            <param name="startPosition">Track position to start at, you must check it's in range</param>
        </member>
        <member name="M:Engine.TrackManager.TravelWithSpeed(Engine.EndOfTrackAction,System.Int32,System.Single,System.Int32)">
            <summary>
            Sets sprite to move along the track at constant speed irrespective of the frame rate
            </summary>
            <param name="et">What to do when you reach end of track</param>
            <param name="startTrack">The track to start at</param>
            <param name="speed">The speed in pixels per second to move at</param>
            <param name="direction">1 for forward, -1 for backward</param>
        </member>
        <member name="P:Engine.TrackManager.PositionCurrent">
            <summary>
            Gets the current x, y and z position (game co-ordinates) along the current track
            </summary>
            <remarks>You shouldn't really need this</remarks>
        </member>
        <member name="M:Engine.TrackManager.TrackPositionNear(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Tries to locate a suitable position on the current track which is
            close to the position specified. If you want to jump from one track to another
            then you need to move to that track first then try this
            </summary>
            <param name="position">The 2d position to locate a point near</param>
            <returns>The Physical position along the track and the track position, 
            the W value holds the track position</returns>
        </member>
        <member name="M:Engine.TrackManager.GetAPositionNear(Microsoft.Xna.Framework.Vector2,System.Int32)">
            <summary>
            Tries to locate a suitable position on the current track which is
            close to the position specified. If you want to jump from one track to another
            then you need to move to that track first then try this
            </summary>
            <param name="position">The 2d position to locate a point near</param>
            <param name="trackNum">The track number (its position in the sprites list) that you wish to attach to</param>
            <returns>The Physical position along the track and the track position, 
            the W value holds the track position</returns>
        </member>
        <member name="M:Engine.TrackManager.TrackPositionNear(Microsoft.Xna.Framework.Vector3)">
            <summary>
            Tries to locate a suitable position on the current track which is
            close to the position specified taking into account the Z position as well.
            It then sets the sprite at this position on the track
            If you want to jump from one track to another
            then you need to move to that track first then try this
            </summary>
            <param name="position">The 3d position to locate a point near</param>
            <returns>The Physical position along the track and the track position, 
            the W value holds the track position</returns>
        </member>
        <member name="M:Engine.TrackManager.GetAPositionNear(Microsoft.Xna.Framework.Vector3,System.Int32)">
            <summary>
            Tries to locate a suitable position on the current track which is
            close to the position specified taking into account the Z position as well.
            Does not move Sprite to that position
            </summary>
            <param name="position">The 3d position to locate a point near</param>
            <param name="trackNum">The track number (its position in the sprites list) that you wish to attach to</param>
            <returns>The Physical position along the track and the track position, 
            the W value holds the track position</returns>
        </member>
        <member name="P:Engine.TrackManager.AtStart">
            <summary>
            Tells you if you are at the start of the current track
            the start depends on direction travelling
            </summary>
            <value>True means the sprite is at the start</value>
        </member>
        <member name="P:Engine.TrackManager.AtPhysicalStart">
            <summary>
            gets a value stating whether you are at the first position
            along a track
            </summary>
            <value>True means at first point, false means not</value>
        </member>
        <member name="P:Engine.TrackManager.AtPhysicalEnd">
            <summary>
            gets a value stating whether you are at the last position
            along a track
            </summary>
            <value>True means at last point, false means not</value>
        </member>
        <member name="P:Engine.TrackManager.AtEnd">
            <summary>
            Tells you if you are at the end of the current track
            </summary>
            <value>True means the sprite is at the end</value>
        </member>
        <member name="P:Engine.TrackManager.TrackPosition">
            <summary>
            Gets or sets the position along the current track
            </summary>
            <remarks>You shouldn't really need this</remarks>
        </member>
        <member name="P:Engine.TrackManager.TrackStep">
            <summary>
            Gets or Sets the step rate for the current track, how many positions to skip along
            </summary>
            <remarks>The larger the step value the quicker the Sprite will appear to move.
            Try to create your tracks with lots of positions, this will then give you flexability
            when trying to decide on the step size</remarks>
            <value>the higher the track step the faster the sprite will appear to move along the track</value>
        </member>
        <member name="P:Engine.TrackManager.TrackName">
            <summary>
            gets the track name of the currently used track
            </summary>
        </member>
        <member name="P:Engine.TrackManager.GetStartPosition">
            <summary>
            Gets the start position on the current track based on the direction travelling
            </summary>
        </member>
        <member name="P:Engine.TrackManager.GetEndPosition">
            <summary>
            gets the end position on the current track based on the direction travelling
            </summary>
        </member>
        <member name="M:Engine.TrackManager.PositionForward">
            <summary>
            Move forward along the current track
            </summary>
        </member>
        <member name="M:Engine.TrackManager.PositionBackward">
            <summary>
            Move backward along the current track
            </summary>
        </member>
        <member name="M:Engine.TrackManager.PositionFirst">
            <summary>
            Moves to the first position on the track
            </summary>
        </member>
        <member name="M:Engine.TrackManager.PositionLast">
            <summary>
            moves to the last position on the track
            </summary>
        </member>
        <member name="M:Engine.TrackManager.TrackNext">
            <summary>
            moves to the next track associated with this sprite
            </summary>
        </member>
        <member name="F:Engine.TrackManager.autoShowHide">
            <summary>
            if true the trackmanager will ensure tracks are displayed and hidden automatically
            as they are used by the sprite
            </summary>
        </member>
        <member name="F:Engine.TrackManager.lastTrackWas">
            <summary>
            holds the track number of the last track prior to changing it
            </summary>
        </member>
        <member name="F:Engine.TrackManager.drawing">
            <summary>
            specifies if a track us currently being drawn
            </summary>
        </member>
        <member name="F:Engine.TrackManager.lastLineStyle">
            <summary>
            holds the line style set so when we draw next track automatically we can use the same style
            </summary>
        </member>
        <member name="F:Engine.TrackManager.lastNumberOfLinesDrawn">
            <summary>
            holds the number of lines specified when drawing automatically so we can use the same number automatically
            </summary>
        </member>
        <member name="P:Engine.TrackManager.AutoShowHide">
            <summary>
            if true the trackmanager for the sprite will automatically draw and remove tracks as the sprite uses them
            </summary>
        </member>
        <member name="M:Engine.TrackManager.DrawTrack(Engine.LineData,System.Int32,System.Boolean)">
            <summary>
            tells the engine to draw the current track on the screen using the 
            given lines style
            </summary>
            <param name="lineStyle">LineData to render the line</param>
            <param name="lines">number of lines to draw</param>
            <param name="autoDraw">If true the track manager will automatically hide and show tracks for the sprite</param>
        </member>
        <member name="M:Engine.TrackManager.DrawTrack(System.Int32,System.Boolean)">
            <summary>
            tells the engine to draw the current track on the screen using default line style 
            </summary>
            <param name="lines">number of lines to draw</param>
            <param name="autoDraw">If true the track manager will automatically hide and show tracks for the sprite</param>
        </member>
        <member name="M:Engine.TrackManager.DrawTrack(System.Int32,System.Int32)">
            <summary>
            tells the engine to draw a specific track on the screen using default line style 
            </summary>
            <param name="trackNumber"></param>
            <param name="lines">number of lines to draw</param>
        </member>
        <member name="M:Engine.TrackManager.DrawTrack(System.Int32,Engine.LineData,System.Int32,System.Boolean)">
            <summary>
            tells the engine to draw a specific track being managed using the line style given
            </summary>
            <param name="trackNumber">track number from manager to draw</param>
            <param name="lineStyle">LineData settings to use</param>
            <returns>The lists of lines required to draw the track, these can then be dynamically manipulated for various effects</returns>
            <param name="lines">number of lines to draw</param>
            <param name="autoDraw">If true the track manager will automatically hide and show tracks for the sprite</param>
        </member>
        <member name="M:Engine.TrackManager.ReplaceTrack(Engine.TrackDefinition,System.Int32)">
            <summary>
            attempts to replace a track at the position given with a new track definition
            </summary>
            <param name="td">track to use</param>
            <param name="position">position of track to remove</param>
        </member>
        <member name="M:Engine.TrackManager.ReplaceTrack(Engine.TrackDefinition)">
            <summary>
            replaces the track at position 0. If not track exists then adds the new track
            </summary>
            <param name="td">Track definition to use instead af first one</param>
        </member>
        <member name="M:Engine.TrackManager.DrawTrackNoMore">
            <summary>
            stops the engine drawing the current track
            </summary>
        </member>
        <member name="M:Engine.TrackManager.DrawTrackNoMore(System.Int32)">
            <summary>
            stops the engine drawing the given track
            </summary>
            <param name="trackNumber">the track number of this track manager to remove</param>
        </member>
        <member name="M:Engine.TrackManager.TrackPrevious">
            <summary>
            moves to the previous track associated with this sprite
            </summary>
        </member>
        <member name="M:Engine.TrackManager.UpdateIntervalSet(System.Single)">
            <summary>
            sets the update interval for track re-positioning
            </summary>
            <param name="interval">time in seconds before moving to next position on the track</param>
        </member>
        <member name="M:Engine.TrackManager.CorrectTrack">
            <summary>
            Corrects any over steps and performs requested action
            </summary>
            <returns></returns>
        </member>
        <member name="M:Engine.TrackManager.Update">
            <summary>
            Perform the update of the Sprite's position using the current track settings
            </summary>
            <remarks>This is called by the Sprites Update method there is no need to call this yourself</remarks>
        </member>
        <member name="M:Engine.TrackManager.TrackDistance(System.Int32,System.Int32,System.Int32,System.Single)">
            <summary>
            works out the number of trackposition between the two track positions given
            </summary>
            <param name="start">the start position of the track</param>
            <param name="end">the position to move towards</param>
            <param name="numberOfPoints">number of points in the track</param>
            <param name="direction">direction of travel +ve is forwards -ve is backwards</param>
            <remarks>the number of trackpositions between these points</remarks>
        </member>
        <member name="T:Engine.VideoManager">
            <summary>
            handles playing of videos for the sprite you associate it with
            </summary>
        </member>
        <member name="P:Engine.VideoManager.VideoEndCallBack">
            <summary>
            a spritehandler which is called when then video gets to the end 
            gives you access to the sprite which was rendering the video if you want it
            </summary>
        </member>
        <member name="F:Engine.VideoManager.boss">
            <summary>
            holds reference to the owner of the video
            </summary>
        </member>
        <member name="F:Engine.VideoManager.video">
            <summary>
            holds a reference to the video file loaded with the content manager
            </summary>
        </member>
        <member name="F:Engine.VideoManager.player">
            <summary>
            holds a reference to the video player
            </summary>
        </member>
        <member name="P:Engine.VideoManager.State">
            <summary>
            gets the current player state of the video
            </summary>
        </member>
        <member name="M:Engine.VideoManager.Dispose">
            <summary>
            dispose of the video manager
            </summary>
        </member>
        <member name="F:Engine.VideoManager.framesRendered">
            <summary>
            holds number fo frames rendered for this video so far
            </summary>
        </member>
        <member name="P:Engine.VideoManager.FramesRendered">
            <summary>
            get the number of frames of video rendered for this video
            </summary>
        </member>
        <member name="M:Engine.VideoManager.#ctor(Microsoft.Xna.Framework.Media.Video)">
            <summary>
            Creates an instance of the video manager with the given video
            </summary>
            <param name="video">The video content for this manager to work with</param>
        </member>
        <member name="M:Engine.VideoManager.Stop">
            <summary>
            stops the video running and disables it's parent sprite
            </summary>
        </member>
        <member name="M:Engine.VideoManager.Pause">
            <summary>
            pauses a currently playing video, does nothing it it is not playing
            </summary>
        </member>
        <member name="M:Engine.VideoManager.Resume">
            <summary>
            resumes a currently paused video, does nothing if it is not paused
            </summary>
        </member>
        <member name="M:Engine.VideoManager.PlayLoop">
            <summary>
            Plays the video with the previously associated sprite repeatidly
            </summary>
        </member>
        <member name="M:Engine.VideoManager.PlayOnce">
            <summary>
            Plays the video with the previously associated sprite once then the sprite is killed
            </summary>
        </member>
        <member name="T:Engine.WorkUnit">
            <summary>
            used to store sprite update details for multiprocessor working
            </summary>
        </member>
        <member name="F:Engine.WorkUnit.start">
            <summary>
            index of first sprite
            </summary>
        </member>
        <member name="F:Engine.WorkUnit.end">
            <summary>
            index of sprite to work up to
            </summary>
        </member>
        <member name="F:Engine.WorkUnit.processor">
            <summary>
            XBOX only, the processor to associate this work unit with
            </summary>
        </member>
        <member name="F:Engine.WorkUnit.working">
            <summary>
            if true thread is still in process
            </summary>
        </member>
        <member name="M:Engine.WorkUnit.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a new work unit
            </summary>
            <param name="s">start sprite</param>
            <param name="e">end sprite</param>
        </member>
        <member name="M:Engine.WorkUnit.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            creates a work unit to be used with threaded helpers
            </summary>
            <param name="s">start sprite</param>
            <param name="e">end sprite</param>
            <param name="processorThread">the processor thread (XBOX only) to try to 
            associate the thread with</param>
        </member>
    </members>
</doc>
